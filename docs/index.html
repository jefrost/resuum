<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resuum - AI-Powered Resume Optimization</title>
    <style>
        /* Main Layout - Two Column */
        body { 
            font-family: system-ui, sans-serif; 
            margin: 0; 
            padding: 0; 
            background: #f5f5f5; 
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            padding: 1rem 0;
            background: white;
            border-bottom: 1px solid #e5e7eb;
        }
        .header h1 {
            color: #1e293b;
            font-size: 2.5rem;
            margin: 0 0 0.5rem 0;
        }
        .header p {
            color: #64748b;
            font-size: 1.1rem;
            margin: 0;
        }

        .main-container {
            flex: 1;
            display: flex;
            min-height: 0;
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 240px;
            background: white;
            border-right: 1px solid #e5e7eb;
            flex-shrink: 0;
            padding: 1rem;
        }

        .tab-navigation {
            width: 100%;
        }
        .tab-list {
            display: flex;
            flex-direction: column;
            list-style: none;
            margin: 0;
            padding: 0;
            gap: 4px;
        }
        .tab-item {
            width: 100%;
        }
        .tab-button {
            width: 100%;
            padding: 12px 16px;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 15px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
            text-align: left;
            color: #374151;
        }
        .tab-button:hover {
            background-color: #f3f4f6;
        }
        .tab-button--active {
            background-color: #e0f2fe;
            color: #0369a1;
            font-weight: 600;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 2rem;
        }

        .tab-content {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            flex: 1;
            overflow: auto;
        }
        
        /* Experience Tab Styles */
        .experience-header {
            margin-bottom: 2rem;
        }
        .section-title {
            color: #1e293b;
            margin-bottom: 1rem;
        }
        .embedding-summary {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1.5rem;
        }
        .summary-text {
            margin: 0;
            font-weight: 500;
        }
        .state-badges {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }
        .summary-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
        }
        .summary-badge--ready { background: #dcfce7; color: #166534; }
        .summary-badge--pending { background: #fef3c7; color: #92400e; }
        .summary-badge--stale { background: #fed7aa; color: #9a3412; }
        .summary-badge--failed { background: #fecaca; color: #991b1b; }
        
        /* Sub Navigation */
        .experience-sub-nav {
            margin-bottom: 1.5rem;
        }
        .sub-nav-list {
            display: flex;
            list-style: none;
            margin: 0;
            padding: 0;
            gap: 0.5rem;
        }
        .sub-nav-button {
            padding: 0.5rem 1rem;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sub-nav-button--active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        /* Table Styles */
        .table-controls {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .sort-select {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
        }
        .bullets-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        .bullets-table th,
        .bullets-table td {
            padding: 0.75rem;
            text-align: left;
            border: 1px solid #e5e7eb;
            vertical-align: top;
        }
        .bullets-table th {
            background: #f9fafb;
            font-weight: 600;
        }
        .bullets-table tr:nth-child(even) {
            background: #f9fafb;
        }
        
        /* State Badges */
        .state-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
            white-space: nowrap;
        }
        .state-badge--ready { background: #dcfce7; color: #166534; }
        .state-badge--pending { background: #fef3c7; color: #92400e; }
        .state-badge--stale { background: #fed7aa; color: #9a3412; }
        .state-badge--failed { background: #fecaca; color: #991b1b; }
        
        /* Quality Indicators */
        .quality-indicators {
            display: flex;
            gap: 0.25rem;
        }
        .quality-indicator {
            font-size: 1.2em;
        }
        .quality-indicator.active {
            opacity: 1;
        }
        .quality-indicator.inactive {
            opacity: 0.3;
        }
        
        /* Status Bar */
        .status-bar {
            margin-top: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
        }
        .status-bar--loading {
            background: #fef3c7;
            color: #92400e;
        }
        .status-bar--error {
            background: #fecaca;
            color: #991b1b;
        }
        .status-bar--success {
            background: #dcfce7;
            color: #166534;
        }
        .status-bar--hidden {
            display: none;
        }
        
        /* Form Styles */
        .form-group {
            margin-bottom: 1rem;
        }
        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        .form-input,
        .form-textarea,
        .form-select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-family: inherit;
        }
        .form-textarea {
            resize: vertical;
        }
        .form-submit {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
        }
        .form-submit:hover {
            background: #2563eb;
        }
        .form-submit:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        
        /* Utility Classes */
        .hidden { display: none; }
        .error { 
            background: #fecaca; 
            border: 1px solid #f87171; 
            padding: 1rem; 
            border-radius: 4px; 
            color: #991b1b; 
            margin: 1rem 0;
        }
        .success {
            background: #dcfce7;
            border: 1px solid #4ade80;
            padding: 1rem;
            border-radius: 4px;
            color: #166534;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>Resuum</h1>
        <p>AI-Powered Resume Optimization</p>
    </header>
    
    <div class="main-container">
        <div class="sidebar">
            <div id="sidebar-nav"></div>
        </div>
        
        <div class="main-content">
            <main id="app">
                <div id="loading">Loading application...</div>
            </main>
        </div>
    </div>

    <script>
        "use strict";
var Resuum = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // src/ui/xss-safe-rendering.ts
  function createSafeTextNode(text) {
    return document.createTextNode(text || "");
  }
  function setSafeTextContent(element, text) {
    element.textContent = "";
    element.appendChild(createSafeTextNode(text));
  }
  function createSafeElement(tagName, textContent, className) {
    const element = document.createElement(tagName);
    if (className) {
      element.className = className;
    }
    if (textContent) {
      setSafeTextContent(element, textContent);
    }
    return element;
  }
  function createErrorElement(message, title) {
    const container = createSafeElement("div", "", "error-message");
    if (title) {
      const titleElement = createSafeElement("h3", title, "error-title");
      container.appendChild(titleElement);
    }
    const messageElement = createSafeElement("p", message, "error-text");
    container.appendChild(messageElement);
    return container;
  }
  function createSuccessElement(message) {
    return createSafeElement("div", message, "success-message");
  }
  var init_xss_safe_rendering = __esm({
    "src/ui/xss-safe-rendering.ts"() {
      "use strict";
    }
  });

  // src/storage/schema.ts
  function handleSchemaUpgrade(event, db) {
    const oldVersion = event.oldVersion;
    console.log(`Upgrading database from version ${oldVersion} to ${DB_SCHEMA.version}`);
    if (oldVersion === 1) {
      if (db.objectStoreNames.contains("embeddings")) {
        db.deleteObjectStore("embeddings");
      }
      if (db.objectStoreNames.contains("embedQueue")) {
        db.deleteObjectStore("embedQueue");
      }
      console.log("Removed obsolete embedding stores");
    }
  }
  var DB_SCHEMA;
  var init_schema = __esm({
    "src/storage/schema.ts"() {
      "use strict";
      DB_SCHEMA = {
        name: "ResuumDB",
        version: 2,
        // Incremented for schema changes
        stores: [
          {
            name: "roles",
            keyPath: "id",
            indexes: [
              { name: "orderIndex", keyPath: "orderIndex" },
              { name: "company", keyPath: "company" },
              { name: "startDate", keyPath: "startDate" },
              { name: "endDate", keyPath: "endDate" }
            ]
          },
          {
            name: "projects",
            keyPath: "id",
            indexes: [
              { name: "roleId", keyPath: "roleId" },
              { name: "name", keyPath: "name" },
              { name: "createdAt", keyPath: "createdAt" },
              { name: "role_created", keyPath: ["roleId", "createdAt"] }
            ]
          },
          {
            name: "bullets",
            keyPath: "id",
            indexes: [
              { name: "roleId", keyPath: "roleId" },
              { name: "projectId", keyPath: "projectId" },
              { name: "source", keyPath: "source" },
              { name: "createdAt", keyPath: "createdAt" },
              { name: "role_project", keyPath: ["roleId", "projectId"] }
            ]
          },
          {
            name: "settings",
            keyPath: "key",
            indexes: []
          }
        ]
      };
    }
  });

  // src/storage/database.ts
  async function initializeDatabase() {
    if (dbInstance) {
      return dbInstance;
    }
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_SCHEMA.name, DB_SCHEMA.version);
      request.onerror = () => {
        reject(new Error(`Failed to open database: ${request.error?.message}`));
      };
      request.onsuccess = () => {
        dbInstance = request.result;
        console.log(`Database ${DB_SCHEMA.name} opened successfully`);
        resolve(dbInstance);
      };
      request.onupgradeneeded = (event) => {
        const db = request.result;
        console.log(`Upgrading database from version ${event.oldVersion} to ${DB_SCHEMA.version}`);
        handleSchemaUpgrade(event, db);
        DB_SCHEMA.stores.forEach((storeConfig) => {
          if (!db.objectStoreNames.contains(storeConfig.name)) {
            const store = db.createObjectStore(storeConfig.name, {
              keyPath: storeConfig.keyPath
            });
            storeConfig.indexes?.forEach((indexConfig) => {
              store.createIndex(
                indexConfig.name,
                indexConfig.keyPath,
                indexConfig.options
              );
            });
            console.log(`Created store: ${storeConfig.name}`);
          }
        });
      };
    });
  }
  async function getDatabase() {
    if (!dbInstance) {
      return initializeDatabase();
    }
    return dbInstance;
  }
  var dbInstance;
  var init_database = __esm({
    "src/storage/database.ts"() {
      "use strict";
      init_schema();
      dbInstance = null;
    }
  });

  // src/utils/uuid.ts
  function generateUUID() {
    if (typeof crypto !== "undefined" && crypto.getRandomValues) {
      const bytes = new Uint8Array(16);
      crypto.getRandomValues(bytes);
      if (bytes.length < 16) {
        throw new Error("Failed to generate sufficient random bytes");
      }
      bytes[6] = (bytes[6] ?? 0) & 15 | 64;
      bytes[8] = (bytes[8] ?? 0) & 63 | 128;
      const hex = Array.from(bytes).map((b) => (b ?? 0).toString(16).padStart(2, "0")).join("");
      return [
        hex.slice(0, 8),
        hex.slice(8, 12),
        hex.slice(12, 16),
        hex.slice(16, 20),
        hex.slice(20, 32)
      ].join("-");
    } else {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
  }
  function generateULID() {
    const timestamp = Date.now();
    const timestampPart = timestamp.toString(36).padStart(10, "0");
    const randomPart = generateRandomString(16);
    return `${timestampPart}_${randomPart}`;
  }
  function generateRandomString(length) {
    const chars = "0123456789abcdefghijklmnopqrstuvwxyz";
    let result = "";
    if (typeof crypto !== "undefined" && crypto.getRandomValues) {
      const bytes = new Uint8Array(length);
      crypto.getRandomValues(bytes);
      for (let i = 0; i < Math.min(bytes.length, length); i++) {
        const byteValue = bytes[i] ?? 0;
        result += chars[byteValue % chars.length] ?? "0";
      }
    } else {
      for (let i = 0; i < length; i++) {
        result += chars[Math.floor(Math.random() * chars.length)] ?? "0";
      }
    }
    return result;
  }
  function createId(type = "bullet") {
    if (type === "bullet" || type === "embed_queue") {
      return generateULID();
    }
    return generateUUID();
  }
  var init_uuid = __esm({
    "src/utils/uuid.ts"() {
      "use strict";
    }
  });

  // src/storage/transactions.ts
  async function getAll(storeName) {
    const db = await getDatabase();
    const transaction = db.transaction([storeName], "readonly");
    const store = transaction.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.getAll();
      request.onsuccess = () => resolve(request.result || []);
      request.onerror = () => reject(request.error);
    });
  }
  async function getById(storeName, id) {
    const db = await getDatabase();
    const transaction = db.transaction([storeName], "readonly");
    const store = transaction.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.get(id);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  async function create(storeName, record) {
    const db = await getDatabase();
    const transaction = db.transaction([storeName], "readwrite");
    const store = transaction.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.add(record);
      request.onsuccess = () => resolve(record);
      request.onerror = () => reject(request.error);
    });
  }
  async function update(storeName, record) {
    const db = await getDatabase();
    const transaction = db.transaction([storeName], "readwrite");
    const store = transaction.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.put(record);
      request.onsuccess = () => resolve(record);
      request.onerror = () => reject(request.error);
    });
  }
  async function deleteById(storeName, id) {
    const db = await getDatabase();
    const transaction = db.transaction([storeName], "readwrite");
    const store = transaction.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.delete(id);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  async function getSetting(key) {
    const db = await getDatabase();
    const transaction = db.transaction(["settings"], "readonly");
    const store = transaction.objectStore("settings");
    return new Promise((resolve, reject) => {
      const request = store.get(key);
      request.onsuccess = () => {
        const result = request.result;
        resolve(result ? result.value : null);
      };
      request.onerror = () => reject(request.error);
    });
  }
  async function setSetting(key, value) {
    const db = await getDatabase();
    const transaction = db.transaction(["settings"], "readwrite");
    const store = transaction.objectStore("settings");
    return new Promise((resolve, reject) => {
      const request = store.put({ key, value });
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  var init_transactions = __esm({
    "src/storage/transactions.ts"() {
      "use strict";
      init_database();
      init_uuid();
    }
  });

  // src/ui/bullet-validator.ts
  function getBulletValidator() {
    if (!globalBulletValidator) {
      globalBulletValidator = new BulletValidator();
    }
    return globalBulletValidator;
  }
  var VALIDATION_RULES, BulletValidator, globalBulletValidator;
  var init_bullet_validator = __esm({
    "src/ui/bullet-validator.ts"() {
      "use strict";
      VALIDATION_RULES = {
        minLength: 10,
        maxLength: 500,
        maxWords: 75
      };
      BulletValidator = class {
        /**
         * Validate bullet point text
         */
        validateText(text) {
          const errors = [];
          const warnings = [];
          if (!text || typeof text !== "string") {
            errors.push("Bullet point text is required");
            return { isValid: false, errors, warnings };
          }
          const trimmedText = text.trim();
          if (trimmedText.length === 0) {
            errors.push("Bullet point cannot be empty");
          } else if (trimmedText.length < VALIDATION_RULES.minLength) {
            errors.push(`Bullet point should be at least ${VALIDATION_RULES.minLength} characters long`);
          } else if (trimmedText.length > VALIDATION_RULES.maxLength) {
            errors.push(`Bullet point should be less than ${VALIDATION_RULES.maxLength} characters long`);
          }
          const wordCount = trimmedText.split(/\s+/).length;
          if (wordCount > VALIDATION_RULES.maxWords) {
            warnings.push(`Bullet point has ${wordCount} words. Consider keeping it under ${VALIDATION_RULES.maxWords} words for readability`);
          }
          if (trimmedText.length > 0) {
            if (!trimmedText.match(/^[A-Z]/) && !trimmedText.match(/^[0-9]/)) {
              warnings.push("Consider starting with a capital letter or number");
            }
            if (wordCount < 5) {
              warnings.push("Bullet point seems very short. Consider adding more detail about your impact");
            }
            if (trimmedText.includes("  ")) {
              warnings.push("Remove extra spaces between words");
            }
            if (trimmedText.startsWith("\u2022") || trimmedText.startsWith("-")) {
              warnings.push("Remove bullet symbols - they will be added automatically");
            }
          }
          return {
            isValid: errors.length === 0,
            errors,
            warnings
          };
        }
        /**
         * Validate complete bullet data
         */
        validateBullet(bulletData) {
          const textValidation = this.validateText(bulletData.text);
          const errors = [...textValidation.errors];
          const warnings = [...textValidation.warnings];
          if (!bulletData.roleId || bulletData.roleId.trim().length === 0) {
            errors.push("Role selection is required");
          }
          if (!bulletData.projectId || bulletData.projectId.trim().length === 0) {
            errors.push("Project selection is required");
          }
          return {
            isValid: errors.length === 0,
            errors,
            warnings
          };
        }
        /**
         * Check for potential duplicates
         */
        checkForDuplicates(newText, existingBullets) {
          const normalizedNew = this.normalizeText(newText);
          const similarBullets = [];
          for (const bullet of existingBullets) {
            const normalizedExisting = this.normalizeText(bullet.text);
            const similarity = this.calculateTextSimilarity(normalizedNew, normalizedExisting);
            if (similarity > 0.8) {
              similarBullets.push({ bullet, similarity });
            }
          }
          return {
            hasDuplicates: similarBullets.length > 0,
            similarBullets: similarBullets.sort((a, b) => b.similarity - a.similarity)
          };
        }
        /**
         * Normalize text for comparison
         */
        normalizeText(text) {
          return text.toLowerCase().replace(/[^\w\s]/g, " ").replace(/\s+/g, " ").trim();
        }
        /**
         * Calculate simple text similarity (Jaccard similarity)
         */
        calculateTextSimilarity(text1, text2) {
          const words1 = new Set(text1.split(/\s+/));
          const words2 = new Set(text2.split(/\s+/));
          const intersection = new Set([...words1].filter((word) => words2.has(word)));
          const union = /* @__PURE__ */ new Set([...words1, ...words2]);
          return union.size === 0 ? 0 : intersection.size / union.size;
        }
        /**
         * Get validation suggestions
         */
        getImprovementSuggestions(text) {
          const suggestions = [];
          const trimmedText = text.trim();
          if (trimmedText.length === 0) {
            return ["Add meaningful content describing your accomplishment or responsibility"];
          }
          const startsWithActionVerb = /^(Led|Managed|Developed|Created|Implemented|Analyzed|Designed|Built|Optimized|Increased|Decreased|Improved|Reduced|Achieved|Delivered|Coordinated|Established|Generated|Streamlined)/i.test(trimmedText);
          if (!startsWithActionVerb) {
            suggestions.push("Consider starting with a strong action verb (Led, Developed, Implemented, etc.)");
          }
          const hasNumbers = /\d/.test(trimmedText);
          if (!hasNumbers) {
            suggestions.push("Consider adding specific numbers or metrics to quantify your impact");
          }
          const hasImpactWords = /(result|impact|effect|outcome|improvement|increase|decrease|saving|revenue|efficiency)/i.test(trimmedText);
          if (!hasImpactWords) {
            suggestions.push("Consider adding the impact or results of your work");
          }
          return suggestions;
        }
      };
      globalBulletValidator = null;
    }
  });

  // src/ui/bullet-form-builder.ts
  var BulletFormBuilder;
  var init_bullet_form_builder = __esm({
    "src/ui/bullet-form-builder.ts"() {
      "use strict";
      init_bullet_validator();
      init_xss_safe_rendering();
      init_transactions();
      init_uuid();
      BulletFormBuilder = class {
        roles = [];
        projects = [];
        async createForm(config, isEdit, onSubmit, onCancel) {
          await this.loadData();
          const form = createSafeElement("form", "", "bullet-form");
          form.append(
            this.createRoleSection(config.defaultRoleId),
            this.createProjectSection(config.defaultRoleId, config.defaultProjectId),
            this.createTextSection(config.bullet?.text || ""),
            this.createButtonSection(isEdit, onCancel)
          );
          this.setupEvents(form, onSubmit);
          const roleSelect = form.querySelector("#bullet-role");
          if (roleSelect && roleSelect.value && roleSelect.value !== "__new_role__") {
            setTimeout(() => {
              const event = new Event("change", { bubbles: true });
              roleSelect.dispatchEvent(event);
            }, 0);
          }
          return form;
        }
        createRoleSection(defaultRoleId) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Role", "form-label");
          const select = document.createElement("select");
          select.id = "bullet-role";
          select.className = "form-select";
          this.roles.forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = `${role.title} (${role.company})`;
            option.selected = role.id === defaultRoleId;
            select.appendChild(option);
          });
          const newRoleOption = document.createElement("option");
          newRoleOption.value = "__new_role__";
          newRoleOption.textContent = "New Role...";
          select.appendChild(newRoleOption);
          const inlineRoleFields = this.createInlineRoleFields();
          group.append(label, select, inlineRoleFields);
          return group;
        }
        createInlineRoleFields() {
          const container = createSafeElement("div", "", "inline-role-fields");
          container.style.display = "none";
          container.style.marginTop = "0.5rem";
          container.style.padding = "0.75rem";
          container.style.backgroundColor = "#f8f9fa";
          container.style.border = "1px solid #dee2e6";
          container.style.borderRadius = "4px";
          const titleGroup = createSafeElement("div", "", "inline-field-group");
          titleGroup.style.marginBottom = "0.5rem";
          const titleLabel = createSafeElement("label", "Role Title", "inline-label");
          titleLabel.style.fontSize = "0.875rem";
          titleLabel.style.fontWeight = "500";
          titleLabel.style.marginBottom = "0.25rem";
          titleLabel.style.display = "block";
          const titleInput = document.createElement("input");
          titleInput.type = "text";
          titleInput.id = "new-role-title";
          titleInput.className = "form-input";
          titleInput.style.width = "100%";
          titleInput.placeholder = "e.g., Senior Product Manager";
          titleGroup.append(titleLabel, titleInput);
          const companyGroup = createSafeElement("div", "", "inline-field-group");
          const companyLabel = createSafeElement("label", "Company", "inline-label");
          companyLabel.style.fontSize = "0.875rem";
          companyLabel.style.fontWeight = "500";
          companyLabel.style.marginBottom = "0.25rem";
          companyLabel.style.display = "block";
          const companyInput = document.createElement("input");
          companyInput.type = "text";
          companyInput.id = "new-role-company";
          companyInput.className = "form-input";
          companyInput.style.width = "100%";
          companyInput.placeholder = "e.g., Amazon";
          companyGroup.append(companyLabel, companyInput);
          container.append(titleGroup, companyGroup);
          return container;
        }
        createProjectSection(defaultRoleId, defaultProjectId) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Project", "form-label");
          const select = document.createElement("select");
          select.id = "bullet-project";
          select.className = "form-select";
          const placeholderOption = document.createElement("option");
          placeholderOption.textContent = "Select a role first";
          placeholderOption.disabled = true;
          placeholderOption.selected = true;
          select.appendChild(placeholderOption);
          const inlineProjectFields = this.createInlineProjectFields();
          group.append(label, select, inlineProjectFields);
          return group;
        }
        createInlineProjectFields() {
          const container = createSafeElement("div", "", "inline-project-fields");
          container.style.display = "none";
          container.style.marginTop = "0.5rem";
          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.id = "new-project-name";
          nameInput.className = "form-input";
          nameInput.style.width = "100%";
          nameInput.placeholder = "Enter project name...";
          container.appendChild(nameInput);
          return container;
        }
        createTextSection(defaultText) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Bullet Point Text", "form-label");
          const textarea = document.createElement("textarea");
          const counter = createSafeElement("div", "", "char-counter");
          textarea.id = "bullet-text";
          textarea.className = "form-textarea";
          textarea.placeholder = "Enter your bullet point...";
          textarea.rows = 4;
          textarea.value = defaultText;
          this.updateCharCounter(defaultText, counter);
          group.append(label, textarea, counter);
          return group;
        }
        createButtonSection(isEdit, onCancel) {
          const group = createSafeElement("div", "", "modal-buttons");
          const cancelBtn = document.createElement("button");
          cancelBtn.type = "button";
          cancelBtn.textContent = "Cancel";
          cancelBtn.className = "btn btn-secondary";
          cancelBtn.onclick = onCancel;
          const saveBtn = document.createElement("button");
          saveBtn.type = "submit";
          saveBtn.textContent = isEdit ? "Update" : "Create";
          saveBtn.className = "btn btn-primary";
          group.append(cancelBtn, saveBtn);
          return group;
        }
        setupEvents(form, onSubmit) {
          const roleSelect = form.querySelector("#bullet-role");
          const projectSelect = form.querySelector("#bullet-project");
          const textarea = form.querySelector("#bullet-text");
          const counter = form.querySelector(".char-counter");
          const inlineRoleFields = form.querySelector(".inline-role-fields");
          const inlineProjectFields = form.querySelector(".inline-project-fields");
          roleSelect.addEventListener("change", () => {
            if (roleSelect.value === "__new_role__") {
              inlineRoleFields.style.display = "block";
              this.updateProjectOptions(projectSelect, void 0);
              inlineProjectFields.style.display = "none";
            } else {
              inlineRoleFields.style.display = "none";
              this.updateProjectOptions(projectSelect, roleSelect.value);
              if (projectSelect.value === "__new_project__") {
                inlineProjectFields.style.display = "block";
              } else {
                inlineProjectFields.style.display = "none";
              }
            }
          });
          projectSelect.addEventListener("change", () => {
            if (projectSelect.value === "__new_project__") {
              inlineProjectFields.style.display = "block";
            } else {
              inlineProjectFields.style.display = "none";
            }
          });
          textarea.addEventListener("input", () => {
            this.updateCharCounter(textarea.value, counter);
          });
          form.addEventListener("submit", async (e) => {
            e.preventDefault();
            const data = await this.getFormDataWithCreation(form);
            const validation = this.validateFormData(data);
            if (!validation.isValid) {
              alert(validation.errors.join("\n"));
              return;
            }
            await onSubmit(data);
          });
        }
        updateProjectOptions(select, roleId, selectedId) {
          select.innerHTML = "";
          if (!roleId || roleId === "__new_role__") {
            const option = document.createElement("option");
            option.textContent = roleId === "__new_role__" ? "Create role first" : "Select a role first";
            option.disabled = true;
            option.selected = true;
            select.appendChild(option);
            return;
          }
          const roleProjects = this.projects.filter((p) => p.roleId === roleId);
          roleProjects.forEach((project) => {
            const option = document.createElement("option");
            option.value = project.id;
            option.textContent = project.name;
            option.selected = project.id === selectedId;
            select.appendChild(option);
          });
          const newProjectOption = document.createElement("option");
          newProjectOption.value = "__new_project__";
          newProjectOption.textContent = "New Project...";
          select.appendChild(newProjectOption);
          if (roleProjects.length === 0 && !selectedId) {
            newProjectOption.selected = true;
          }
        }
        updateCharCounter(text, counter) {
          const length = text.length;
          const maxLength = 500;
          setSafeTextContent(counter, `${length}/${maxLength} characters`);
          if (length > maxLength * 0.9) {
            counter.className = "char-counter char-counter--warning";
          } else if (length > maxLength) {
            counter.className = "char-counter char-counter--error";
          } else {
            counter.className = "char-counter";
          }
        }
        async getFormDataWithCreation(form) {
          const roleSelect = form.querySelector("#bullet-role");
          const projectSelect = form.querySelector("#bullet-project");
          const textArea = form.querySelector("#bullet-text");
          let roleId = roleSelect.value;
          let projectId = projectSelect.value;
          if (roleId === "__new_role__") {
            const titleInput = form.querySelector("#new-role-title");
            const companyInput = form.querySelector("#new-role-company");
            if (!titleInput.value.trim() || !companyInput.value.trim()) {
              throw new Error("Role title and company are required");
            }
            const newRole = {
              id: createId("role"),
              title: titleInput.value.trim(),
              company: companyInput.value.trim(),
              orderIndex: this.roles.length,
              // Add at end
              bulletsLimit: 10,
              // Default limit
              startDate: (/* @__PURE__ */ new Date()).toISOString().slice(0, 7),
              // Current month
              endDate: null
              // Current role
            };
            const createdRole = await create("roles", newRole);
            roleId = createdRole.id;
            this.roles.push(createdRole);
          }
          if (projectId === "__new_project__") {
            const nameInput = form.querySelector("#new-project-name");
            if (!nameInput.value.trim()) {
              throw new Error("Project name is required");
            }
            const newProject = {
              id: createId("project"),
              roleId,
              name: nameInput.value.trim(),
              description: "",
              bulletCount: 0,
              createdAt: Date.now(),
              updatedAt: Date.now()
            };
            const createdProject = await create("projects", newProject);
            projectId = createdProject.id;
            this.projects.push(createdProject);
          }
          return {
            roleId,
            projectId,
            text: textArea.value.trim()
          };
        }
        validateFormData(data) {
          const validator = getBulletValidator();
          const errors = [];
          if (!data.roleId) {
            errors.push("Role is required");
          }
          if (!data.projectId) {
            errors.push("Project is required");
          }
          const textValidation = validator.validateText(data.text);
          if (!textValidation.isValid) {
            errors.push(...textValidation.errors);
          }
          return {
            isValid: errors.length === 0,
            errors
          };
        }
        async loadData() {
          [this.roles, this.projects] = await Promise.all([
            getAll("roles"),
            getAll("projects")
          ]);
          this.roles.sort((a, b) => a.orderIndex - b.orderIndex);
        }
      };
    }
  });

  // src/ui/bullet-data-service.ts
  function getBulletDataService() {
    if (!globalBulletDataService) {
      globalBulletDataService = new BulletDataService();
    }
    return globalBulletDataService;
  }
  var BulletDataService, globalBulletDataService;
  var init_bullet_data_service = __esm({
    "src/ui/bullet-data-service.ts"() {
      "use strict";
      init_transactions();
      BulletDataService = class {
        /**
         * Get all bullet points
         */
        async getAllBullets() {
          return getAll("bullets");
        }
        /**
         * Get bullet points by role
         */
        async getBulletsByRole(roleId) {
          const allBullets = await this.getAllBullets();
          return allBullets.filter((bullet) => bullet.roleId === roleId);
        }
        /**
         * Get bullet points by project
         */
        async getBulletsByProject(projectId) {
          const allBullets = await this.getAllBullets();
          return allBullets.filter((bullet) => bullet.projectId === projectId);
        }
        /**
         * Create new bullet point
         */
        async createBullet(bulletData) {
          const bullet = {
            id: `bullet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            roleId: bulletData.roleId,
            projectId: bulletData.projectId,
            text: bulletData.text.trim(),
            source: bulletData.source || "manual",
            createdAt: Date.now(),
            lastModified: Date.now()
          };
          return create("bullets", bullet);
        }
        /**
         * Update bullet point
         */
        async updateBullet(bulletId, updates) {
          const existingBullet = await getById("bullets", bulletId);
          if (!existingBullet) {
            throw new Error(`Bullet with id ${bulletId} not found`);
          }
          const updatedBullet = {
            ...existingBullet,
            ...updates,
            lastModified: Date.now()
          };
          if (updates.text) {
            updatedBullet.text = updates.text.trim();
          }
          return update("bullets", updatedBullet);
        }
        /**
         * Delete bullet point
         */
        async deleteBullet(bulletId) {
          await deleteById("bullets", bulletId);
        }
        /**
         * Get bullets with role and project context
         */
        async getBulletsWithContext() {
          const [bullets, roles, projects] = await Promise.all([
            this.getAllBullets(),
            getAll("roles"),
            getAll("projects")
          ]);
          return bullets.map((bullet) => ({
            bullet,
            role: roles.find((r) => r.id === bullet.roleId) || null,
            project: projects.find((p) => p.id === bullet.projectId) || null
          }));
        }
        /**
         * Validate bullet point data
         */
        validateBulletData(text, roleId, projectId) {
          const errors = [];
          if (!text || text.trim().length === 0) {
            errors.push("Bullet point text is required");
          }
          if (text && text.trim().length < 10) {
            errors.push("Bullet point should be at least 10 characters long");
          }
          if (text && text.trim().length > 500) {
            errors.push("Bullet point should be less than 500 characters");
          }
          if (!roleId) {
            errors.push("Role is required");
          }
          if (!projectId) {
            errors.push("Project is required");
          }
          return {
            isValid: errors.length === 0,
            errors
          };
        }
        /**
         * Search bullets by text
         */
        async searchBullets(searchTerm) {
          const allBullets = await this.getAllBullets();
          const lowerSearchTerm = searchTerm.toLowerCase();
          return allBullets.filter(
            (bullet) => bullet.text.toLowerCase().includes(lowerSearchTerm)
          );
        }
        /**
         * Get bullet statistics
         */
        async getBulletStats() {
          const bullets = await this.getAllBullets();
          const bulletsByRole = bullets.reduce((acc, bullet) => {
            const existing = acc.find((item) => item.roleId === bullet.roleId);
            if (existing) {
              existing.count++;
            } else {
              acc.push({ roleId: bullet.roleId, count: 1 });
            }
            return acc;
          }, []);
          const bulletsByProject = bullets.reduce((acc, bullet) => {
            const existing = acc.find((item) => item.projectId === bullet.projectId);
            if (existing) {
              existing.count++;
            } else {
              acc.push({ projectId: bullet.projectId, count: 1 });
            }
            return acc;
          }, []);
          return {
            totalBullets: bullets.length,
            bulletsByRole,
            bulletsByProject
          };
        }
      };
      globalBulletDataService = null;
    }
  });

  // src/ui/bullet-editor.ts
  function getBulletEditor() {
    if (!globalBulletEditor) {
      globalBulletEditor = new BulletEditor();
    }
    return globalBulletEditor;
  }
  var BulletEditor, globalBulletEditor;
  var init_bullet_editor = __esm({
    "src/ui/bullet-editor.ts"() {
      "use strict";
      init_bullet_form_builder();
      init_bullet_data_service();
      init_xss_safe_rendering();
      BulletEditor = class {
        modal = null;
        formBuilder;
        constructor() {
          this.formBuilder = new BulletFormBuilder();
        }
        async showAddModal(defaultRoleId, defaultProjectId, onSave) {
          await this.showModal({
            title: "Add Bullet Point",
            bullet: null,
            ...defaultRoleId && { defaultRoleId },
            ...defaultProjectId && { defaultProjectId }
          }, false, onSave);
        }
        async showEditModal(bulletId, onSave) {
          const dataService = getBulletDataService();
          const bullets = await dataService.getAllBullets();
          const bullet = bullets.find((b) => b.id === bulletId);
          if (!bullet) throw new Error("Bullet not found");
          await this.showModal({
            title: "Edit Bullet Point",
            bullet,
            defaultRoleId: bullet.roleId,
            defaultProjectId: bullet.projectId
          }, true, onSave);
        }
        async showModal(config, isEdit, onSave) {
          this.hideModal();
          this.modal = this.createModalStructure(config.title);
          const form = await this.formBuilder.createForm(
            config,
            isEdit,
            (data) => this.handleSubmit(data, isEdit, config.bullet?.id, onSave),
            () => this.hideModal()
          );
          this.modal.querySelector(".modal-body").appendChild(form);
          this.showModalElement();
        }
        createModalStructure(title) {
          const modal = createSafeElement("div", "", "modal-overlay");
          const content = createSafeElement("div", "", "modal-content bullet-editor-modal");
          const header = createSafeElement("div", "", "modal-header");
          const titleEl = createSafeElement("h3", title);
          const closeBtn = createSafeElement("button", "\xD7", "modal-close");
          const body = createSafeElement("div", "", "modal-body");
          closeBtn.onclick = () => this.hideModal();
          header.append(titleEl, closeBtn);
          content.append(header, body);
          modal.appendChild(content);
          return modal;
        }
        showModalElement() {
          const mainContent = document.querySelector(".main-content") || document.body;
          mainContent.appendChild(this.modal);
          setTimeout(() => {
            const firstInput = this.modal.querySelector("input, textarea");
            firstInput?.focus();
          }, 100);
        }
        async handleSubmit(data, isEdit, bulletId, onSave) {
          try {
            const dataService = getBulletDataService();
            if (isEdit && bulletId) {
              await dataService.updateBullet(bulletId, {
                text: data.text,
                projectId: data.projectId
              });
            } else {
              await dataService.createBullet({
                roleId: data.roleId,
                projectId: data.projectId,
                text: data.text,
                source: "manual"
              });
            }
            this.hideModal();
            if (onSave) {
              onSave();
            }
          } catch (error) {
            console.error("Failed to save bullet:", error);
            alert("Failed to save bullet point");
          }
        }
        hideModal() {
          this.modal?.remove();
          this.modal = null;
        }
      };
      globalBulletEditor = null;
    }
  });

  // src/ui/project-form-builder.ts
  var ProjectFormBuilder;
  var init_project_form_builder = __esm({
    "src/ui/project-form-builder.ts"() {
      "use strict";
      init_xss_safe_rendering();
      init_transactions();
      init_uuid();
      ProjectFormBuilder = class {
        roles = [];
        async createForm(config, onSubmit, onCancel) {
          await this.loadRoles();
          const form = createSafeElement("form", "", "project-form");
          form.append(
            this.createRoleSection(config.defaultRoleId),
            this.createNameSection(config.project?.name || ""),
            this.createDescriptionSection(config.project?.description || ""),
            this.createBulletPointsSection(config.bullets, config.isEdit),
            this.createButtonSection(config.isEdit, onCancel)
          );
          this.setupEvents(form, onSubmit);
          return form;
        }
        createRoleSection(defaultRoleId) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Role", "form-label");
          const select = document.createElement("select");
          select.id = "project-role";
          select.className = "form-select";
          this.roles.forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = `${role.title} (${role.company})`;
            option.selected = role.id === defaultRoleId;
            select.appendChild(option);
          });
          const newRoleOption = document.createElement("option");
          newRoleOption.value = "__new_role__";
          newRoleOption.textContent = "New Role...";
          select.appendChild(newRoleOption);
          const inlineRoleFields = this.createInlineRoleFields();
          group.append(label, select, inlineRoleFields);
          return group;
        }
        createInlineRoleFields() {
          const container = createSafeElement("div", "", "inline-role-fields");
          container.style.display = "none";
          container.style.marginTop = "0.5rem";
          container.style.padding = "0.75rem";
          container.style.backgroundColor = "#f8f9fa";
          container.style.border = "1px solid #dee2e6";
          container.style.borderRadius = "4px";
          const titleGroup = createSafeElement("div", "", "inline-field-group");
          titleGroup.style.marginBottom = "0.5rem";
          const titleLabel = createSafeElement("label", "Role Title", "inline-label");
          titleLabel.style.fontSize = "0.875rem";
          titleLabel.style.fontWeight = "500";
          titleLabel.style.marginBottom = "0.25rem";
          titleLabel.style.display = "block";
          const titleInput = document.createElement("input");
          titleInput.type = "text";
          titleInput.id = "new-role-title";
          titleInput.className = "form-input";
          titleInput.style.width = "100%";
          titleInput.placeholder = "e.g., Senior Product Manager";
          titleGroup.append(titleLabel, titleInput);
          const companyGroup = createSafeElement("div", "", "inline-field-group");
          const companyLabel = createSafeElement("label", "Company", "inline-label");
          companyLabel.style.fontSize = "0.875rem";
          companyLabel.style.fontWeight = "500";
          companyLabel.style.marginBottom = "0.25rem";
          companyLabel.style.display = "block";
          const companyInput = document.createElement("input");
          companyInput.type = "text";
          companyInput.id = "new-role-company";
          companyInput.className = "form-input";
          companyInput.style.width = "100%";
          companyInput.placeholder = "e.g., Amazon";
          companyGroup.append(companyLabel, companyInput);
          container.append(titleGroup, companyGroup);
          return container;
        }
        createNameSection(defaultName) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Project Name", "form-label");
          const input = document.createElement("input");
          input.id = "project-name";
          input.type = "text";
          input.className = "form-input";
          input.placeholder = "Enter project name...";
          input.value = defaultName;
          group.append(label, input);
          return group;
        }
        createDescriptionSection(defaultDescription) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Description", "form-label");
          const textarea = document.createElement("textarea");
          textarea.id = "project-description";
          textarea.className = "form-textarea";
          textarea.placeholder = "Enter description...";
          textarea.rows = 3;
          textarea.value = defaultDescription;
          group.append(label, textarea);
          return group;
        }
        createBulletPointsSection(bullets, isEdit) {
          const group = createSafeElement("div", "", "form-group");
          if (!isEdit && bullets.length === 0) {
            group.style.display = "none";
            return group;
          }
          const label = createSafeElement("label", "Bullet Points", "form-label");
          const helpText = createSafeElement(
            "div",
            "Enter one bullet point per line. Add new lines to create additional bullet points.",
            ""
          );
          helpText.style.fontSize = "0.875rem";
          helpText.style.color = "#6c757d";
          helpText.style.marginBottom = "0.5rem";
          const textarea = document.createElement("textarea");
          textarea.id = "project-bullets";
          textarea.className = "form-textarea";
          textarea.placeholder = "Enter bullet points, one per line...";
          textarea.rows = Math.max(6, bullets.length + 2);
          const bulletTexts = bullets.map((bullet) => bullet.text);
          textarea.value = bulletTexts.join("\n");
          const counter = createSafeElement("div", "", "char-counter");
          const updateCounter = () => {
            const lines = textarea.value.split("\n").filter((line) => line.trim().length > 0);
            setSafeTextContent(counter, `${lines.length} bullet points, ${textarea.value.length} characters`);
          };
          updateCounter();
          textarea.addEventListener("input", updateCounter);
          group.append(label, helpText, textarea, counter);
          return group;
        }
        createButtonSection(isEdit, onCancel) {
          const group = createSafeElement("div", "", "modal-buttons");
          const cancelBtn = document.createElement("button");
          cancelBtn.type = "button";
          cancelBtn.textContent = "Cancel";
          cancelBtn.className = "btn btn-secondary";
          cancelBtn.onclick = onCancel;
          const saveBtn = document.createElement("button");
          saveBtn.type = "submit";
          saveBtn.textContent = isEdit ? "Update" : "Create";
          saveBtn.className = "btn btn-primary";
          group.append(cancelBtn, saveBtn);
          return group;
        }
        setupEvents(form, onSubmit) {
          const roleSelect = form.querySelector("#project-role");
          const inlineRoleFields = form.querySelector(".inline-role-fields");
          roleSelect.addEventListener("change", () => {
            if (roleSelect.value === "__new_role__") {
              inlineRoleFields.style.display = "block";
            } else {
              inlineRoleFields.style.display = "none";
            }
          });
          form.addEventListener("submit", async (e) => {
            e.preventDefault();
            const data = await this.getFormDataWithCreation(form);
            const validation = this.validateFormData(data);
            if (!validation.isValid) {
              alert(validation.errors.join("\n"));
              return;
            }
            await onSubmit(data);
          });
        }
        async getFormDataWithCreation(form) {
          const roleSelect = form.querySelector("#project-role");
          const nameInput = form.querySelector("#project-name");
          const descInput = form.querySelector("#project-description");
          const bulletsTextarea = form.querySelector("#project-bullets");
          let roleId = roleSelect.value;
          if (roleId === "__new_role__") {
            const titleInput = form.querySelector("#new-role-title");
            const companyInput = form.querySelector("#new-role-company");
            if (!titleInput.value.trim() || !companyInput.value.trim()) {
              throw new Error("Role title and company are required");
            }
            const newRole = {
              id: createId("role"),
              title: titleInput.value.trim(),
              company: companyInput.value.trim(),
              orderIndex: this.roles.length,
              bulletsLimit: 10,
              startDate: (/* @__PURE__ */ new Date()).toISOString().slice(0, 7),
              endDate: null
            };
            const createdRole = await create("roles", newRole);
            roleId = createdRole.id;
            this.roles.push(createdRole);
          }
          const bulletTexts = bulletsTextarea ? bulletsTextarea.value.split("\n").map((line) => line.trim()).filter((line) => line.length > 0) : [];
          return {
            roleId,
            name: nameInput.value.trim(),
            description: descInput.value.trim(),
            bulletTexts
          };
        }
        validateFormData(data) {
          const errors = [];
          if (!data.name) {
            errors.push("Project name is required");
          }
          if (!data.roleId) {
            errors.push("Role is required");
          }
          return {
            isValid: errors.length === 0,
            errors
          };
        }
        async loadRoles() {
          this.roles = await getAll("roles");
          this.roles.sort((a, b) => a.orderIndex - b.orderIndex);
        }
      };
    }
  });

  // src/ui/project-editor.ts
  function getProjectEditor() {
    if (!globalProjectEditor) {
      globalProjectEditor = new ProjectEditor();
    }
    return globalProjectEditor;
  }
  var ProjectEditor, globalProjectEditor;
  var init_project_editor = __esm({
    "src/ui/project-editor.ts"() {
      "use strict";
      init_transactions();
      init_xss_safe_rendering();
      init_uuid();
      init_project_form_builder();
      ProjectEditor = class {
        modal = null;
        currentProjectId = null;
        onSave;
        formBuilder;
        constructor() {
          this.formBuilder = new ProjectFormBuilder();
        }
        async showAddModal(defaultRoleId, onSave) {
          this.currentProjectId = null;
          this.onSave = onSave;
          await this.showModal({
            title: "Add Project",
            project: null,
            bullets: [],
            isEdit: false,
            ...defaultRoleId && { defaultRoleId }
          });
        }
        async showEditModal(projectId, onSave) {
          this.currentProjectId = projectId;
          this.onSave = onSave;
          const project = await getById("projects", projectId);
          if (!project) {
            throw new Error("Project not found");
          }
          const bullets = await this.loadProjectBullets(projectId);
          await this.showModal({
            title: "Edit Project",
            project,
            bullets,
            isEdit: true,
            defaultRoleId: project.roleId
          });
        }
        async loadProjectBullets(projectId) {
          const allBullets = await getAll("bullets");
          const projectBullets = allBullets.filter((bullet) => bullet.projectId === projectId);
          return projectBullets.sort((a, b) => a.createdAt - b.createdAt);
        }
        async showModal(config) {
          this.hideModal();
          this.modal = this.createModalStructure(config.title);
          const formConfig = {
            project: config.project,
            bullets: config.bullets,
            isEdit: config.isEdit,
            ...config.defaultRoleId && { defaultRoleId: config.defaultRoleId }
          };
          const form = await this.formBuilder.createForm(
            formConfig,
            (data) => this.handleSubmit(data),
            () => this.hideModal()
          );
          this.modal.querySelector(".modal-body").appendChild(form);
          this.showModalElement();
        }
        createModalStructure(title) {
          const modal = createSafeElement("div", "", "modal-overlay");
          const content = createSafeElement("div", "", "modal-content project-editor-modal");
          const header = createSafeElement("div", "", "modal-header");
          const titleEl = createSafeElement("h3", title);
          const closeBtn = createSafeElement("button", "\xD7", "modal-close");
          const body = createSafeElement("div", "", "modal-body");
          closeBtn.onclick = () => this.hideModal();
          header.append(titleEl, closeBtn);
          content.append(header, body);
          modal.appendChild(content);
          return modal;
        }
        showModalElement() {
          const mainContent = document.querySelector(".main-content") || document.body;
          mainContent.appendChild(this.modal);
          setTimeout(() => {
            const firstInput = this.modal.querySelector("input, textarea");
            firstInput?.focus();
          }, 100);
          document.onkeydown = (e) => {
            if (e.key === "Escape") {
              this.hideModal();
            }
          };
        }
        async handleSubmit(formData) {
          try {
            if (this.currentProjectId) {
              await this.updateProject(formData);
              await this.updateProjectBullets(formData);
            } else {
              const project = await this.createProject(formData);
              await this.createProjectBullets(formData, project.id);
            }
            this.hideModal();
            this.onSave?.();
          } catch (error) {
            alert(error instanceof Error ? error.message : "An error occurred");
          }
        }
        async createProject(formData) {
          const newProject = {
            id: createId("project"),
            roleId: formData.roleId,
            name: formData.name,
            description: formData.description,
            bulletCount: formData.bulletTexts.length,
            createdAt: Date.now(),
            updatedAt: Date.now()
          };
          return await create("projects", newProject);
        }
        async updateProject(formData) {
          if (!this.currentProjectId) return;
          const existingProject = await getById("projects", this.currentProjectId);
          if (!existingProject) {
            throw new Error("Project not found");
          }
          const updatedProject = {
            ...existingProject,
            roleId: formData.roleId,
            name: formData.name,
            description: formData.description,
            bulletCount: formData.bulletTexts.length,
            updatedAt: Date.now()
          };
          await update("projects", updatedProject);
        }
        async createProjectBullets(formData, projectId) {
          for (const bulletText of formData.bulletTexts) {
            const newBullet = {
              id: createId("bullet"),
              roleId: formData.roleId,
              projectId,
              text: bulletText,
              source: "manual",
              createdAt: Date.now(),
              lastModified: Date.now()
            };
            await create("bullets", newBullet);
          }
        }
        async updateProjectBullets(formData) {
          if (!this.currentProjectId) return;
          const existingBullets = await this.loadProjectBullets(this.currentProjectId);
          for (const bullet of existingBullets) {
            await deleteById("bullets", bullet.id);
          }
          await this.createProjectBullets(formData, this.currentProjectId);
        }
        hideModal() {
          this.modal?.remove();
          this.modal = null;
          this.currentProjectId = null;
          this.onSave = void 0;
          document.onkeydown = null;
        }
      };
      globalProjectEditor = null;
    }
  });

  // src/ui/data-management.ts
  var BulletPointsTable, ProjectsTable;
  var init_data_management = __esm({
    "src/ui/data-management.ts"() {
      "use strict";
      init_transactions();
      init_xss_safe_rendering();
      init_bullet_editor();
      init_project_editor();
      BulletPointsTable = class {
        container;
        bullets = [];
        projects = [];
        roles = [];
        sortBy = "created";
        sortOrder = "desc";
        filterText = "";
        constructor(container) {
          this.container = container;
        }
        /**
         * Render the bullets table
         */
        async render() {
          await this.loadData();
          this.container.innerHTML = "";
          const header = this.createHeader();
          const table = await this.createTable();
          this.container.appendChild(header);
          this.container.appendChild(table);
        }
        /**
         * Create table header with controls
         */
        createHeader() {
          const header = createSafeElement("div", "", "bullets-header");
          const addButton = createSafeElement("button", "+ Add Bullet Point", "btn btn-primary");
          addButton.addEventListener("click", () => this.showAddBulletModal());
          const filterInput = document.createElement("input");
          filterInput.type = "text";
          filterInput.placeholder = "Filter bullets...";
          filterInput.className = "filter-input";
          filterInput.value = this.filterText;
          filterInput.addEventListener("input", (e) => {
            this.filterText = e.target.value;
            this.render();
          });
          const sortSelect = document.createElement("select");
          sortSelect.className = "sort-select";
          [
            { value: "created", label: "Created Date" },
            { value: "modified", label: "Modified Date" },
            { value: "role", label: "Role" },
            { value: "project", label: "Project" }
          ].forEach((option) => {
            const opt = document.createElement("option");
            opt.value = option.value;
            opt.textContent = option.label;
            opt.selected = this.sortBy === option.value;
            sortSelect.appendChild(opt);
          });
          sortSelect.addEventListener("change", (e) => {
            this.sortBy = e.target.value;
            this.render();
          });
          const orderButton = createSafeElement(
            "button",
            this.sortOrder === "asc" ? "\u2191" : "\u2193",
            "btn btn-sm"
          );
          orderButton.addEventListener("click", () => {
            this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
            this.render();
          });
          header.appendChild(addButton);
          header.appendChild(filterInput);
          header.appendChild(sortSelect);
          header.appendChild(orderButton);
          return header;
        }
        /**
         * Create bullets table
         */
        async createTable() {
          const table = createSafeElement("table", "", "bullets-table");
          const thead = document.createElement("thead");
          const headerRow = document.createElement("tr");
          ["Role", "Project", "Bullet Text", "Modified", "Actions"].forEach((header) => {
            const th = document.createElement("th");
            setSafeTextContent(th, header);
            headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);
          const tbody = document.createElement("tbody");
          const sortedBullets = this.sortAndFilterBullets();
          for (const bullet of sortedBullets) {
            const row = this.createBulletRow(bullet);
            tbody.appendChild(row);
          }
          table.appendChild(tbody);
          return table;
        }
        /**
         * Create bullet row
         */
        createBulletRow(bullet) {
          const row = document.createElement("tr");
          const role = this.roles.find((r) => r.id === bullet.roleId);
          const roleCell = createSafeElement(
            "td",
            role ? `${role.title}
${role.company}` : "Unknown Role",
            "role-cell"
          );
          const projectCell = createSafeElement("td", "", "project-cell");
          const projectSelect = this.createProjectSelect(bullet);
          projectCell.appendChild(projectSelect);
          const textCell = createSafeElement("td", "", "text-cell");
          const truncatedText = bullet.text.length > 80 ? bullet.text.substring(0, 80) + "..." : bullet.text;
          setSafeTextContent(textCell, truncatedText);
          textCell.title = bullet.text;
          const modifiedCell = createSafeElement(
            "td",
            new Date(bullet.lastModified).toLocaleDateString(),
            "date-cell"
          );
          const actionsCell = createSafeElement("td", "", "actions-cell");
          const editButton = createSafeElement("button", "Edit", "btn btn-sm");
          const deleteButton = createSafeElement("button", "Delete", "btn btn-sm btn-danger");
          editButton.addEventListener("click", () => this.editBullet(bullet.id));
          deleteButton.addEventListener("click", () => this.deleteBullet(bullet.id));
          actionsCell.appendChild(editButton);
          actionsCell.appendChild(deleteButton);
          row.appendChild(roleCell);
          row.appendChild(projectCell);
          row.appendChild(textCell);
          row.appendChild(modifiedCell);
          row.appendChild(actionsCell);
          return row;
        }
        /**
         * Create project selection dropdown for bullet
         */
        createProjectSelect(bullet) {
          const select = document.createElement("select");
          select.className = "project-select";
          const currentProject = this.projects.find((p) => p.id === bullet.projectId);
          const roleProjects = this.projects.filter((p) => p.roleId === bullet.roleId);
          roleProjects.forEach((project) => {
            const option = document.createElement("option");
            option.value = project.id;
            option.textContent = project.name;
            option.selected = project.id === bullet.projectId;
            select.appendChild(option);
          });
          select.addEventListener("change", () => {
            this.moveBulletToProject(bullet.id, select.value);
          });
          return select;
        }
        /**
         * Sort and filter bullets
         */
        sortAndFilterBullets() {
          let filtered = this.bullets.filter((bullet) => {
            if (!this.filterText) return true;
            const role = this.roles.find((r) => r.id === bullet.roleId);
            const project = this.projects.find((p) => p.id === bullet.projectId);
            const searchText = [
              bullet.text,
              role?.title,
              role?.company,
              project?.name
            ].filter(Boolean).join(" ").toLowerCase();
            return searchText.includes(this.filterText.toLowerCase());
          });
          filtered.sort((a, b) => {
            let compareValue = 0;
            switch (this.sortBy) {
              case "role": {
                const roleA = this.roles.find((r) => r.id === a.roleId);
                const roleB = this.roles.find((r) => r.id === b.roleId);
                const nameA = roleA ? `${roleA.company} ${roleA.title}` : "";
                const nameB = roleB ? `${roleB.company} ${roleB.title}` : "";
                compareValue = nameA.localeCompare(nameB);
                break;
              }
              case "project": {
                const projectA = this.projects.find((p) => p.id === a.projectId);
                const projectB = this.projects.find((p) => p.id === b.projectId);
                const nameA = projectA?.name || "";
                const nameB = projectB?.name || "";
                compareValue = nameA.localeCompare(nameB);
                break;
              }
              case "created":
                compareValue = a.createdAt - b.createdAt;
                break;
              case "modified":
                compareValue = a.lastModified - b.lastModified;
                break;
            }
            return this.sortOrder === "asc" ? compareValue : -compareValue;
          });
          return filtered;
        }
        /**
         * Move bullet to different project
         */
        async moveBulletToProject(bulletId, newProjectId) {
          try {
            const bullet = this.bullets.find((b) => b.id === bulletId);
            if (!bullet) return;
            const updatedBullet = {
              ...bullet,
              projectId: newProjectId,
              lastModified: Date.now()
            };
            await update("bullets", updatedBullet);
            await this.render();
          } catch (error) {
            console.error("Failed to move bullet:", error);
            alert("Failed to move bullet point");
          }
        }
        /**
         * Show add bullet modal
         */
        showAddBulletModal() {
          try {
            const editor = getBulletEditor();
            editor.showAddModal(void 0, void 0, () => {
              this.render();
            });
          } catch (error) {
            console.error("Error showing add modal:", error);
            alert("Error opening bullet editor: " + (error instanceof Error ? error.message : "Unknown error"));
          }
        }
        editBullet(bulletId) {
          try {
            const editor = getBulletEditor();
            editor.showEditModal(bulletId, () => this.render());
          } catch (error) {
            console.error("Error editing bullet:", error);
            alert("Error opening bullet editor: " + (error instanceof Error ? error.message : "Unknown error"));
          }
        }
        /**
         * Delete bullet
         */
        async deleteBullet(bulletId) {
          if (!confirm("Are you sure you want to delete this bullet point?")) {
            return;
          }
          try {
            await deleteById("bullets", bulletId);
            await this.render();
          } catch (error) {
            console.error("Failed to delete bullet:", error);
            alert("Failed to delete bullet point");
          }
        }
        /**
         * Load data from storage
         */
        async loadData() {
          [this.bullets, this.projects, this.roles] = await Promise.all([
            getAll("bullets"),
            getAll("projects"),
            getAll("roles")
          ]);
        }
      };
      ProjectsTable = class {
        container;
        projects = [];
        roles = [];
        bullets = [];
        sortBy = "role";
        sortOrder = "asc";
        constructor(container) {
          this.container = container;
        }
        /**
         * Render the projects table
         */
        async render() {
          await this.loadData();
          this.container.innerHTML = "";
          const header = this.createHeader();
          const table = this.createTable();
          this.container.appendChild(header);
          this.container.appendChild(table);
        }
        /**
         * Create table header with controls
         */
        createHeader() {
          const header = createSafeElement("div", "", "projects-header");
          header.style.marginBottom = "1rem";
          header.style.display = "flex";
          header.style.gap = "1rem";
          header.style.alignItems = "center";
          const addButton = createSafeElement("button", "+ Add Project", "btn btn-primary");
          addButton.addEventListener("click", () => this.showAddProjectModal());
          const sortLabel = createSafeElement("label", "Sort by: ");
          const sortSelect = document.createElement("select");
          sortSelect.className = "sort-select";
          [
            { value: "role", label: "Role" },
            { value: "project", label: "Project Name" },
            { value: "bulletCount", label: "Bullet Count" }
          ].forEach((option) => {
            const opt = document.createElement("option");
            opt.value = option.value;
            opt.textContent = option.label;
            opt.selected = this.sortBy === option.value;
            sortSelect.appendChild(opt);
          });
          sortSelect.addEventListener("change", (e) => {
            this.sortBy = e.target.value;
            this.render();
          });
          const orderButton = createSafeElement(
            "button",
            this.sortOrder === "asc" ? "\u2191 A\u2192Z" : "\u2193 Z\u2192A",
            "btn btn-sm"
          );
          orderButton.addEventListener("click", () => {
            this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
            this.render();
          });
          header.appendChild(addButton);
          header.appendChild(sortLabel);
          header.appendChild(sortSelect);
          header.appendChild(orderButton);
          return header;
        }
        /**
         * Create projects table
         */
        createTable() {
          const table = createSafeElement("table", "", "projects-table");
          const thead = document.createElement("thead");
          const headerRow = document.createElement("tr");
          const columns = [
            { key: "role", label: "Role" },
            { key: "project", label: "Project Name" },
            { key: null, label: "Description" },
            { key: "bulletCount", label: "# Bullets" },
            { key: null, label: "Actions" }
          ];
          columns.forEach((col) => {
            const th = document.createElement("th");
            if (col.key) {
              th.style.cursor = "pointer";
              th.style.userSelect = "none";
              const content = document.createElement("span");
              setSafeTextContent(content, col.label);
              if (this.sortBy === col.key) {
                const indicator = document.createElement("span");
                setSafeTextContent(indicator, this.sortOrder === "asc" ? " \u2191" : " \u2193");
                indicator.style.marginLeft = "0.25rem";
                content.appendChild(indicator);
              }
              th.appendChild(content);
              th.addEventListener("click", () => {
                if (this.sortBy === col.key) {
                  this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
                } else {
                  this.sortBy = col.key;
                  this.sortOrder = "asc";
                }
                this.render();
              });
            } else {
              setSafeTextContent(th, col.label);
            }
            headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);
          const tbody = document.createElement("tbody");
          const sortedProjects = this.sortProjects();
          for (const project of sortedProjects) {
            const row = this.createProjectRow(project);
            tbody.appendChild(row);
          }
          table.appendChild(tbody);
          return table;
        }
        /**
         * Sort projects based on current sort settings
         */
        sortProjects() {
          const sorted = [...this.projects];
          sorted.sort((a, b) => {
            let compareValue = 0;
            switch (this.sortBy) {
              case "role": {
                const roleA = this.roles.find((r) => r.id === a.roleId);
                const roleB = this.roles.find((r) => r.id === b.roleId);
                const endDateA = roleA?.endDate;
                const endDateB = roleB?.endDate;
                if (!endDateA && !endDateB) {
                  const companyA = roleA?.company || "";
                  const companyB = roleB?.company || "";
                  compareValue = companyA.localeCompare(companyB);
                  if (compareValue === 0) {
                    const titleA = roleA?.title || "";
                    const titleB = roleB?.title || "";
                    compareValue = titleA.localeCompare(titleB);
                  }
                } else if (!endDateA) {
                  compareValue = -1;
                } else if (!endDateB) {
                  compareValue = 1;
                } else {
                  compareValue = endDateB.localeCompare(endDateA);
                }
                break;
              }
            }
            return this.sortOrder === "asc" ? compareValue : -compareValue;
          });
          return sorted;
        }
        /**
         * Create project row
         */
        createProjectRow(project) {
          const row = document.createElement("tr");
          const role = this.roles.find((r) => r.id === project.roleId);
          const roleCell = createSafeElement(
            "td",
            role ? `${role.title}
${role.company}` : "Unknown Role"
          );
          const nameCell = createSafeElement("td", project.name, "project-name");
          const descCell = createSafeElement(
            "td",
            project.description && project.description.length > 60 ? project.description.substring(0, 60) + "..." : project.description || "No description"
          );
          const bulletCount = this.bullets.filter((b) => b.projectId === project.id).length;
          const countCell = createSafeElement("td", bulletCount.toString());
          const actionsCell = createSafeElement("td", "", "actions-cell");
          const editButton = createSafeElement("button", "Edit", "btn btn-sm");
          const deleteButton = createSafeElement("button", "Delete", "btn btn-sm btn-danger");
          editButton.addEventListener("click", () => this.editProject(project.id));
          deleteButton.addEventListener("click", () => this.deleteProject(project.id));
          actionsCell.appendChild(editButton);
          actionsCell.appendChild(deleteButton);
          row.appendChild(roleCell);
          row.appendChild(nameCell);
          row.appendChild(descCell);
          row.appendChild(countCell);
          row.appendChild(actionsCell);
          return row;
        }
        /**
         * Show add project modal
         */
        showAddProjectModal() {
          try {
            const editor = getProjectEditor();
            editor.showAddModal(void 0, () => this.render());
          } catch (error) {
            console.error("Error showing add project modal:", error);
            alert("Error opening project editor: " + (error instanceof Error ? error.message : "Unknown error"));
          }
        }
        /**
         * Edit project
         */
        editProject(projectId) {
          try {
            const editor = getProjectEditor();
            editor.showEditModal(projectId, () => this.render());
          } catch (error) {
            console.error("Error editing project:", error);
            alert("Error opening project editor: " + (error instanceof Error ? error.message : "Unknown error"));
          }
        }
        /**
         * Delete project
         */
        async deleteProject(projectId) {
          const project = this.projects.find((p) => p.id === projectId);
          if (!project) return;
          const projectBullets = this.bullets.filter((b) => b.projectId === projectId);
          if (projectBullets.length > 0) {
            const confirmMessage = `This project has ${projectBullets.length} bullet points. Deleting it will remove them from the project but keep the bullets. Continue?`;
            if (!confirm(confirmMessage)) {
              return;
            }
          }
          try {
            await deleteById("projects", projectId);
            await this.render();
          } catch (error) {
            console.error("Failed to delete project:", error);
            alert("Failed to delete project");
          }
        }
        /**
         * Load data from storage
         */
        async loadData() {
          [this.projects, this.roles, this.bullets] = await Promise.all([
            getAll("projects"),
            getAll("roles"),
            getAll("bullets")
          ]);
        }
      };
    }
  });

  // src/ui/experience-tab.ts
  var experience_tab_exports = {};
  __export(experience_tab_exports, {
    ExperienceTab: () => ExperienceTab
  });
  var ExperienceTab;
  var init_experience_tab = __esm({
    "src/ui/experience-tab.ts"() {
      "use strict";
      init_data_management();
      init_xss_safe_rendering();
      ExperienceTab = class {
        container;
        currentView = "bullets";
        bulletsTable = null;
        projectsTable = null;
        constructor(container) {
          this.container = container;
          console.log("ExperienceTab constructor called with container:", container);
        }
        /**
         * Render the experience tab content
         */
        async render() {
          console.log("ExperienceTab render() called");
          try {
            this.container.innerHTML = "";
            const tabContent = createSafeElement("div", "", "experience-tab-content");
            const subNav = this.createSubNavigation();
            const contentArea = createSafeElement("div", "", "experience-content");
            tabContent.appendChild(subNav);
            tabContent.appendChild(contentArea);
            this.container.appendChild(tabContent);
            console.log("ExperienceTab basic structure created, rendering current view...");
            await this.renderCurrentView(contentArea);
            console.log("ExperienceTab render completed successfully");
          } catch (error) {
            console.error("Error in ExperienceTab.render():", error);
            this.container.innerHTML = `
        <div style="color: red; padding: 1rem; border: 1px solid #ff0000; border-radius: 4px;">
          <h3>Experience Tab Render Error</h3>
          <p>Error rendering experience tab: ${error instanceof Error ? error.message : "Unknown error"}</p>
        </div>
      `;
          }
        }
        /**
         * Create sub-navigation between bullets and projects
         */
        createSubNavigation() {
          const nav = createSafeElement("div", "", "experience-subnav");
          const bulletsButton = createSafeElement(
            "button",
            "Bullet Points",
            `subnav-button ${this.currentView === "bullets" ? "subnav-button--active" : ""}`
          );
          const projectsButton = createSafeElement(
            "button",
            "Projects",
            `subnav-button ${this.currentView === "projects" ? "subnav-button--active" : ""}`
          );
          bulletsButton.addEventListener("click", async () => {
            if (this.currentView !== "bullets") {
              this.currentView = "bullets";
              await this.render();
            }
          });
          projectsButton.addEventListener("click", async () => {
            if (this.currentView !== "projects") {
              this.currentView = "projects";
              await this.render();
            }
          });
          nav.appendChild(bulletsButton);
          nav.appendChild(projectsButton);
          return nav;
        }
        /**
         * Render the current view content
         */
        async renderCurrentView(contentArea) {
          contentArea.innerHTML = "";
          if (this.currentView === "bullets") {
            await this.renderBulletsView(contentArea);
          } else {
            await this.renderProjectsView(contentArea);
          }
        }
        /**
         * Render bullets view - FIXED to actually use BulletPointsTable
         */
        async renderBulletsView(contentArea) {
          try {
            console.log("Rendering bullets view...");
            const tableContainer = createSafeElement("div", "", "bullets-table-container");
            contentArea.appendChild(tableContainer);
            this.bulletsTable = new BulletPointsTable(tableContainer);
            await this.bulletsTable.render();
            console.log("Bullets view rendered successfully");
          } catch (error) {
            console.error("Error rendering bullets view:", error);
            contentArea.innerHTML = `
        <div style="padding: 1rem;">
          <h3>Bullets</h3>
          <p style="color: orange;">Error loading bullets table: ${error instanceof Error ? error.message : "Unknown error"}</p>
          <p>The bullets functionality is being updated. Please check back soon.</p>
        </div>
      `;
          }
        }
        /**
         * Render projects view - FIXED to actually use ProjectsTable
         */
        async renderProjectsView(contentArea) {
          try {
            console.log("Rendering projects view...");
            const tableContainer = createSafeElement("div", "", "projects-table-container");
            contentArea.appendChild(tableContainer);
            this.projectsTable = new ProjectsTable(tableContainer);
            await this.projectsTable.render();
            console.log("Projects view rendered successfully");
          } catch (error) {
            console.error("Error rendering projects view:", error);
            contentArea.innerHTML = `
        <div style="padding: 1rem;">
          <h3>Projects</h3>
          <p style="color: orange;">Error loading projects interface: ${error instanceof Error ? error.message : "Unknown error"}</p>
          <p>The projects functionality is being updated. Please check back soon.</p>
        </div>
      `;
          }
        }
        /**
         * Refresh the current view
         */
        async refresh() {
          await this.render();
        }
      };
    }
  });

  // src/ui/app.ts
  init_xss_safe_rendering();

  // src/ui/application-tab.ts
  init_xss_safe_rendering();

  // src/workers/recommendation-engine.ts
  init_transactions();

  // src/workers/openai-service.ts
  init_transactions();
  var DEFAULT_CHAT_MODEL = "gpt-4o-mini";
  var OpenAIService = class {
    name = "OpenAI";
    supportsBrowserFetch = true;
    supportsEmbeddings = true;
    apiKey = null;
    isInitialized = false;
    /**
     * Initialize service and load API key from storage
     */
    async initialize() {
      if (this.isInitialized) return;
      try {
        const storedKey = await getSetting("openai_api_key");
        if (storedKey && typeof storedKey === "string") {
          this.apiKey = storedKey;
        }
        this.isInitialized = true;
      } catch (error) {
        console.warn("Failed to load API key from storage:", error);
        this.isInitialized = true;
      }
    }
    /**
     * Set API key and save to storage
     */
    async setApiKey(apiKey) {
      if (!apiKey || typeof apiKey !== "string") {
        throw new Error("Invalid API key provided");
      }
      if (!apiKey.startsWith("sk-")) {
        console.warn('API key does not start with "sk-" - may not be a standard OpenAI key');
      }
      this.apiKey = apiKey;
      try {
        await setSetting("openai_api_key", apiKey);
      } catch (error) {
        console.error("Failed to save API key to storage:", error);
      }
    }
    /**
     * Get current API key
     */
    getApiKey() {
      if (!this.apiKey) {
        throw this.createError("ERR_NO_KEY" /* NO_KEY */, "OpenAI API key not set");
      }
      return this.apiKey;
    }
    /**
     * Check if API key is set
     */
    hasApiKey() {
      return this.apiKey !== null && this.apiKey.length > 0;
    }
    /**
     * Clear API key from memory and storage
     */
    async clearApiKey() {
      this.apiKey = null;
      try {
        await setSetting("openai_api_key", "");
      } catch (error) {
        console.error("Failed to clear API key from storage:", error);
      }
    }
    /**
     * Test API key validity
     */
    async testApiKey(model) {
      if (!this.hasApiKey()) {
        return { isValid: false, error: "No API key set" };
      }
      try {
        await this.createChatCompletion({
          model: model || DEFAULT_CHAT_MODEL,
          messages: [{ role: "user", content: "Hi" }],
          max_tokens: 5,
          temperature: 0
        });
        return { isValid: true };
      } catch (error) {
        if (error instanceof Error && "code" in error) {
          const openAIError = error;
          return {
            isValid: false,
            error: this.getErrorMessage(openAIError.code)
          };
        }
        return {
          isValid: false,
          error: error instanceof Error ? error.message : "Unknown error"
        };
      }
    }
    /**
     * Create chat completion with OpenAI API
     */
    async createChatCompletion(params) {
      if (!this.hasApiKey()) {
        throw this.createError("ERR_NO_KEY" /* NO_KEY */, "OpenAI API key is required");
      }
      const requestBody = {
        model: params.model || DEFAULT_CHAT_MODEL,
        messages: params.messages,
        temperature: params.temperature ?? 0.7,
        max_tokens: params.max_tokens ?? 1e3
      };
      if (params.response_format) {
        requestBody.response_format = params.response_format;
      }
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${this.getApiKey()}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(requestBody)
        });
        if (!response.ok) {
          throw await this.handleAPIError(response);
        }
        return await response.json();
      } catch (error) {
        if (error instanceof Error && "code" in error) {
          throw error;
        }
        throw this.createError(
          "ERR_NETWORK" /* NETWORK_ERROR */,
          `Network error: ${error instanceof Error ? error.message : "Unknown error"}`
        );
      }
    }
    /**
     * Create embeddings
     */
    async createEmbeddings(input, model = "text-embedding-3-small") {
      if (!this.hasApiKey()) {
        throw this.createError("ERR_NO_KEY" /* NO_KEY */, "OpenAI API key is required");
      }
      try {
        const response = await fetch("https://api.openai.com/v1/embeddings", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${this.getApiKey()}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model,
            input
          })
        });
        if (!response.ok) {
          throw await this.handleAPIError(response);
        }
        return await response.json();
      } catch (error) {
        if (error instanceof Error && "code" in error) {
          throw error;
        }
        throw this.createError(
          "ERR_NETWORK" /* NETWORK_ERROR */,
          `Network error: ${error instanceof Error ? error.message : "Unknown error"}`
        );
      }
    }
    /**
     * Handle API errors
     */
    async handleAPIError(response) {
      const retryAfter = response.headers.get("Retry-After");
      let errorData = {};
      try {
        errorData = await response.json();
      } catch {
      }
      const errorMessage = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;
      switch (response.status) {
        case 401:
        case 403:
          return this.createError("ERR_KEY_INVALID" /* KEY_INVALID */, "Invalid OpenAI API key", response.status);
        case 404:
          return this.createError(
            "ERR_MODEL_UNAVAILABLE" /* MODEL_UNAVAILABLE */,
            "Model not available for this key",
            response.status
          );
        case 429:
          return this.createError(
            "ERR_RATE_LIMIT" /* RATE_LIMIT */,
            "Rate limit exceeded. Please try again later.",
            response.status,
            retryAfter ? parseInt(retryAfter) : void 0
          );
        case 400:
          return this.createError("ERR_PARSE" /* PARSE_ERROR */, errorMessage, response.status);
        case 500:
        case 502:
        case 503:
        case 504:
          return this.createError(
            "ERR_SERVER" /* SERVER_ERROR */,
            "OpenAI server error. Please try again.",
            response.status
          );
        default:
          return this.createError("ERR_NETWORK" /* NETWORK_ERROR */, errorMessage, response.status);
      }
    }
    /**
     * Create normalized error
     */
    createError(code, message, status, retryAfter) {
      const error = new Error(message);
      error.code = code;
      if (status !== void 0) {
        error.status = status;
      }
      if (retryAfter !== void 0) {
        error.retryAfter = retryAfter;
      }
      return error;
    }
    /**
     * Get user-friendly error messages
     */
    getErrorMessage(code) {
      switch (code) {
        case "ERR_NO_KEY" /* NO_KEY */:
          return "Please set your OpenAI API key in settings";
        case "ERR_KEY_INVALID" /* KEY_INVALID */:
          return "Invalid API key. Please check your OpenAI key in settings";
        case "ERR_MODEL_UNAVAILABLE" /* MODEL_UNAVAILABLE */:
          return "Selected model isn't available for your account";
        case "ERR_RATE_LIMIT" /* RATE_LIMIT */:
          return "Rate limit exceeded. Please wait a moment and try again";
        case "ERR_SERVER" /* SERVER_ERROR */:
          return "OpenAI server error. Please try again in a moment";
        case "ERR_UNSUPPORTED_FORMAT" /* UNSUPPORTED_FORMAT */:
          return "Feature not supported with current model";
        case "ERR_PARSE" /* PARSE_ERROR */:
          return "Error processing response. Please try again";
        case "ERR_NETWORK" /* NETWORK_ERROR */:
          return "Network error. Please check your connection and try again";
        default:
          return "Unknown error occurred";
      }
    }
    /**
     * Get usage info (placeholder)
     */
    async getUsageInfo() {
      return {
        totalTokens: 0,
        estimatedCost: 0
      };
    }
  };
  var globalOpenAIService = null;
  function getOpenAIService() {
    if (!globalOpenAIService) {
      globalOpenAIService = new OpenAIService();
    }
    return globalOpenAIService;
  }
  async function initializeOpenAIService() {
    const service = getOpenAIService();
    await service.initialize();
    return service;
  }

  // src/workers/job-analyzer.ts
  var analysisCache = null;
  var CACHE_DURATION = 10 * 60 * 1e3;
  var MAX_INPUT_LENGTH = 8e3;
  var MODEL = "gpt-4o-mini";
  var PROMPT_VERSION = "v4";
  var JobAnalyzer = class {
    /**
     * Analyze job description using OpenAI to extract skills and requirements
     */
    async analyzeJob(title, description) {
      const truncatedDescription = this.truncateDescription(description);
      const cacheKey = `${MODEL}|${PROMPT_VERSION}|${title.trim()}|${truncatedDescription}`;
      const cached = this.getCachedAnalysis(cacheKey);
      if (cached) {
        return cached;
      }
      if (!title.trim() || !description.trim()) {
        throw new Error("Job title and description are required");
      }
      const openaiService = getOpenAIService();
      if (!openaiService.hasApiKey()) {
        throw new Error("OpenAI API key is required for job analysis");
      }
      try {
        const analysis = await this.performAIAnalysis(title, truncatedDescription);
        this.cacheAnalysis(cacheKey, analysis);
        return analysis;
      } catch (error) {
        if (error && typeof error.code === "string") {
          throw error;
        }
        const wrappedError = new Error(`Job analysis failed: ${error instanceof Error ? error.message : "Unknown error"}`);
        wrappedError.code = "ERR_ANALYZER";
        throw wrappedError;
      }
    }
    /**
     * Truncate description with section-aware logic
     */
    truncateDescription(description) {
      if (description.length <= MAX_INPUT_LENGTH) {
        return description;
      }
      const sections = ["requirements", "qualifications", "responsibilities", "skills", "experience"];
      const sectionRegex = new RegExp(`(${sections.join("|")})`, "gi");
      const firstSectionIndex = description.search(sectionRegex);
      if (firstSectionIndex >= 0) {
        const fromFirstSection = description.substring(firstSectionIndex);
        if (fromFirstSection.length <= MAX_INPUT_LENGTH) {
          return fromFirstSection;
        }
        return fromFirstSection.substring(0, MAX_INPUT_LENGTH) + "...";
      }
      return description.substring(0, MAX_INPUT_LENGTH) + "...";
    }
    /**
     * Perform AI-powered analysis with OpenAI (simple JSON format)
     */
    async performAIAnalysis(title, truncatedDescription) {
      const openaiService = getOpenAIService();
      const prompt = `Analyze this job posting and extract structured information. Return ONLY valid JSON with no other text.

JOB TITLE: ${title}

JOB DESCRIPTION:
${truncatedDescription}

Return a JSON object with exactly these fields:
{
  "extractedSkills": ["skill1", "skill2", ...],
  "keyRequirements": ["requirement1", "requirement2", ...],
  "roleLevel": "entry|mid|senior|executive",
  "functionType": "string",
  "companyContext": "string"
}

Focus on:
- 8-12 key skills mentioned or implied
- 5-8 essential requirements for the role
- Experience level based on title and requirements
- Primary function area (e.g., "Product Management", "Strategy", "Engineering")
- Brief company/industry context if mentioned

Return ONLY the JSON object, no explanations or additional text.`;
      try {
        const response = await openaiService.createChatCompletion({
          model: MODEL,
          messages: [
            {
              role: "user",
              content: prompt
            }
          ],
          temperature: 0,
          max_tokens: 800
        });
        const content = response.choices[0]?.message?.content;
        if (!content) {
          throw new Error("No analysis content received from OpenAI");
        }
        const analysisData = this.parseJSONResponse(content);
        if (!analysisData.extractedSkills || !analysisData.keyRequirements || !analysisData.roleLevel) {
          throw new Error("Invalid response structure from AI");
        }
        const analysis = {
          title: title.trim(),
          description: truncatedDescription.trim(),
          extractedSkills: analysisData.extractedSkills || [],
          keyRequirements: analysisData.keyRequirements || [],
          roleLevel: analysisData.roleLevel || "mid",
          functionType: analysisData.functionType || "General",
          companyContext: analysisData.companyContext || void 0
        };
        return analysis;
      } catch (error) {
        throw new Error(`Analysis failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Parse JSON response with fallback handling
     */
    parseJSONResponse(content) {
      try {
        return JSON.parse(content);
      } catch (e) {
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          try {
            return JSON.parse(jsonMatch[0]);
          } catch (e2) {
            throw new SyntaxError("Could not parse JSON from response");
          }
        }
        throw new SyntaxError("No JSON found in response");
      }
    }
    /**
     * Get cached analysis if still valid
     */
    getCachedAnalysis(cacheKey) {
      if (!analysisCache) return null;
      const isExpired = Date.now() - analysisCache.timestamp > CACHE_DURATION;
      if (isExpired) {
        analysisCache = null;
        return null;
      }
      if (analysisCache.cacheKey === cacheKey) {
        return analysisCache.analysis;
      }
      return null;
    }
    /**
     * Cache analysis result
     */
    cacheAnalysis(cacheKey, analysis) {
      analysisCache = {
        cacheKey,
        analysis,
        timestamp: Date.now()
      };
    }
  };
  var globalJobAnalyzer = null;
  function getJobAnalyzer() {
    if (!globalJobAnalyzer) {
      globalJobAnalyzer = new JobAnalyzer();
    }
    return globalJobAnalyzer;
  }

  // src/workers/openai-batch-scorer.ts
  var MAX_TOKENS_PER_BATCH = 4e3;
  var MIN_BATCH_SIZE = 8;
  var MAX_BATCH_SIZE = 20;
  var TOKENS_PER_CHAR = 0.3;
  var OpenAIBatchScorer = class {
    /**
     * Score bullets using OpenAI in batches
     */
    async scoreBullets(jobAnalysis, bullets, onProgress) {
      const openaiService = getOpenAIService();
      if (!openaiService.hasApiKey()) {
        throw new Error("OpenAI API key required for scoring");
      }
      const batches = this.createBatches(jobAnalysis, bullets);
      if (batches.length === 0) {
        throw new Error("No batches created - insufficient bullet data");
      }
      const allScored = [];
      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        if (!batch) {
          console.warn(`Batch ${i} is undefined, skipping`);
          continue;
        }
        const progress = 0.4 + i / batches.length * 0.4;
        onProgress?.(`OpenAI scoring (batch ${i + 1}/${batches.length})...`, progress);
        try {
          const scored = await this.scoreBatch(batch, openaiService);
          allScored.push(...scored);
        } catch (error) {
          console.warn(`OpenAI batch ${i + 1} failed, retrying:`, error);
          await this.sleep(1e3);
          try {
            const scored = await this.scoreBatch(batch, openaiService);
            allScored.push(...scored);
          } catch (retryError) {
            console.error(`OpenAI batch ${i + 1} failed after retry:`, retryError);
            throw new Error(`OpenAI batch scoring failed: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        }
      }
      return this.normalizeScores(allScored, jobAnalysis.extractedSkills);
    }
    /**
     * Create batches optimized for OpenAI
     */
    createBatches(jobAnalysis, bullets) {
      const baseTokens = this.estimateBaseTokens(jobAnalysis);
      const batches = [];
      let currentBatch = [];
      let currentTokens = baseTokens;
      for (const bullet of bullets) {
        const bulletTokens = bullet.text.length * TOKENS_PER_CHAR + 60;
        if (currentBatch.length >= MIN_BATCH_SIZE && (currentTokens + bulletTokens > MAX_TOKENS_PER_BATCH || currentBatch.length >= MAX_BATCH_SIZE)) {
          batches.push(this.createBatchRequest(jobAnalysis, currentBatch));
          currentBatch = [bullet];
          currentTokens = baseTokens + bulletTokens;
        } else {
          currentBatch.push(bullet);
          currentTokens += bulletTokens;
        }
      }
      if (currentBatch.length > 0) {
        batches.push(this.createBatchRequest(jobAnalysis, currentBatch));
      }
      return batches;
    }
    /**
     * Score a single batch with OpenAI
     */
    async scoreBatch(batch, openaiService) {
      const systemPrompt = `You are a resume expert helping rank bullet points for job applications.

Rate each bullet point's relevance to the job on a scale of 1.0 to 10.0.

Consider:
- Direct skill/experience matches
- Quantified achievements and impact
- Leadership and cross-functional collaboration
- Technical depth and complexity
- Business results and outcomes

Respond with ONLY a JSON object in this exact format:
{
  "bullets": [
    {
      "id": "exact_id_from_input",
      "score": 8.5,
      "reasoning": "Brief explanation under 15 words",
      "skill_matches": ["list", "of", "matching", "skills"],
      "quality_flags": ["quantified", "leadership", "technical"]
    }
  ]
}`;
      const userPrompt = `Job Title: ${batch.jobTitle}

Job Requirements:
${batch.jobDescription.substring(0, 1500)}

Required Skills: ${batch.skills.join(", ")}

Rate these ${batch.bullets.length} bullet points:
${batch.bullets.map((b) => `ID: ${b.id}
Text: ${b.text}`).join("\n\n")}

Return JSON with ${batch.bullets.length} scored bullets.`;
      const response = await openaiService.createChatCompletion({
        model: "gpt-4o-mini",
        // OpenAI model
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ],
        temperature: 0.1,
        // Low temperature for consistent scoring
        max_tokens: 2e3,
        response_format: { type: "json_object" }
        // OpenAI JSON mode
      });
      const content = response.choices[0]?.message?.content;
      if (!content) {
        throw new Error("No response from OpenAI");
      }
      const parsed = this.parseOpenAIResponse(content, batch.bullets);
      return this.convertToScoredBullets(parsed, batch.bullets, batch.originalBullets);
    }
    /**
     * Parse OpenAI JSON response
     */
    parseOpenAIResponse(content, inputBullets) {
      let parsed;
      try {
        parsed = JSON.parse(content);
      } catch (e) {
        throw new Error(`Invalid JSON from OpenAI: ${e instanceof Error ? e.message : "Parse error"}`);
      }
      if (!parsed.bullets || !Array.isArray(parsed.bullets)) {
        throw new Error("OpenAI response missing bullets array");
      }
      if (parsed.bullets.length !== inputBullets.length) {
        console.warn(`Expected ${inputBullets.length} bullets, got ${parsed.bullets.length}`);
      }
      return parsed;
    }
    /**
    * Convert OpenAI response to ScoredBullet format - FIXED
    */
    convertToScoredBullets(parsed, inputBullets, originalBullets) {
      const results = [];
      for (const bullet of inputBullets) {
        const originalBullet = originalBullets.find((b) => b.bulletId === bullet.id);
        const result = parsed.bullets.find((b) => b.id === bullet.id);
        if (result) {
          results.push({
            bulletId: bullet.id,
            text: bullet.text,
            projectId: originalBullet?.projectId || "",
            //  Preserve original projectId
            roleId: originalBullet?.roleId || "",
            //  Preserve original roleId
            score: Math.max(1, Math.min(10, result.score)),
            normalizedScore: 0,
            reasons: result.reasoning || "OpenAI scoring",
            skillHits: Array.isArray(result.skill_matches) ? result.skill_matches : [],
            flags: Array.isArray(result.quality_flags) ? result.quality_flags : []
          });
        } else {
          results.push({
            bulletId: bullet.id,
            text: bullet.text,
            projectId: originalBullet?.projectId || "",
            //  Preserve original projectId
            roleId: originalBullet?.roleId || "",
            //  Preserve original roleId
            score: 5,
            normalizedScore: 0,
            reasons: "OpenAI fallback",
            skillHits: [],
            flags: ["fallback"]
          });
        }
      }
      return results;
    }
    /**
     * Normalize scores across all bullets
     */
    normalizeScores(bullets, skills) {
      if (bullets.length === 0) return bullets;
      const scores = bullets.map((b) => b.score);
      const minScore = Math.min(...scores);
      const maxScore = Math.max(...scores);
      const scoreRange = maxScore - minScore;
      return bullets.map((bullet) => ({
        ...bullet,
        normalizedScore: scoreRange > 0 ? 0.1 + 0.8 * ((bullet.score - minScore) / scoreRange) : 0.5
        // All same score
      }));
    }
    /**
     * Create batch request structure
     */
    createBatchRequest(jobAnalysis, bullets) {
      return {
        jobTitle: jobAnalysis.title,
        jobDescription: jobAnalysis.description,
        skills: jobAnalysis.extractedSkills,
        bullets: bullets.map((b) => ({ id: b.bulletId, text: b.text })),
        originalBullets: bullets
        // Include the original bullets
      };
    }
    /**
     * Estimate base token usage
     */
    estimateBaseTokens(jobAnalysis) {
      const titleTokens = jobAnalysis.title.length * TOKENS_PER_CHAR;
      const descTokens = Math.min(jobAnalysis.description.length * TOKENS_PER_CHAR, 500);
      const skillsTokens = jobAnalysis.extractedSkills.join(",").length * TOKENS_PER_CHAR;
      const systemPromptTokens = 300;
      return titleTokens + descTokens + skillsTokens + systemPromptTokens;
    }
    /**
     * Sleep utility
     */
    sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  };

  // src/utils/text-similarity.ts
  function calculateWordOverlapSimilarity(text1, text2) {
    const words1 = new Set(normalizeWords(text1));
    const words2 = new Set(normalizeWords(text2));
    const intersection = new Set([...words1].filter((word) => words2.has(word)));
    const union = /* @__PURE__ */ new Set([...words1, ...words2]);
    return union.size > 0 ? intersection.size / union.size : 0;
  }
  function createFingerprint(text) {
    return text.toLowerCase().replace(/[^\w\s]/g, "").replace(/\d+/g, "<NUM>").replace(/\s+/g, " ").trim();
  }
  function areDuplicates(text1, text2) {
    if (createFingerprint(text1) === createFingerprint(text2)) {
      return true;
    }
    const wordSim = calculateWordOverlapSimilarity(text1, text2);
    return wordSim > 0.8;
  }
  function normalizeWords(text) {
    return text.toLowerCase().replace(/[^\w\s]/g, " ").split(/\s+/).filter((word) => word.length > 2).filter((word) => !isStopWord(word));
  }
  function isStopWord(word) {
    const stopWords = /* @__PURE__ */ new Set([
      "the",
      "and",
      "or",
      "but",
      "in",
      "on",
      "at",
      "to",
      "for",
      "of",
      "with",
      "by",
      "from",
      "up",
      "about",
      "into",
      "through",
      "during",
      "before",
      "after",
      "above",
      "below",
      "was",
      "were",
      "been",
      "have",
      "has",
      "had",
      "do",
      "does",
      "did",
      "will",
      "would",
      "could",
      "should",
      "may",
      "might",
      "must",
      "can",
      "shall",
      "this",
      "that",
      "these",
      "those"
    ]);
    return stopWords.has(word);
  }

  // src/workers/bullet-selector.ts
  var BulletSelector = class {
    /**
     * Apply business rules and select final bullets with flexible project diversity
     */
    selectFinalBullets(bullets, roles) {
      bullets.sort((a, b) => b.normalizedScore - a.normalizedScore);
      const bulletsByRole = /* @__PURE__ */ new Map();
      for (const bullet of bullets) {
        if (!bulletsByRole.has(bullet.roleId)) {
          bulletsByRole.set(bullet.roleId, []);
        }
        bulletsByRole.get(bullet.roleId).push(bullet);
      }
      const allSelected = [];
      for (const [roleId, roleBullets] of bulletsByRole) {
        const role = roles.find((r) => r.id === roleId);
        const roleLimit = role?.bulletsLimit || 3;
        console.log(`Processing role ${roleId} with ${roleBullets.length} bullets, limit: ${roleLimit}`);
        const roleSelected = this.selectBulletsForRole(roleBullets, roleLimit);
        console.log(`Selected ${roleSelected.length} bullets for role ${roleId}`);
        for (const bullet of roleSelected) {
          if (allSelected.length >= 50) break;
          if (this.isRedundant(bullet, allSelected)) {
            console.log(`Bullet ${bullet.bulletId} rejected for redundancy`);
            continue;
          }
          if (this.hasDuplicateFingerprint(bullet, allSelected)) {
            console.log(`Bullet ${bullet.bulletId} rejected for duplicate fingerprint`);
            continue;
          }
          console.log(`Adding bullet ${bullet.bulletId} to final selection`);
          allSelected.push(bullet);
        }
      }
      console.log(`Final selection: ${allSelected.length} bullets`);
      return this.sortDeterministically(allSelected);
    }
    /**
     * Select bullets for a single role with diversity priority
     */
    selectBulletsForRole(roleBullets, roleLimit) {
      if (roleBullets.length === 0 || roleLimit === 0) return [];
      const bulletsByProject = /* @__PURE__ */ new Map();
      for (const bullet of roleBullets) {
        if (!bulletsByProject.has(bullet.projectId)) {
          bulletsByProject.set(bullet.projectId, []);
        }
        bulletsByProject.get(bullet.projectId).push(bullet);
      }
      for (const [_, projectBullets] of bulletsByProject) {
        projectBullets.sort((a, b) => b.normalizedScore - a.normalizedScore);
      }
      const selected = [];
      const projects = Array.from(bulletsByProject.keys());
      console.log(`Role has ${projects.length} projects, limit is ${roleLimit}`);
      for (const projectId of projects) {
        if (selected.length >= roleLimit) break;
        const projectBullets = bulletsByProject.get(projectId);
        if (projectBullets.length > 0) {
          if (projectBullets[0]) {
            selected.push(projectBullets[0]);
          }
          console.log(`Phase 1: Added bullet from project ${projectId}`);
        }
      }
      if (selected.length < roleLimit) {
        console.log(`Phase 2: Need ${roleLimit - selected.length} more bullets`);
        const remaining = [];
        for (const [projectId, projectBullets] of bulletsByProject) {
          const startIndex = selected.some((s) => s.projectId === projectId) ? 1 : 0;
          remaining.push(...projectBullets.slice(startIndex));
        }
        remaining.sort((a, b) => b.normalizedScore - a.normalizedScore);
        for (const bullet of remaining) {
          if (selected.length >= roleLimit) break;
          selected.push(bullet);
          console.log(`Phase 2: Added additional bullet from project ${bullet.projectId}`);
        }
      }
      console.log(`Role selection complete: ${selected.length} bullets from ${new Set(selected.map((b) => b.projectId)).size} projects`);
      return selected;
    }
    /**
     * Check if bullet is redundant with selected bullets
     */
    isRedundant(bullet, selected) {
      for (const existing of selected) {
        if (calculateWordOverlapSimilarity(bullet.text, existing.text) > 0.75) {
          return true;
        }
      }
      return false;
    }
    /**
     * Check for duplicate fingerprints using shared function
     */
    hasDuplicateFingerprint(bullet, selected) {
      const bulletFingerprint = createFingerprint(bullet.text);
      for (const existing of selected) {
        const existingFingerprint = createFingerprint(existing.text);
        if (areDuplicates(bulletFingerprint, existingFingerprint)) {
          return true;
        }
      }
      return false;
    }
    /**
     * Apply deterministic sorting for stable results
     */
    sortDeterministically(bullets) {
      return bullets.sort((a, b) => {
        if (Math.abs(a.normalizedScore - b.normalizedScore) > 1e-3) {
          return b.normalizedScore - a.normalizedScore;
        }
        const aQuantified = this.hasNumbers(a.text) ? 1 : 0;
        const bQuantified = this.hasNumbers(b.text) ? 1 : 0;
        if (aQuantified !== bQuantified) {
          return bQuantified - aQuantified;
        }
        return a.bulletId.localeCompare(b.bulletId);
      });
    }
    hasNumbers(text) {
      return /\d/.test(text);
    }
  };

  // src/utils/bm25-filter.ts
  var BM25_K1 = 1.5;
  var BM25_B = 0.75;
  function prefilterWithBM25(jobAnalysis, bullets, limit) {
    if (bullets.length === 0) return [];
    const searchTerms = extractSearchTerms(jobAnalysis);
    const scored = bullets.map((bullet) => ({
      bullet,
      score: calculateBM25Score(bullet.text, searchTerms, bullets)
    }));
    scored.sort((a, b) => b.score - a.score);
    return scored.slice(0, limit).map((item) => item.bullet);
  }
  function extractSearchTerms(jobAnalysis) {
    const terms = /* @__PURE__ */ new Set();
    jobAnalysis.title.toLowerCase().split(/\s+/).forEach((word) => {
      if (word.length > 2) terms.add(word);
    });
    jobAnalysis.extractedSkills.forEach((skill) => {
      const variants = generateSkillVariants(skill);
      variants.forEach((variant) => terms.add(variant.toLowerCase()));
    });
    jobAnalysis.keyRequirements.forEach((req) => {
      req.toLowerCase().split(/\s+/).forEach((word) => {
        if (word.length > 3) terms.add(word);
      });
    });
    return Array.from(terms);
  }
  function generateSkillVariants(skill) {
    const variants = [skill];
    const lower = skill.toLowerCase();
    variants.push(lower);
    variants.push(lower.replace(/\s+/g, ""));
    variants.push(lower.replace(/[^a-z0-9]/g, ""));
    const words = lower.split(/\s+/);
    if (words.length > 1) {
      const acronym = words.map((w) => w[0]).join("");
      if (acronym.length > 1) variants.push(acronym);
    }
    const expansions = {
      "sql": ["database", "queries"],
      "js": ["javascript"],
      "ai": ["artificial intelligence", "machine learning"],
      "ml": ["machine learning"],
      "pm": ["product management", "project management"]
    };
    if (expansions[lower]) {
      variants.push(...expansions[lower]);
    }
    return variants;
  }
  function calculateBM25Score(bulletText, searchTerms, allBullets) {
    const doc = bulletText.toLowerCase();
    const docWords = doc.split(/\s+/);
    const docLength = docWords.length;
    const avgDocLength = allBullets.reduce((sum, bullet) => {
      return sum + bullet.text.split(/\s+/).length;
    }, 0) / allBullets.length;
    let score = 0;
    for (const term of searchTerms) {
      const tf = docWords.filter((word) => word.includes(term)).length;
      if (tf === 0) continue;
      const df = allBullets.filter(
        (bullet) => bullet.text.toLowerCase().includes(term)
      ).length;
      const idf = Math.log((allBullets.length - df + 0.5) / (df + 0.5));
      const tfComponent = tf * (BM25_K1 + 1) / (tf + BM25_K1 * (1 - BM25_B + BM25_B * (docLength / avgDocLength)));
      score += idf * tfComponent;
    }
    score += calculateQualityBonus(bulletText);
    return score;
  }
  function calculateQualityBonus(text) {
    let bonus = 0;
    if (/\d+[%$]|\d+\s*(percent|million|billion|thousand)|\$\d+|\d+x/i.test(text)) {
      bonus += 0.3;
    }
    if (/^(led|managed|developed|created|implemented|optimized|increased|reduced|built|designed)/i.test(text)) {
      bonus += 0.2;
    }
    const wordCount = text.split(/\s+/).length;
    if (wordCount >= 10 && wordCount <= 30) {
      bonus += 0.1;
    }
    return bonus;
  }

  // src/workers/openai-ranking-engine.ts
  var OpenAIRankingEngine = class {
    batchScorer;
    // UPDATED TYPE
    bulletSelector;
    config;
    constructor(config = {}) {
      this.config = {
        maxBulletsPerRole: 60,
        maxTotalBullets: 240,
        fallbackToBM25: true,
        ...config
      };
      this.batchScorer = new OpenAIBatchScorer();
      this.bulletSelector = new BulletSelector();
    }
    /**
     * Main ranking pipeline
     */
    async rankBullets(jobTitle, jobDescription, bullets, roles, onProgress) {
      try {
        onProgress?.("Analyzing job description...", 0.1);
        const jobAnalyzer = getJobAnalyzer();
        const jobAnalysis = await jobAnalyzer.analyzeJob(jobTitle, jobDescription);
        onProgress?.("Filtering bullet points...", 0.2);
        const prefiltered = this.prefilterBullets(jobAnalysis, bullets, roles);
        if (prefiltered.length === 0) {
          throw new Error("No relevant bullet points found for this job description");
        }
        let scored;
        try {
          onProgress?.("Preparing OpenAI scoring...", 0.3);
          scored = await this.batchScorer.scoreBullets(jobAnalysis, prefiltered, onProgress);
        } catch (error) {
          console.warn("OpenAI scoring failed:", error);
          if (this.config.fallbackToBM25) {
            onProgress?.("Using fallback ranking...", 0.7);
            scored = this.createFallbackScores(prefiltered, jobAnalysis.extractedSkills);
          } else {
            throw error;
          }
        }
        onProgress?.("Selecting optimal set...", 0.9);
        return this.bulletSelector.selectFinalBullets(scored, roles);
      } catch (error) {
        throw new Error(`Ranking failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Prefilter bullets using BM25
     */
    prefilterBullets(jobAnalysis, bullets, roles) {
      const bulletsByRole = /* @__PURE__ */ new Map();
      for (const bullet of bullets) {
        if (!bulletsByRole.has(bullet.roleId)) {
          bulletsByRole.set(bullet.roleId, []);
        }
        bulletsByRole.get(bullet.roleId).push(bullet);
      }
      const prefiltered = [];
      let totalProcessed = 0;
      for (const [roleId, roleBullets] of bulletsByRole) {
        if (totalProcessed >= this.config.maxTotalBullets) break;
        const roleLimit = Math.min(
          this.config.maxBulletsPerRole,
          this.config.maxTotalBullets - totalProcessed
        );
        const filtered = prefilterWithBM25(jobAnalysis, roleBullets, roleLimit);
        for (const bullet of filtered) {
          prefiltered.push({
            bulletId: bullet.id,
            text: bullet.text,
            projectId: bullet.projectId,
            roleId: bullet.roleId,
            score: 5,
            normalizedScore: 0.5,
            reasons: "Prefiltered candidate",
            skillHits: [],
            flags: []
          });
        }
        totalProcessed += filtered.length;
      }
      return prefiltered;
    }
    /**
     * Create fallback scores using proper relevance + quality metrics when OpenAI fails
     */
    createFallbackScores(bullets, jobSkills) {
      console.log("\u{1F6A8} OpenAI failed - using fallback scoring for", bullets.length, "bullets");
      const scoredBullets = bullets.map((bullet) => {
        const relevanceScore = this.calculateBulletRelevance(bullet.text, jobSkills);
        const qualityScore = this.calculateQualityScore(bullet.text);
        const impactScore = this.calculateImpactScore(bullet.text);
        const totalScore = relevanceScore * 0.4 + qualityScore * 0.3 + impactScore * 0.3;
        const normalizedScore = Math.max(0.1, Math.min(0.95, totalScore));
        const skillHits = this.findSkillHits(bullet.text, jobSkills);
        let reasons = "Fallback relevance scoring";
        if (impactScore > 0.7) reasons += ", major business impact";
        if (skillHits.length > 0) reasons += `, ${skillHits.length} skill matches`;
        if (qualityScore > 0.7) reasons += ", high quality";
        return {
          ...bullet,
          score: totalScore * 10,
          // Scale to 0-10 range
          normalizedScore,
          reasons,
          skillHits,
          flags: ["fallback"]
        };
      });
      scoredBullets.sort((a, b) => b.normalizedScore - a.normalizedScore);
      console.log("\u{1F4CA} Top 5 fallback-scored bullets:");
      scoredBullets.slice(0, 5).forEach((bullet, i) => {
        console.log(`${i + 1}. [${bullet.normalizedScore.toFixed(3)}] ${bullet.text.substring(0, 100)}...`);
      });
      return scoredBullets;
    }
    /**
     * Calculate relevance score based on job skill and keyword matching
     */
    calculateBulletRelevance(bulletText, jobSkills) {
      const lowerText = bulletText.toLowerCase();
      let score = 0;
      const matchedSkills = jobSkills.filter(
        (skill) => lowerText.includes(skill.toLowerCase())
      );
      score += Math.min(0.4, matchedSkills.length * 0.1);
      const pmKeywords = ["product", "roadmap", "strategy", "feature", "requirements", "stakeholder", "user", "customer"];
      const pmMatches = pmKeywords.filter((keyword) => lowerText.includes(keyword));
      score += Math.min(0.3, pmMatches.length * 0.08);
      const techKeywords = ["engineering", "technical", "integration", "workflow", "system", "process"];
      const techMatches = techKeywords.filter((keyword) => lowerText.includes(keyword));
      score += Math.min(0.2, techMatches.length * 0.07);
      const leadershipKeywords = ["teams", "alignment", "collaboration", "cross-functional", "stakeholder"];
      const leadershipMatches = leadershipKeywords.filter((keyword) => lowerText.includes(keyword));
      score += Math.min(0.1, leadershipMatches.length * 0.05);
      return Math.min(1, score);
    }
    /**
     * Calculate quality score based on bullet structure and language
     */
    calculateQualityScore(text) {
      let score = 0;
      const lowerText = text.toLowerCase();
      const strongVerbs = [
        "designed",
        "built",
        "created",
        "developed",
        "implemented",
        "launched",
        "led",
        "managed",
        "drove",
        "delivered",
        "achieved",
        "increased",
        "improved",
        "optimized",
        "established",
        "defined",
        "aligned",
        "validated"
      ];
      if (strongVerbs.some((verb) => lowerText.startsWith(verb))) {
        score += 0.4;
      }
      const wordCount = text.split(/\s+/).length;
      if (wordCount >= 15 && wordCount <= 30) {
        score += 0.3;
      } else if (wordCount >= 10 && wordCount <= 35) {
        score += 0.2;
      }
      const professionalTerms = ["analysis", "strategy", "framework", "methodology", "requirements"];
      const profMatches = professionalTerms.filter((term) => lowerText.includes(term));
      score += Math.min(0.2, profMatches.length * 0.05);
      const weakTerms = ["helped", "assisted", "participated", "involved", "responsible for"];
      if (!weakTerms.some((term) => lowerText.includes(term))) {
        score += 0.1;
      }
      return Math.min(1, score);
    }
    /**
     * Calculate business impact score - KEY for ranking $160M bullet first
     */
    calculateImpactScore(text) {
      let score = 0;
      if (/\$\d{2,3}M\+?|\$\d+\s*million/i.test(text)) {
        score += 0.9;
      } else if (/\$\d+M|\$\d+K/i.test(text)) {
        score += 0.5;
      } else if (/\$\d+/.test(text)) {
        score += 0.3;
      }
      if (/\d+\s*teams/i.test(text)) {
        const match = text.match(/(\d+)\s*teams/i);
        if (match && match[1]) {
          const num = parseInt(match[1], 10);
          if (num >= 10) score += 0.4;
          else if (num >= 5) score += 0.3;
          else score += 0.2;
        }
      }
      const strategyKeywords = ["strategy", "roadmap", "revenue", "pilot", "expansion"];
      const strategyMatches = strategyKeywords.filter((word) => text.toLowerCase().includes(word));
      score += Math.min(0.3, strategyMatches.length * 0.1);
      if (/\d+/.test(text)) {
        score += 0.1;
      }
      if (/analysis|research|conjoint|primary/i.test(text)) {
        score += 0.2;
      }
      return Math.min(1, score);
    }
    /**
     * FIXED: Add missing findSkillHits method
     */
    findSkillHits(text, skills) {
      const hits = [];
      const lowerText = text.toLowerCase();
      for (const skill of skills) {
        if (lowerText.includes(skill.toLowerCase())) {
          hits.push(skill);
        }
      }
      return hits.slice(0, 5);
    }
  };

  // src/workers/recommendation-engine.ts
  var RecommendationEngine = class {
    openaiEngine;
    // RENAMED
    constructor() {
      this.openaiEngine = new OpenAIRankingEngine();
    }
    /**
     * Generate recommendations for a job application
     */
    async generateRecommendations(jobTitle, jobDescription, onProgress) {
      const startTime = Date.now();
      if (!jobTitle.trim() || !jobDescription.trim()) {
        throw new Error("Job title and description are required");
      }
      await this.validateUserHasExperience();
      try {
        onProgress?.("Loading experience data...", 0.05);
        const experienceData = await this.loadExperienceData();
        onProgress?.("Starting AI analysis...", 0.1);
        const scoredBullets = await this.openaiEngine.rankBullets(
          jobTitle,
          jobDescription,
          experienceData.bullets,
          experienceData.roles,
          onProgress
        );
        onProgress?.("Organizing results...", 0.95);
        const roleResults = this.convertToRoleResults(scoredBullets, experienceData);
        const processingTime = (Date.now() - startTime) / 1e3;
        return {
          jobTitle: jobTitle.trim(),
          totalBullets: scoredBullets.length,
          processingTime,
          roleResults
        };
      } catch (error) {
        throw new Error(`Recommendation generation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    // ... rest of the methods remain the same
    /**
     * Validate user has experience data
     */
    async validateUserHasExperience() {
      const [roles, bullets] = await Promise.all([
        getAll("roles"),
        getAll("bullets")
      ]);
      if (roles.length === 0) {
        throw new Error("You must add roles first. Please add your work experience in the Experience tab.");
      }
      if (bullets.length === 0) {
        throw new Error("You must add bullet points first. Please add bullet points for your roles in the Experience tab.");
      }
    }
    /**
     * Load user's experience data
     */
    async loadExperienceData() {
      const [roles, projects, bullets] = await Promise.all([
        getAll("roles"),
        getAll("projects"),
        getAll("bullets")
      ]);
      return { roles, projects, bullets };
    }
    /**
     * Convert scored bullets to role-based results format
     */
    convertToRoleResults(scoredBullets, experienceData) {
      const roleResults = [];
      const bulletsByRole = /* @__PURE__ */ new Map();
      for (const scoredBullet of scoredBullets) {
        if (!bulletsByRole.has(scoredBullet.roleId)) {
          bulletsByRole.set(scoredBullet.roleId, []);
        }
        bulletsByRole.get(scoredBullet.roleId).push(scoredBullet);
      }
      for (const [roleId, bullets] of bulletsByRole) {
        const role = experienceData.roles.find((r) => r.id === roleId);
        if (!role) continue;
        const selectedBullets = bullets.map((scoredBullet) => {
          const project = experienceData.projects.find((p) => p.id === scoredBullet.projectId);
          return {
            bulletId: scoredBullet.bulletId,
            text: scoredBullet.text,
            relevanceScore: scoredBullet.normalizedScore,
            projectName: project?.name || "Unknown Project",
            matchedSkills: scoredBullet.skillHits || []
          };
        });
        const avgRelevance = selectedBullets.length > 0 ? selectedBullets.reduce((sum, b) => sum + b.relevanceScore, 0) / selectedBullets.length : 0;
        const projectsUsed = [...new Set(selectedBullets.map((b) => b.projectName))];
        roleResults.push({
          roleId: role.id,
          roleTitle: `${role.title} (${role.company})`,
          selectedBullets,
          projectsUsed,
          avgRelevance
        });
      }
      roleResults.sort((a, b) => {
        const roleA = experienceData.roles.find((r) => r.id === a.roleId);
        const roleB = experienceData.roles.find((r) => r.id === b.roleId);
        return (roleA?.orderIndex || 0) - (roleB?.orderIndex || 0);
      });
      return roleResults;
    }
  };

  // src/ui/application-tab.ts
  var RecommendationService = class {
    engine;
    constructor() {
      this.engine = new RecommendationEngine();
    }
    async generateRecommendations(jobTitle, jobDescription) {
      return await this.engine.generateRecommendations(jobTitle, jobDescription);
    }
  };
  var recommendationService = null;
  function getRecommendationService() {
    if (!recommendationService) {
      recommendationService = new RecommendationService();
    }
    return recommendationService;
  }
  var ApplicationTab = class {
    container;
    processingState = "idle";
    lastResults = null;
    lastError = null;
    lastJobData = null;
    onStatusUpdate;
    constructor(container, onStatusUpdate) {
      this.container = container;
      this.onStatusUpdate = onStatusUpdate;
    }
    // ============================================================================
    // Public Interface
    // ============================================================================
    /**
     * Render the Application tab content
     */
    render() {
      this.container.innerHTML = "";
      const tabContainer = createSafeElement("div", "", "application-tab");
      const inputSection = this.createJobInputSection();
      tabContainer.appendChild(inputSection);
      if (this.lastResults || this.processingState !== "idle") {
        const resultsSection = this.createResultsSection();
        tabContainer.appendChild(resultsSection);
      }
      this.container.appendChild(tabContainer);
      this.addKeyboardShortcuts();
    }
    // ============================================================================
    // Job Input Section
    // ============================================================================
    /**
     * Create job input form section
     */
    createJobInputSection() {
      const section = createSafeElement("section", "", "job-input-section");
      const title = createSafeElement("h2", "New Job Application", "section-title");
      const description = createSafeElement(
        "p",
        "Paste your job description below and get AI-powered resume recommendations.",
        "section-description"
      );
      const form = this.createJobInputForm();
      section.appendChild(title);
      section.appendChild(description);
      section.appendChild(form);
      return section;
    }
    /**
     * Create job input form
     */
    createJobInputForm() {
      const form = createSafeElement("form", "", "job-input-form");
      form.setAttribute("data-form", "job-input");
      const titleGroup = this.createInputGroup(
        "job-title",
        "Job Title",
        "text",
        "e.g., Senior Product Manager"
      );
      const descriptionGroup = this.createTextareaGroup(
        "job-description",
        "Job Description",
        "Paste the complete job description here..."
      );
      const submitButton = document.createElement("button");
      submitButton.type = "submit";
      submitButton.className = "form-submit";
      submitButton.disabled = this.processingState === "processing" || this.processingState === "almost-done";
      setSafeTextContent(submitButton, this.getSubmitButtonText());
      form.appendChild(titleGroup);
      form.appendChild(descriptionGroup);
      form.appendChild(submitButton);
      form.addEventListener("submit", (event) => {
        event.preventDefault();
        if (event.target && this.isHTMLFormElement(event.target)) {
          this.handleFormSubmission(event.target);
        }
      });
      return form;
    }
    /**
     * Type guard for HTMLFormElement
     */
    isHTMLFormElement(element) {
      return element instanceof HTMLFormElement;
    }
    /**
     * Get submit button text based on processing state
     */
    getSubmitButtonText() {
      switch (this.processingState) {
        case "processing":
          return "Processing...";
        case "almost-done":
          return "Almost done...";
        default:
          return "Generate Recommendations";
      }
    }
    /**
     * Handle form submission
     */
    async handleFormSubmission(form) {
      const formData = new FormData(form);
      const jobTitle = formData.get("job-title")?.trim() || "";
      const jobDescription = formData.get("job-description")?.trim() || "";
      if (!jobTitle) {
        this.showInlineError("Please enter a job title");
        return;
      }
      if (!jobDescription || jobDescription.length < 10) {
        this.showInlineError("Please enter a job description (at least 10 characters)");
        return;
      }
      this.lastError = null;
      this.lastJobData = { title: jobTitle, description: jobDescription };
      try {
        this.updateProcessingState("processing");
        this.render();
        const service = getRecommendationService();
        setTimeout(() => {
          if (this.processingState === "processing") {
            this.updateProcessingState("almost-done");
            this.render();
          }
        }, 1500);
        const result = await service.generateRecommendations(jobTitle, jobDescription);
        this.lastResults = {
          jobTitle: result.jobTitle,
          totalBullets: result.totalBullets,
          processingTime: result.processingTime,
          projectsConsidered: result.roleResults.length,
          // Approximation for now
          roleResults: result.roleResults.map((role) => ({
            roleTitle: role.roleTitle,
            projectsShortlisted: [],
            // Will be populated in future iterations
            selectedBullets: role.selectedBullets.map((bullet) => ({
              text: bullet.text,
              relevance: bullet.relevanceScore ?? 0.9,
              projectName: bullet.projectName ?? "Unknown Project"
            })),
            avgRelevance: role.selectedBullets.reduce((avg, b) => avg + (b.relevanceScore ?? 0.9), 0) / role.selectedBullets.length
          }))
        };
        this.updateProcessingState("complete");
        if (this.onStatusUpdate) {
          this.onStatusUpdate({ success: `Generated ${result.totalBullets} recommendations in ${result.processingTime.toFixed(1)}s` });
        }
      } catch (error) {
        this.lastError = error instanceof Error ? error.message : "Unknown error occurred";
        this.updateProcessingState("error");
        if (this.lastError.includes("API key") || this.lastError.includes("network") || this.lastError.includes("OpenAI")) {
          if (this.onStatusUpdate) {
            this.onStatusUpdate({ error: this.lastError });
          }
        }
      }
      this.render();
    }
    /**
     * Update processing state
     */
    updateProcessingState(state) {
      this.processingState = state;
    }
    /**
     * Show inline error message
     */
    showInlineError(message) {
      this.lastError = message;
      this.processingState = "error";
      this.render();
    }
    /**
     * Create input group
     */
    createInputGroup(id, label, type, placeholder) {
      const group = createSafeElement("div", "", "input-group");
      const labelElement = createSafeElement("label", label, "input-label");
      labelElement.setAttribute("for", id);
      const input = document.createElement("input");
      input.type = type;
      input.id = id;
      input.name = id;
      input.className = "form-input";
      input.placeholder = placeholder;
      if (this.lastJobData) {
        if (id === "job-title") {
          input.value = this.lastJobData.title;
        }
      }
      group.appendChild(labelElement);
      group.appendChild(input);
      return group;
    }
    /**
     * Create textarea group
     */
    createTextareaGroup(id, label, placeholder) {
      const group = createSafeElement("div", "", "input-group");
      const labelElement = createSafeElement("label", label, "input-label");
      labelElement.setAttribute("for", id);
      const textarea = document.createElement("textarea");
      textarea.id = id;
      textarea.name = id;
      textarea.className = "form-textarea";
      textarea.placeholder = placeholder;
      textarea.rows = 8;
      if (this.lastJobData && id === "job-description") {
        textarea.value = this.lastJobData.description;
      }
      group.appendChild(labelElement);
      group.appendChild(textarea);
      return group;
    }
    // ============================================================================
    // Results Section
    // ============================================================================
    /**
     * Create results display section
     */
    createResultsSection() {
      const section = createSafeElement("section", "", "results-section");
      const title = createSafeElement("h3", "Recommendations", "results-title");
      section.appendChild(title);
      if (this.processingState === "processing" || this.processingState === "almost-done") {
        const status = this.createProcessingStatus();
        section.appendChild(status);
      } else if (this.processingState === "complete" && this.lastResults) {
        const summary = this.createResultsSummary();
        const details = this.createResultsDetails();
        const actions = this.createResultsActions();
        section.appendChild(summary);
        section.appendChild(details);
        section.appendChild(actions);
      } else if (this.processingState === "error") {
        const error = this.createErrorDisplay();
        section.appendChild(error);
      }
      return section;
    }
    /**
     * Create processing status display
     */
    createProcessingStatus() {
      const container = createSafeElement("div", "", "processing-status");
      const spinner = createSafeElement("div", "", "spinner");
      const statusText = this.processingState === "processing" ? "Analyzing job description and finding best matches..." : "Finalizing recommendations...";
      const status = createSafeElement("p", statusText, "status-text");
      container.appendChild(spinner);
      container.appendChild(status);
      return container;
    }
    /**
     * Create results summary box
     */
    createResultsSummary() {
      if (!this.lastResults) return createSafeElement("div", "", "results-summary");
      const summary = createSafeElement("div", "", "results-summary");
      const { totalBullets, processingTime, projectsConsidered } = this.lastResults;
      const summaryText = createSafeElement("p", "", "summary-text");
      setSafeTextContent(
        summaryText,
        `Selected ${totalBullets} bullet points across ${projectsConsidered} projects. Processing time: ${processingTime.toFixed(1)}s`
      );
      summary.appendChild(summaryText);
      return summary;
    }
    /**
     * Create detailed results display
     */
    createResultsDetails() {
      if (!this.lastResults) return createSafeElement("div", "", "results-details");
      const details = createSafeElement("div", "", "results-details");
      for (const roleResult of this.lastResults.roleResults) {
        const roleSection = this.createRoleResultSection(roleResult);
        details.appendChild(roleSection);
      }
      return details;
    }
    /**
     * Create role result section
     */
    createRoleResultSection(roleResult) {
      const section = createSafeElement("div", "", "role-result");
      const header = createSafeElement("h4", "", "role-title");
      setSafeTextContent(
        header,
        `${roleResult.roleTitle} - ${roleResult.selectedBullets.length} bullet points selected`
      );
      const bulletsList = createSafeElement("ul", "", "bullets-list");
      for (const bullet of roleResult.selectedBullets) {
        const listItem = createSafeElement("li", "", "bullet-item");
        const bulletText = createSafeElement("span", bullet.text, "bullet-text");
        const metadata = createSafeElement("span", "", "bullet-metadata");
        setSafeTextContent(
          metadata,
          ` (Relevance: ${(bullet.relevance * 100).toFixed(0)}%, Project: ${bullet.projectName})`
        );
        listItem.appendChild(bulletText);
        listItem.appendChild(metadata);
        bulletsList.appendChild(listItem);
      }
      section.appendChild(header);
      section.appendChild(bulletsList);
      return section;
    }
    /**
     * Create results actions (copy, export, etc.)
     */
    createResultsActions() {
      const actions = createSafeElement("div", "", "results-actions");
      const copyButton = document.createElement("button");
      copyButton.className = "form-button form-button--primary";
      setSafeTextContent(copyButton, "Copy All Bullets");
      copyButton.addEventListener("click", () => this.copyBulletsToClipboard());
      const regenerateButton = document.createElement("button");
      regenerateButton.className = "form-button form-button--secondary";
      setSafeTextContent(regenerateButton, "Regenerate");
      regenerateButton.addEventListener("click", () => this.regenerateRecommendations());
      actions.appendChild(copyButton);
      actions.appendChild(regenerateButton);
      return actions;
    }
    /**
     * Create error display
     */
    createErrorDisplay() {
      const container = createSafeElement("div", "", "error-display");
      const title = createSafeElement("h4", "Error Generating Recommendations", "error-title");
      const message = createSafeElement("p", this.lastError || "Unknown error", "error-message");
      const retryButton = document.createElement("button");
      retryButton.className = "form-button form-button--secondary";
      setSafeTextContent(retryButton, "Try Again");
      retryButton.addEventListener("click", () => {
        if (this.lastJobData) {
          const form = this.container.querySelector('form[data-form="job-input"]');
          if (form && this.isHTMLFormElement(form)) {
            this.handleFormSubmission(form);
          }
        }
      });
      container.appendChild(title);
      container.appendChild(message);
      container.appendChild(retryButton);
      return container;
    }
    // ============================================================================
    // Actions
    // ============================================================================
    /**
     * Copy bullets to clipboard (simple format)
     */
    async copyBulletsToClipboard() {
      if (!this.lastResults) return;
      const bullets = [];
      for (const roleResult of this.lastResults.roleResults) {
        for (const bullet of roleResult.selectedBullets) {
          bullets.push(`\u2022 ${bullet.text}`);
        }
      }
      const text = bullets.join("\n");
      try {
        await navigator.clipboard.writeText(text);
        if (this.onStatusUpdate) {
          this.onStatusUpdate({ success: `Copied ${bullets.length} bullet points to clipboard` });
        }
      } catch (error) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand("copy");
        document.body.removeChild(textArea);
        if (this.onStatusUpdate) {
          this.onStatusUpdate({ success: `Copied ${bullets.length} bullet points to clipboard` });
        }
      }
    }
    /**
     * Regenerate recommendations
     */
    regenerateRecommendations() {
      if (this.lastJobData) {
        const form = this.container.querySelector('form[data-form="job-input"]');
        if (form && this.isHTMLFormElement(form)) {
          this.handleFormSubmission(form);
        }
      }
    }
    // ============================================================================
    // Keyboard Shortcuts
    // ============================================================================
    /**
     * Add keyboard shortcuts
     */
    addKeyboardShortcuts() {
      const handleKeyPress = (event) => {
        if ((event.ctrlKey || event.metaKey) && event.key === "Enter") {
          event.preventDefault();
          const form = this.container.querySelector('form[data-form="job-input"]');
          if (form && this.isHTMLFormElement(form) && this.processingState === "idle") {
            this.handleFormSubmission(form);
          }
        }
        if ((event.ctrlKey || event.metaKey) && event.key === "c" && this.lastResults) {
          const activeElement = document.activeElement;
          if (!activeElement || activeElement.tagName !== "INPUT" && activeElement.tagName !== "TEXTAREA") {
            event.preventDefault();
            this.copyBulletsToClipboard();
          }
        }
      };
      document.addEventListener("keydown", handleKeyPress);
    }
  };

  // src/ui/settings-tab.ts
  init_xss_safe_rendering();

  // src/ui/api-config.ts
  init_xss_safe_rendering();
  init_transactions();
  var APIConfig = class {
    container = null;
    /**
     * Render API configuration interface
     */
    async render(container) {
      this.container = container;
      container.innerHTML = "";
      try {
        await initializeOpenAIService();
      } catch (error) {
        console.warn("Failed to initialize OpenAI service:", error);
      }
      const description = createSafeElement(
        "p",
        "Your OpenAI API key is stored locally in your browser and never exported. OpenAI works directly from the browser.",
        "section-description"
      );
      const form = this.createForm();
      container.appendChild(description);
      container.appendChild(form);
    }
    /**
     * Create API key form
     */
    createForm() {
      const form = createSafeElement("div", "", "api-form");
      const inputGroup = createSafeElement("div", "", "input-group");
      const label = createSafeElement("label", "OpenAI API Key", "input-label");
      label.setAttribute("for", "api-key");
      const keyInput = document.createElement("input");
      keyInput.type = "password";
      keyInput.id = "api-key";
      keyInput.className = "form-input";
      keyInput.placeholder = "sk-proj-...";
      const openaiService = getOpenAIService();
      if (openaiService.hasApiKey()) {
        keyInput.value = "***key-stored***";
        keyInput.disabled = true;
      }
      inputGroup.appendChild(label);
      inputGroup.appendChild(keyInput);
      const buttonGroup = createSafeElement("div", "", "button-group");
      const saveBtn = this.createSaveButton(keyInput);
      const testBtn = this.createTestButton();
      const forgetBtn = this.createForgetButton();
      buttonGroup.appendChild(saveBtn);
      buttonGroup.appendChild(testBtn);
      buttonGroup.appendChild(forgetBtn);
      form.appendChild(inputGroup);
      form.appendChild(buttonGroup);
      return form;
    }
    /**
     * Create save button
     */
    createSaveButton(keyInput) {
      const button = document.createElement("button");
      button.type = "button";
      button.className = "form-button form-button--primary";
      const openaiService = getOpenAIService();
      setSafeTextContent(button, openaiService.hasApiKey() ? "Update Key" : "Save Key");
      button.addEventListener("click", async () => {
        await this.saveKey(keyInput.value);
      });
      return button;
    }
    /**
     * Create test button
     */
    createTestButton() {
      const button = document.createElement("button");
      button.type = "button";
      button.className = "form-button form-button--secondary";
      setSafeTextContent(button, "Test Connection");
      button.addEventListener("click", async () => {
        await this.testConnection();
      });
      return button;
    }
    /**
     * Create forget button
     */
    createForgetButton() {
      const button = document.createElement("button");
      button.type = "button";
      button.className = "form-button form-button--danger";
      setSafeTextContent(button, "Forget Key");
      const openaiService = getOpenAIService();
      button.style.display = openaiService.hasApiKey() ? "inline-block" : "none";
      button.addEventListener("click", () => {
        this.forgetKey();
      });
      return button;
    }
    // ============================================================================
    // Actions
    // ============================================================================
    /**
     * Save API key - DEBUG VERSION
     */
    async saveKey(key) {
      if (!key || key === "***key-stored***") {
        alert("Please enter a valid OpenAI API key");
        return;
      }
      try {
        console.log("INPUT KEY:", key);
        const openaiService = await initializeOpenAIService();
        await openaiService.setApiKey(key);
        const storedValue = await getSetting("openai_api_key");
        console.log("STORED VALUE:", storedValue);
        console.log("SERVICE HAS KEY:", openaiService.hasApiKey());
        console.log("SERVICE KEY VALUE:", openaiService.hasApiKey() ? openaiService.getApiKey() : "NO KEY");
        await new Promise((resolve) => setTimeout(resolve, 100));
        const result = await openaiService.testApiKey();
        if (!result.isValid) {
          await openaiService.clearApiKey();
          throw new Error(result.error || "Connection test failed");
        }
        alert("OpenAI API key saved and tested successfully");
        if (this.container) {
          await this.render(this.container);
        }
      } catch (error) {
        console.error("SAVE KEY ERROR:", error);
        alert(`Failed to save API key: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Test connection - DEBUG VERSION
     */
    async testConnection() {
      try {
        console.log("TESTING CONNECTION...");
        const openaiService = await initializeOpenAIService();
        if (!openaiService.hasApiKey()) {
          console.log("NO API KEY FOUND");
          alert("No OpenAI API key configured");
          return;
        }
        console.log("SERVICE HAS KEY, TESTING...");
        const result = await openaiService.testApiKey();
        console.log("TEST RESULT:", result);
        if (result.isValid) {
          alert("Connection test successful");
        } else {
          alert(`Connection test failed: ${result.error}`);
        }
      } catch (error) {
        console.error("TEST CONNECTION ERROR:", error);
        alert(`Connection test failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Forget API key
     */
    async forgetKey() {
      if (confirm("Are you sure you want to forget your OpenAI API key? This will disable AI functionality.")) {
        try {
          const openaiService = await initializeOpenAIService();
          await openaiService.clearApiKey();
          if (this.container) {
            await this.render(this.container);
          }
          alert("OpenAI API key forgotten");
        } catch (error) {
          alert(`Failed to forget API key: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
    }
  };

  // src/ui/role-manager.ts
  init_xss_safe_rendering();
  init_transactions();

  // src/utils/simple-modal.ts
  init_xss_safe_rendering();
  function createSimpleModal(title, formContent, onSubmit, onCancel) {
    const mainContent = document.querySelector(".main-content") || document.body;
    const backdrop = createSafeElement("div", "", "modal-backdrop");
    backdrop.style.cssText = `
    position: fixed;
    top: 0;
    left: 250px;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  `;
    const modal = createSafeElement("div", "", "modal-content");
    modal.style.cssText = `
    background: white;
    border-radius: 8px;
    padding: 0;
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
  `;
    const header = createSafeElement("div", "", "modal-header");
    header.style.cssText = `
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
  `;
    const titleElement = createSafeElement("h2", title, "modal-title");
    titleElement.style.cssText = `
    margin: 0;
    font-size: 1.25rem;
    font-weight: 600;
  `;
    const closeButton = document.createElement("button");
    closeButton.type = "button";
    closeButton.className = "close-button";
    closeButton.style.cssText = `
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
  `;
    setSafeTextContent(closeButton, "\xD7");
    header.appendChild(titleElement);
    header.appendChild(closeButton);
    const body = createSafeElement("div", "", "modal-body");
    body.style.cssText = `
    padding: 1.5rem;
  `;
    body.appendChild(formContent);
    const footer = createSafeElement("div", "", "modal-footer");
    footer.style.cssText = `
    padding: 1rem 1.5rem;
    border-top: 1px solid #e5e7eb;
    display: flex;
    gap: 0.5rem;
    justify-content: flex-end;
  `;
    const cancelBtn = document.createElement("button");
    cancelBtn.type = "button";
    cancelBtn.className = "form-button form-button--secondary";
    cancelBtn.style.cssText = `
    padding: 0.5rem 1rem;
    border: 1px solid #d1d5db;
    background: white;
    border-radius: 4px;
    cursor: pointer;
  `;
    setSafeTextContent(cancelBtn, "Cancel");
    const submitBtn = document.createElement("button");
    submitBtn.type = "button";
    submitBtn.className = "form-button form-button--primary";
    submitBtn.style.cssText = `
    padding: 0.5rem 1rem;
    border: none;
    background: #3b82f6;
    color: white;
    border-radius: 4px;
    cursor: pointer;
  `;
    setSafeTextContent(submitBtn, "Save");
    footer.appendChild(cancelBtn);
    footer.appendChild(submitBtn);
    modal.appendChild(header);
    modal.appendChild(body);
    modal.appendChild(footer);
    backdrop.appendChild(modal);
    const closeModal = () => {
      mainContent.removeChild(backdrop);
      document.removeEventListener("keydown", handleKeydown);
      if (onCancel) onCancel();
    };
    const handleSubmit = async () => {
      try {
        const formData = new FormData();
        const inputs = modal.querySelectorAll("input, select, textarea");
        inputs.forEach((input) => {
          const element = input;
          if (element.name) {
            if (element.type === "checkbox") {
              formData.append(element.name, element.checked ? "true" : "false");
            } else {
              formData.append(element.name, element.value);
            }
          }
        });
        await onSubmit(formData);
        closeModal();
      } catch (error) {
        console.error("Modal submit error:", error);
        alert(error instanceof Error ? error.message : "An error occurred");
      }
    };
    const handleKeydown = (event) => {
      if (event.key === "Escape") {
        closeModal();
      } else if (event.key === "Enter" && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();
        handleSubmit();
      }
    };
    closeButton.addEventListener("click", closeModal);
    cancelBtn.addEventListener("click", closeModal);
    submitBtn.addEventListener("click", handleSubmit);
    backdrop.addEventListener("click", (event) => {
      if (event.target === backdrop) {
        closeModal();
      }
    });
    document.addEventListener("keydown", handleKeydown);
    mainContent.appendChild(backdrop);
    const firstInput = modal.querySelector("input, select, textarea");
    if (firstInput) {
      firstInput.focus();
    }
  }

  // src/ui/role-manager.ts
  var RoleManager = class {
    container = null;
    roles = [];
    sortBy = "endDate";
    /**
     * Render role management interface
     */
    async render(container) {
      this.container = container;
      await this.loadRoles();
      container.innerHTML = "";
      const header = this.createHeader();
      const rolesList = this.createRolesList();
      container.appendChild(header);
      container.appendChild(rolesList);
    }
    /**
     * Create header with add button and sort control
     */
    createHeader() {
      const header = createSafeElement("div", "", "role-manager-header");
      header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1rem;
    `;
      const leftSection = createSafeElement("div", "", "header-left");
      const description = createSafeElement(
        "p",
        "Roles are automatically sorted by date (most recent first). Set bullet limits for recommendations.",
        "section-description"
      );
      const addBtn = document.createElement("button");
      addBtn.className = "form-button form-button--primary";
      addBtn.style.marginTop = "0.5rem";
      setSafeTextContent(addBtn, "Add Role");
      addBtn.addEventListener("click", () => this.showAddModal());
      leftSection.appendChild(description);
      leftSection.appendChild(addBtn);
      const sortSection = createSafeElement("div", "", "header-sort");
      const sortLabel = createSafeElement("label", "Sort by:", "sort-label");
      sortLabel.style.cssText = `
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      color: #374151;
      margin-bottom: 0.25rem;
    `;
      const sortSelect = document.createElement("select");
      sortSelect.style.cssText = `
      padding: 0.375rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.875rem;
      background: white;
    `;
      const endDateOption = document.createElement("option");
      endDateOption.value = "endDate";
      setSafeTextContent(endDateOption, "End Date");
      endDateOption.selected = this.sortBy === "endDate";
      const startDateOption = document.createElement("option");
      startDateOption.value = "startDate";
      setSafeTextContent(startDateOption, "Start Date");
      startDateOption.selected = this.sortBy === "startDate";
      sortSelect.appendChild(endDateOption);
      sortSelect.appendChild(startDateOption);
      sortSelect.addEventListener("change", () => {
        this.sortBy = sortSelect.value;
        this.render(this.container);
      });
      sortSection.appendChild(sortLabel);
      sortSection.appendChild(sortSelect);
      header.appendChild(leftSection);
      header.appendChild(sortSection);
      return header;
    }
    /**
     * Create roles list
     */
    createRolesList() {
      const container = createSafeElement("div", "", "roles-list");
      container.style.cssText = `
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 0.75rem;
    `;
      if (this.roles.length === 0) {
        const empty = createSafeElement("div", "No roles configured. Add your first role to get started.", "empty-state");
        empty.style.cssText = `
        padding: 2rem;
        text-align: center;
        color: #6b7280;
        border: 2px dashed #d1d5db;
        border-radius: 8px;
      `;
        container.appendChild(empty);
        return container;
      }
      const sortedRoles = this.getSortedRoles();
      sortedRoles.forEach((role) => {
        const item = this.createRoleCard(role);
        container.appendChild(item);
      });
      return container;
    }
    /**
     * Get roles sorted by current criteria
     */
    getSortedRoles() {
      return [...this.roles].sort((a, b) => {
        if (this.sortBy === "endDate") {
          const aDate = a.endDate || "9999-99";
          const bDate = b.endDate || "9999-99";
          return bDate.localeCompare(aDate);
        } else {
          return b.startDate.localeCompare(a.startDate);
        }
      });
    }
    /**
     * Create compact role card
     */
    createRoleCard(role) {
      const card = createSafeElement("div", "", "role-card");
      card.style.cssText = `
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 0.75rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      transition: box-shadow 0.15s ease;
    `;
      const topLine = createSafeElement("div", "", "role-top-line");
      topLine.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    `;
      const nameSection = createSafeElement("div", "", "role-name");
      const title = createSafeElement("div", `${role.title} at ${role.company}`, "role-title");
      title.style.cssText = `
      font-weight: 600;
      font-size: 0.95rem;
      color: #111827;
    `;
      nameSection.appendChild(title);
      const dateSection = createSafeElement("div", "", "role-date");
      const dates = createSafeElement("div", this.formatDateRange(role), "role-dates");
      dates.style.cssText = `
      color: #6b7280;
      font-size: 0.8rem;
      text-align: right;
    `;
      dateSection.appendChild(dates);
      topLine.appendChild(nameSection);
      topLine.appendChild(dateSection);
      const bottomLine = createSafeElement("div", "", "role-bottom-line");
      bottomLine.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
    `;
      const bulletsSection = createSafeElement("div", "", "role-bullets");
      bulletsSection.style.cssText = `
      display: flex;
      align-items: center;
      gap: 0.5rem;
    `;
      const bulletsLabel = createSafeElement("span", "Bullets:", "bullets-label");
      bulletsLabel.style.cssText = `
      font-size: 0.8rem;
      color: #374151;
      font-weight: 500;
    `;
      const limitInput = document.createElement("input");
      limitInput.type = "number";
      limitInput.min = "1";
      limitInput.max = "10";
      limitInput.value = role.bulletsLimit.toString();
      limitInput.style.cssText = `
      width: 50px;
      padding: 0.2rem 0.4rem;
      border: 1px solid #d1d5db;
      border-radius: 3px;
      text-align: center;
      font-size: 0.8rem;
    `;
      limitInput.addEventListener("change", () => this.updateLimit(role.id, parseInt(limitInput.value)));
      bulletsSection.appendChild(bulletsLabel);
      bulletsSection.appendChild(limitInput);
      const actionsSection = createSafeElement("div", "", "role-actions");
      actionsSection.style.cssText = `
      display: flex;
      gap: 0.4rem;
    `;
      const editBtn = this.createActionButton("Edit", "secondary", () => this.showEditModal(role.id));
      const deleteBtn = this.createActionButton("Delete", "danger", () => this.deleteRole(role.id));
      actionsSection.appendChild(editBtn);
      actionsSection.appendChild(deleteBtn);
      bottomLine.appendChild(bulletsSection);
      bottomLine.appendChild(actionsSection);
      card.appendChild(topLine);
      card.appendChild(bottomLine);
      card.addEventListener("mouseenter", () => {
        card.style.boxShadow = "0 3px 6px rgba(0, 0, 0, 0.15)";
      });
      card.addEventListener("mouseleave", () => {
        card.style.boxShadow = "0 1px 3px rgba(0, 0, 0, 0.1)";
      });
      return card;
    }
    /**
     * Create compact action button
     */
    createActionButton(text, variant, onClick) {
      const button = document.createElement("button");
      button.type = "button";
      setSafeTextContent(button, text);
      button.addEventListener("click", onClick);
      const baseStyles = `
      padding: 0.3rem 0.6rem;
      border-radius: 3px;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    `;
      if (variant === "danger") {
        button.style.cssText = baseStyles + `
        background: #fef2f2;
        color: #dc2626;
        border: 1px solid #fecaca;
      `;
      } else {
        button.style.cssText = baseStyles + `
        background: #f9fafb;
        color: #374151;
        border: 1px solid #d1d5db;
      `;
      }
      return button;
    }
    // ============================================================================
    // Actions
    // ============================================================================
    /**
     * Update bullet limit
     */
    async updateLimit(roleId, limit) {
      if (limit < 1 || limit > 10 || isNaN(limit)) {
        alert("Bullet limit must be between 1 and 10");
        if (this.container) await this.render(this.container);
        return;
      }
      try {
        const role = this.roles.find((r) => r.id === roleId);
        if (!role) return;
        role.bulletsLimit = limit;
        await update("roles", role);
      } catch (error) {
        alert(`Failed to update limit: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Delete role
     */
    async deleteRole(roleId) {
      const role = this.roles.find((r) => r.id === roleId);
      if (!role) return;
      if (!confirm(`Delete "${role.title} at ${role.company}"? This will also delete associated data.`)) {
        return;
      }
      try {
        await deleteById("roles", roleId);
        if (this.container) await this.render(this.container);
      } catch (error) {
        alert(`Failed to delete role: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Show add modal
     */
    showAddModal() {
      createSimpleModal("Add Role", this.createRoleForm(), (formData) => {
        this.saveRole(formData);
      });
    }
    /**
     * Show edit modal
     */
    showEditModal(roleId) {
      const role = this.roles.find((r) => r.id === roleId);
      if (!role) return;
      createSimpleModal("Edit Role", this.createRoleForm(role), (formData) => {
        this.saveRole(formData, role.id);
      });
    }
    /**
     * Create role form with simple date inputs
     */
    createRoleForm(role) {
      const form = createSafeElement("div", "", "role-form");
      const titleGroup = this.createInputGroup("title", "Job Title", "text", "e.g., Senior Product Manager");
      if (role) titleGroup.querySelector("input").value = role.title;
      const companyGroup = this.createInputGroup("company", "Company", "text", "e.g., Google");
      if (role) companyGroup.querySelector("input").value = role.company;
      const startGroup = this.createDateInputGroup("startDate", "Start Date", "e.g., 2023-01");
      if (role) startGroup.querySelector("input").value = role.startDate;
      const endGroup = this.createDateInputGroup("endDate", "End Date", "e.g., 2024-12");
      if (role && role.endDate) endGroup.querySelector("input").value = role.endDate;
      const currentGroup = createSafeElement("div", "", "input-group");
      const currentLabel = createSafeElement("label", "", "checkbox-label");
      const currentCheckbox = document.createElement("input");
      currentCheckbox.type = "checkbox";
      currentCheckbox.name = "isCurrent";
      currentCheckbox.checked = role ? !role.endDate : false;
      const checkboxText = createSafeElement("span", "This is my current role", "");
      currentLabel.appendChild(currentCheckbox);
      currentLabel.appendChild(checkboxText);
      currentGroup.appendChild(currentLabel);
      const endInput = endGroup.querySelector("input");
      const updateEndDateState = () => {
        endInput.disabled = currentCheckbox.checked;
        if (currentCheckbox.checked) {
          endInput.value = "";
        }
      };
      currentCheckbox.addEventListener("change", updateEndDateState);
      updateEndDateState();
      form.appendChild(titleGroup);
      form.appendChild(companyGroup);
      form.appendChild(startGroup);
      form.appendChild(endGroup);
      form.appendChild(currentGroup);
      return form;
    }
    /**
     * Create input group helper
     */
    createInputGroup(name, label, type, placeholder) {
      const group = createSafeElement("div", "", "input-group");
      const labelElement = createSafeElement("label", label, "input-label");
      const input = document.createElement("input");
      input.type = type;
      input.name = name;
      input.className = "form-input";
      input.placeholder = placeholder;
      if (name === "title" || name === "company") {
        input.required = true;
      }
      group.appendChild(labelElement);
      group.appendChild(input);
      return group;
    }
    /**
     * Create date input group with validation
     */
    createDateInputGroup(name, label, placeholder) {
      const group = createSafeElement("div", "", "input-group");
      const labelElement = createSafeElement("label", label, "input-label");
      const input = document.createElement("input");
      input.type = "text";
      input.name = name;
      input.className = "form-input";
      input.placeholder = placeholder;
      input.pattern = "^\\d{4}-\\d{2}$";
      input.title = "Format: YYYY-MM (e.g., 2023-01)";
      const helper = createSafeElement("small", "Format: YYYY-MM", "input-helper");
      if (name === "startDate") {
        input.required = true;
      }
      group.appendChild(labelElement);
      group.appendChild(input);
      group.appendChild(helper);
      return group;
    }
    /**
     * Save role
     */
    async saveRole(formData, roleId) {
      const title = formData.get("title");
      const company = formData.get("company");
      const startDate = formData.get("startDate");
      const endDate = formData.get("endDate");
      const isCurrent = formData.get("isCurrent") === "true";
      if (!title || !company || !startDate) {
        alert("Title, company, and start date are required");
        return;
      }
      const datePattern = /^\d{4}-\d{2}$/;
      if (!datePattern.test(startDate)) {
        alert("Start date must be in YYYY-MM format (e.g., 2023-01)");
        return;
      }
      if (endDate && !isCurrent && !datePattern.test(endDate)) {
        alert("End date must be in YYYY-MM format (e.g., 2024-12)");
        return;
      }
      try {
        if (roleId) {
          const role = this.roles.find((r) => r.id === roleId);
          if (role) {
            role.title = title;
            role.company = company;
            role.startDate = startDate;
            role.endDate = isCurrent ? null : endDate || null;
            await update("roles", role);
          }
        } else {
          const newRole = {
            id: `role_${Date.now()}`,
            title,
            company,
            orderIndex: 0,
            // Not used anymore but keeping for compatibility
            bulletsLimit: 3,
            startDate,
            endDate: isCurrent ? null : endDate || null
          };
          await update("roles", newRole);
        }
        if (this.container) await this.render(this.container);
      } catch (error) {
        alert(`Failed to save role: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    // ============================================================================
    // Utilities
    // ============================================================================
    /**
     * Load roles from storage
     */
    async loadRoles() {
      this.roles = await getAll("roles");
    }
    /**
     * Format date range
     */
    formatDateRange(role) {
      return role.endDate ? `${role.startDate} - ${role.endDate}` : `${role.startDate} - Present`;
    }
  };

  // src/ui/settings-tab.ts
  init_transactions();
  var SettingsTab = class {
    container;
    apiConfig;
    roleManager;
    constructor(container) {
      this.container = container;
      this.apiConfig = new APIConfig();
      this.roleManager = new RoleManager();
    }
    // ============================================================================
    // Public Interface
    // ============================================================================
    /**
     * Render the Settings tab content
     */
    async render() {
      this.container.innerHTML = "";
      const tabContainer = createSafeElement("div", "", "settings-tab");
      const apiSection = await this.createAPISection();
      const roleSection = await this.createRoleSection();
      const dataSection = await this.createDataSection();
      tabContainer.appendChild(apiSection);
      tabContainer.appendChild(roleSection);
      tabContainer.appendChild(dataSection);
      this.container.appendChild(tabContainer);
    }
    // ============================================================================
    // Section Creation
    // ============================================================================
    /**
     * Create API configuration section
     */
    async createAPISection() {
      const section = createSafeElement("section", "", "settings-section");
      const title = createSafeElement("h2", "AI Configuration", "section-title");
      const configContainer = createSafeElement("div", "", "api-config-container");
      await this.apiConfig.render(configContainer);
      section.appendChild(title);
      section.appendChild(configContainer);
      return section;
    }
    /**
     * Create role management section
     */
    async createRoleSection() {
      const section = createSafeElement("section", "", "settings-section");
      const title = createSafeElement("h2", "Role Management", "section-title");
      const managerContainer = createSafeElement("div", "", "role-manager-container");
      await this.roleManager.render(managerContainer);
      section.appendChild(title);
      section.appendChild(managerContainer);
      return section;
    }
    /**
     * Create data management section
     */
    async createDataSection() {
      const section = createSafeElement("section", "", "settings-section");
      const title = createSafeElement("h2", "Data Management", "section-title");
      const usage = await this.createStorageUsage();
      const actions = this.createDataActions();
      section.appendChild(title);
      section.appendChild(usage);
      section.appendChild(actions);
      return section;
    }
    /**
     * Create storage usage display
     */
    async createStorageUsage() {
      const container = createSafeElement("div", "", "storage-usage");
      try {
        const [roles, bullets, projects] = await Promise.all([
          getAll("roles"),
          getAll("bullets"),
          getAll("projects")
        ]);
        const stats = createSafeElement("div", "", "usage-stats");
        const roleCount = createSafeElement("span", `${roles.length} roles`, "stat-item");
        const bulletCount = createSafeElement("span", `${bullets.length} bullets`, "stat-item");
        const projectCount = createSafeElement("span", `${projects.length} projects`, "stat-item");
        stats.appendChild(roleCount);
        stats.appendChild(bulletCount);
        stats.appendChild(projectCount);
        container.appendChild(stats);
      } catch (error) {
        const errorMsg = createSafeElement("div", "Unable to load storage usage", "error-text");
        container.appendChild(errorMsg);
      }
      return container;
    }
    /**
     * Create data action buttons
     */
    createDataActions() {
      const actions = createSafeElement("div", "", "data-actions");
      const exportBtn = document.createElement("button");
      exportBtn.className = "form-button form-button--secondary";
      setSafeTextContent(exportBtn, "Export Data");
      exportBtn.addEventListener("click", () => this.exportData());
      const importBtn = document.createElement("button");
      importBtn.className = "form-button form-button--secondary";
      setSafeTextContent(importBtn, "Import Data");
      importBtn.addEventListener("click", () => this.importData());
      actions.appendChild(exportBtn);
      actions.appendChild(importBtn);
      return actions;
    }
    // ============================================================================
    // Data Operations
    // ============================================================================
    /**
     * Export all data
     */
    async exportData() {
      try {
        const [roles, projects, bullets] = await Promise.all([
          getAll("roles"),
          getAll("projects"),
          getAll("bullets")
        ]);
        const exportData = {
          version: 1,
          timestamp: Date.now(),
          data: { roles, projects, bullets }
        };
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `resuum-export-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
        link.click();
        URL.revokeObjectURL(url);
      } catch (error) {
        alert(`Export failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Import data
     */
    importData() {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.addEventListener("change", async (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        try {
          const text = await file.text();
          const importData = JSON.parse(text);
          if (!importData.version || !importData.data) {
            throw new Error("Invalid file format");
          }
          alert("Import functionality coming soon");
        } catch (error) {
          alert(`Import failed: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      });
      input.click();
    }
  };

  // src/ui/app.ts
  var TAB_CONFIGS = [
    {
      id: "application",
      label: "New Application",
      icon: "\u{1F4DD}",
      description: "Generate recommendations for a job application"
    },
    {
      id: "experience",
      label: "Experience",
      icon: "\u{1F4BC}",
      description: "Manage your bullet points and projects"
    },
    {
      id: "settings",
      label: "Settings",
      icon: "\u2699\uFE0F",
      description: "Configure API key and data management"
    }
  ];
  var ResuumApp = class {
    state = {
      currentTab: "application",
      loading: false
    };
    container;
    tabNavigation = null;
    tabContent = null;
    statusBar = null;
    // Tab instances
    applicationTab = null;
    settingsTab = null;
    constructor(containerId) {
      const container = document.getElementById(containerId);
      if (!container) {
        throw new Error(`Container element with id "${containerId}" not found`);
      }
      this.container = container;
    }
    // ============================================================================
    // Initialization
    // ============================================================================
    /**
     * Initialize the application UI
     */
    async initialize() {
      try {
        this.showLoading("Initializing Resuum...");
        this.container.innerHTML = "";
        this.buildUIStructure();
        await this.switchTab("application");
        this.hideLoading();
        this.showSuccess("Resuum initialized successfully");
      } catch (error) {
        this.showError(`Failed to initialize: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Build the main UI structure
     */
    buildUIStructure() {
      this.container.innerHTML = "";
      const sidebarNav = document.getElementById("sidebar-nav");
      if (sidebarNav) {
        const navigation = this.createTabNavigation();
        sidebarNav.appendChild(navigation);
        this.tabNavigation = navigation;
      }
      const content = this.createTabContent();
      const status = this.createStatusBar();
      this.container.appendChild(content);
      this.container.appendChild(status);
      this.tabContent = content;
      this.statusBar = status;
    }
    /**
     * Create tab navigation
     */
    createTabNavigation() {
      const nav = createSafeElement("nav", "", "tab-navigation");
      const tabList = createSafeElement("ul", "", "tab-list");
      TAB_CONFIGS.forEach((tabConfig) => {
        const tabItem = this.createTabItem(tabConfig);
        tabList.appendChild(tabItem);
      });
      nav.appendChild(tabList);
      return nav;
    }
    /**
     * Create individual tab item
     */
    createTabItem(config) {
      const listItem = createSafeElement("li", "", "tab-item");
      const button = document.createElement("button");
      button.className = `tab-button ${this.state.currentTab === config.id ? "tab-button--active" : ""}`;
      button.setAttribute("data-tab", config.id);
      button.setAttribute("aria-label", config.description);
      const icon = createSafeElement("span", config.icon, "tab-icon");
      const label = createSafeElement("span", config.label, "tab-label");
      button.appendChild(icon);
      button.appendChild(label);
      button.addEventListener("click", () => {
        this.switchTab(config.id);
      });
      button.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          this.switchTab(config.id);
        }
      });
      listItem.appendChild(button);
      return listItem;
    }
    /**
     * Create tab content container
     */
    createTabContent() {
      return createSafeElement("div", "", "tab-content");
    }
    /**
     * Create status bar
     */
    createStatusBar() {
      return createSafeElement("div", "", "status-bar");
    }
    // ============================================================================
    // Tab Management
    // ============================================================================
    /**
     * Switch to a different tab
     */
    async switchTab(tabName) {
      try {
        this.state.currentTab = tabName;
        this.updateTabNavigation();
        await this.loadTabContent(tabName);
      } catch (error) {
        this.showError(`Failed to switch to ${tabName} tab: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Update tab navigation visual state
     */
    updateTabNavigation() {
      if (!this.tabNavigation) return;
      const buttons = this.tabNavigation.querySelectorAll(".tab-button");
      buttons.forEach((button) => {
        const isActive = button.getAttribute("data-tab") === this.state.currentTab;
        button.classList.toggle("tab-button--active", isActive);
        button.setAttribute("aria-selected", isActive.toString());
      });
    }
    /**
     * Load content for the current tab
     */
    async loadTabContent(tabName) {
      if (!this.tabContent) return;
      this.tabContent.innerHTML = "";
      switch (tabName) {
        case "application":
          await this.loadApplicationTab();
          break;
        case "experience":
          this.loadExperienceTab();
          break;
        case "settings":
          await this.loadSettingsTab();
          break;
        default:
          throw new Error(`Unknown tab: ${tabName}`);
      }
    }
    /**
     * Load New Application tab content
     */
    async loadApplicationTab() {
      if (!this.tabContent) return;
      try {
        if (!this.applicationTab) {
          this.applicationTab = new ApplicationTab(this.tabContent);
        }
        this.applicationTab.render();
      } catch (error) {
        this.showError(`Failed to load application tab: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Load Experience tab content (placeholder)
     */
    /**
     * Load Experience tab content (FIXED VERSION)
     * Replace the existing loadExperienceTab() method in app.ts with this
     */
    async loadExperienceTab() {
      if (!this.tabContent) return;
      console.log("Loading Experience tab...");
      try {
        this.tabContent.innerHTML = "";
        const { ExperienceTab: ExperienceTab2 } = await Promise.resolve().then(() => (init_experience_tab(), experience_tab_exports));
        console.log("ExperienceTab imported successfully");
        console.log("Creating ExperienceTab instance...");
        const experienceTab = new ExperienceTab2(this.tabContent);
        console.log("Rendering ExperienceTab...");
        await experienceTab.render();
        console.log("ExperienceTab rendered successfully");
      } catch (error) {
        console.error("Experience tab error:", error);
        if (this.tabContent) {
          this.tabContent.innerHTML = `
          <div style="color: red; padding: 1rem; border: 1px solid #ff0000; border-radius: 4px; margin: 1rem;">
            <h3>Experience Tab Error</h3>
            <p>Failed to load Experience tab: ${error instanceof Error ? error.message : "Unknown error"}</p>
            <details>
              <summary>Click for Error Details</summary>
              <pre style="background: #f5f5f5; padding: 1rem; margin-top: 0.5rem; overflow: auto;">${error instanceof Error ? error.stack : JSON.stringify(error, null, 2)}</pre>
            </details>
            <br>
            <button onclick="location.reload()" style="padding: 0.5rem 1rem; background: #007cba; color: white; border: none; border-radius: 4px; cursor: pointer;">
              Reload Page
            </button>
          </div>
        `;
        }
      }
    }
    /**
     * Load Settings tab content
     */
    async loadSettingsTab() {
      if (!this.tabContent) return;
      try {
        if (!this.settingsTab) {
          this.settingsTab = new SettingsTab(this.tabContent);
        }
        await this.settingsTab.render();
      } catch (error) {
        this.showError(`Failed to load settings tab: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    // ============================================================================
    // State Management
    // ============================================================================
    /**
     * Show loading state
     */
    showLoading(message) {
      this.state.loading = true;
      this.state.error = void 0;
      this.state.success = void 0;
      this.updateStatusBar(message, "loading");
    }
    /**
     * Hide loading state
     */
    hideLoading() {
      this.state.loading = false;
      this.updateStatusBar("", "hidden");
    }
    /**
     * Show error message
     */
    showError(message) {
      this.state.loading = false;
      this.state.error = message;
      this.state.success = void 0;
      this.updateStatusBar(message, "error");
    }
    /**
     * Show success message
     */
    showSuccess(message) {
      this.state.loading = false;
      this.state.error = void 0;
      this.state.success = message;
      this.updateStatusBar(message, "success");
      setTimeout(() => {
        if (this.state.success === message) {
          this.hideLoading();
        }
      }, 3e3);
    }
    /**
     * Update status bar
     */
    updateStatusBar(message, type) {
      if (!this.statusBar) return;
      this.statusBar.innerHTML = "";
      this.statusBar.className = `status-bar status-bar--${type}`;
      if (type !== "hidden" && message) {
        let element;
        switch (type) {
          case "loading":
            element = createSafeElement("div", `\u23F3 ${message}`, "status-message");
            break;
          case "error":
            element = createErrorElement(message);
            break;
          case "success":
            element = createSuccessElement(`\u2713 ${message}`);
            break;
          default:
            element = createSafeElement("div", message, "status-message");
        }
        this.statusBar.appendChild(element);
      }
    }
    // ============================================================================
    // Public API
    // ============================================================================
    /**
     * Get current application state
     */
    getState() {
      return { ...this.state };
    }
    /**
     * Navigate to specific tab programmatically
     */
    async navigateToTab(tabName) {
      await this.switchTab(tabName);
    }
  };

  // src/main.ts
  console.log("Main.ts loaded - initializing app...");
  var loadingDiv = document.getElementById("loading");
  if (loadingDiv) {
    loadingDiv.remove();
  }
  try {
    const app = new ResuumApp("app");
    app.initialize();
    console.log("ResuumApp initialized successfully");
  } catch (error) {
    console.error("App initialization failed:", error);
    const container = document.getElementById("app");
    if (container) {
      container.innerHTML = `<div style="color: red; padding: 1rem;">
      App failed to load: ${error instanceof Error ? error.message : "Unknown error"}
      <br><br>
      Check browser console for details.
    </div>`;
    }
  }
})();

    </script>
</body>
</html>