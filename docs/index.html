<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resuum - AI-Powered Resume Optimization</title>
    <style>
        /* Main Layout - Two Column */
        body { 
            font-family: system-ui, sans-serif; 
            margin: 0; 
            padding: 0; 
            background: #f5f5f5; 
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            padding: 1rem 0;
            background: white;
            border-bottom: 1px solid #e5e7eb;
        }
        .header h1 {
            color: #1e293b;
            font-size: 2.5rem;
            margin: 0 0 0.5rem 0;
        }
        .header p {
            color: #64748b;
            font-size: 1.1rem;
            margin: 0;
        }

        .main-container {
            flex: 1;
            display: flex;
            min-height: 0;
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 240px;
            background: white;
            border-right: 1px solid #e5e7eb;
            flex-shrink: 0;
            padding: 1rem;
        }

        .tab-navigation {
            width: 100%;
        }
        .tab-list {
            display: flex;
            flex-direction: column;
            list-style: none;
            margin: 0;
            padding: 0;
            gap: 4px;
        }
        .tab-item {
            width: 100%;
        }
        .tab-button {
            width: 100%;
            padding: 12px 16px;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 15px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
            text-align: left;
            color: #374151;
        }
        .tab-button:hover {
            background-color: #f3f4f6;
        }
        .tab-button--active {
            background-color: #e0f2fe;
            color: #0369a1;
            font-weight: 600;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 2rem;
        }

        .tab-content {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            flex: 1;
            overflow: auto;
        }
        
        /* Experience Tab Styles */
        .experience-header {
            margin-bottom: 2rem;
        }
        .section-title {
            color: #1e293b;
            margin-bottom: 1rem;
        }
        .embedding-summary {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1.5rem;
        }
        .summary-text {
            margin: 0;
            font-weight: 500;
        }
        .state-badges {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }
        .summary-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
        }
        .summary-badge--ready { background: #dcfce7; color: #166534; }
        .summary-badge--pending { background: #fef3c7; color: #92400e; }
        .summary-badge--stale { background: #fed7aa; color: #9a3412; }
        .summary-badge--failed { background: #fecaca; color: #991b1b; }
        
        /* Sub Navigation */
        .experience-sub-nav {
            margin-bottom: 1.5rem;
        }
        .sub-nav-list {
            display: flex;
            list-style: none;
            margin: 0;
            padding: 0;
            gap: 0.5rem;
        }
        .sub-nav-button {
            padding: 0.5rem 1rem;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sub-nav-button--active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        /* Table Styles */
        .table-controls {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .sort-select {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
        }
        .bullets-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        .bullets-table th,
        .bullets-table td {
            padding: 0.75rem;
            text-align: left;
            border: 1px solid #e5e7eb;
            vertical-align: top;
        }
        .bullets-table th {
            background: #f9fafb;
            font-weight: 600;
        }
        .bullets-table tr:nth-child(even) {
            background: #f9fafb;
        }
        
        /* State Badges */
        .state-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
            white-space: nowrap;
        }
        .state-badge--ready { background: #dcfce7; color: #166534; }
        .state-badge--pending { background: #fef3c7; color: #92400e; }
        .state-badge--stale { background: #fed7aa; color: #9a3412; }
        .state-badge--failed { background: #fecaca; color: #991b1b; }
        
        /* Quality Indicators */
        .quality-indicators {
            display: flex;
            gap: 0.25rem;
        }
        .quality-indicator {
            font-size: 1.2em;
        }
        .quality-indicator.active {
            opacity: 1;
        }
        .quality-indicator.inactive {
            opacity: 0.3;
        }
        
        /* Status Bar */
        .status-bar {
            margin-top: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
        }
        .status-bar--loading {
            background: #fef3c7;
            color: #92400e;
        }
        .status-bar--error {
            background: #fecaca;
            color: #991b1b;
        }
        .status-bar--success {
            background: #dcfce7;
            color: #166534;
        }
        .status-bar--hidden {
            display: none;
        }
        
        /* Form Styles */
        .form-group {
            margin-bottom: 1rem;
        }
        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        .form-input,
        .form-textarea,
        .form-select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-family: inherit;
        }
        .form-textarea {
            resize: vertical;
        }
        .form-submit {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
        }
        .form-submit:hover {
            background: #2563eb;
        }
        .form-submit:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        
        /* Utility Classes */
        .hidden { display: none; }
        .error { 
            background: #fecaca; 
            border: 1px solid #f87171; 
            padding: 1rem; 
            border-radius: 4px; 
            color: #991b1b; 
            margin: 1rem 0;
        }
        .success {
            background: #dcfce7;
            border: 1px solid #4ade80;
            padding: 1rem;
            border-radius: 4px;
            color: #166534;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>Resuum</h1>
        <p>AI-Powered Resume Optimization</p>
    </header>
    
    <div class="main-container">
        <div class="sidebar">
            <div id="sidebar-nav"></div>
        </div>
        
        <div class="main-content">
            <main id="app">
                <div id="loading">Loading application...</div>
            </main>
        </div>
    </div>

    <script>
        "use strict";
var Resuum = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // src/ui/xss-safe-rendering.ts
  function createSafeTextNode(text) {
    return document.createTextNode(text || "");
  }
  function setSafeTextContent(element, text) {
    element.textContent = "";
    element.appendChild(createSafeTextNode(text));
  }
  function createSafeElement(tagName, textContent, className) {
    const element = document.createElement(tagName);
    if (className) {
      element.className = className;
    }
    if (textContent) {
      setSafeTextContent(element, textContent);
    }
    return element;
  }
  function renderBulletPoint(bulletText, embeddingState) {
    const container = createSafeElement("div", "", "bullet-point-container");
    const textElement = createSafeElement("span", bulletText, "bullet-text");
    const stateElement = createSafeElement("span", "", `embedding-state embedding-state--${embeddingState}`);
    setSafeTextContent(stateElement, getEmbeddingStateLabel(embeddingState));
    container.appendChild(textElement);
    container.appendChild(stateElement);
    return container;
  }
  function getEmbeddingStateLabel(state) {
    switch (state) {
      case "ready":
        return "\u2713";
      case "pending":
        return "\u23F3";
      case "stale":
        return "\u26A0";
      case "failed":
        return "\u2717";
      default:
        return "?";
    }
  }
  function createErrorElement(message, title) {
    const container = createSafeElement("div", "", "error-message");
    if (title) {
      const titleElement = createSafeElement("h3", title, "error-title");
      container.appendChild(titleElement);
    }
    const messageElement = createSafeElement("p", message, "error-text");
    container.appendChild(messageElement);
    return container;
  }
  function createSuccessElement(message) {
    return createSafeElement("div", message, "success-message");
  }
  var init_xss_safe_rendering = __esm({
    "src/ui/xss-safe-rendering.ts"() {
      "use strict";
    }
  });

  // src/utils/feature-detection.ts
  function detectIndexedDB() {
    try {
      if (!("indexedDB" in window)) {
        return false;
      }
      if (!window.indexedDB) {
        return false;
      }
      if (typeof window.indexedDB.open !== "function") {
        return false;
      }
      return true;
    } catch (error) {
      return false;
    }
  }
  function detectWebWorkers() {
    try {
      return "Worker" in window && typeof Worker === "function";
    } catch (error) {
      return false;
    }
  }
  function detectBlobWorkers() {
    try {
      if (!detectWebWorkers()) {
        return false;
      }
      if (!("Blob" in window) || !("URL" in window) || typeof URL.createObjectURL !== "function") {
        return false;
      }
      const testBlob = new Blob([""], { type: "application/javascript" });
      const url = URL.createObjectURL(testBlob);
      URL.revokeObjectURL(url);
      return true;
    } catch (error) {
      return false;
    }
  }
  function detectClipboardAPI() {
    try {
      return "navigator" in window && "clipboard" in navigator && typeof navigator.clipboard.writeText === "function";
    } catch (error) {
      return false;
    }
  }
  function detectFetch() {
    try {
      return "fetch" in window && typeof fetch === "function";
    } catch (error) {
      return false;
    }
  }
  function detectArrayBuffer() {
    try {
      return "ArrayBuffer" in window && "Float32Array" in window && typeof ArrayBuffer === "function" && typeof Float32Array === "function";
    } catch (error) {
      return false;
    }
  }
  function detectTextEncoder() {
    try {
      return "TextEncoder" in window && "TextDecoder" in window && typeof TextEncoder === "function";
    } catch (error) {
      return false;
    }
  }
  function detectCrypto() {
    try {
      return "crypto" in window && window.crypto && "getRandomValues" in window.crypto && typeof window.crypto.getRandomValues === "function";
    } catch (error) {
      return false;
    }
  }
  function detectBrowserCapabilities() {
    return {
      indexedDB: detectIndexedDB(),
      webWorkers: detectWebWorkers(),
      blobWorkers: detectBlobWorkers(),
      clipboardAPI: detectClipboardAPI(),
      fetch: detectFetch(),
      arrayBuffer: detectArrayBuffer(),
      textEncoder: detectTextEncoder(),
      crypto: detectCrypto()
    };
  }
  var init_feature_detection = __esm({
    "src/utils/feature-detection.ts"() {
      "use strict";
    }
  });

  // src/storage/schema.ts
  function validateStoreConfig(store) {
    if (!store.name || !store.keyPath) {
      return false;
    }
    if (store.indexes) {
      for (const index of store.indexes) {
        if (!index.name || !index.keyPath) {
          return false;
        }
      }
    }
    return true;
  }
  var DB_NAME, DB_VERSION, DATABASE_SCHEMA, EMBEDDING_STATES, EMBEDDING_RETRY_LIMITS, QUEUE_PRIORITIES;
  var init_schema = __esm({
    "src/storage/schema.ts"() {
      "use strict";
      DB_NAME = "ResuumDB";
      DB_VERSION = 1;
      DATABASE_SCHEMA = {
        name: DB_NAME,
        version: DB_VERSION,
        stores: [
          {
            name: "roles",
            keyPath: "id",
            indexes: [
              { name: "orderIndex", keyPath: "orderIndex" },
              { name: "company", keyPath: "company" }
            ]
          },
          {
            name: "projects",
            keyPath: "id",
            indexes: [
              { name: "roleId", keyPath: "roleId" },
              { name: "name", keyPath: "name" },
              { name: "bulletCount", keyPath: "bulletCount" },
              { name: "embeddingVersion", keyPath: "embeddingVersion" },
              { name: "role_bulletCount", keyPath: ["roleId", "bulletCount"] }
            ]
          },
          {
            name: "bullets",
            keyPath: "id",
            indexes: [
              { name: "roleId", keyPath: "roleId" },
              { name: "projectId", keyPath: "projectId" },
              { name: "normalizedFingerprint", keyPath: "normalizedFingerprint" },
              { name: "embeddingState", keyPath: "embeddingState" },
              { name: "createdAt", keyPath: "createdAt" },
              { name: "lastModified", keyPath: "lastModified" },
              { name: "role_project", keyPath: ["roleId", "projectId"] },
              { name: "role_state", keyPath: ["roleId", "embeddingState"] },
              { name: "project_state", keyPath: ["projectId", "embeddingState"] },
              { name: "fingerprint_role", keyPath: ["normalizedFingerprint", "roleId"] }
            ]
          },
          {
            name: "embeddings",
            keyPath: "bulletId",
            indexes: [
              { name: "vendor", keyPath: "vendor" },
              { name: "model", keyPath: "model" },
              { name: "version", keyPath: "version" },
              { name: "createdAt", keyPath: "createdAt" },
              { name: "vendor_model_version", keyPath: ["vendor", "model", "version"] }
            ]
          },
          {
            name: "embedQueue",
            keyPath: "id",
            indexes: [
              { name: "bulletId", keyPath: "bulletId", options: { unique: true } },
              { name: "priority", keyPath: "priority" },
              { name: "createdAt", keyPath: "createdAt" },
              { name: "retryCount", keyPath: "retryCount" },
              { name: "priority_created", keyPath: ["priority", "createdAt"] }
            ]
          },
          {
            name: "settings",
            keyPath: "key",
            indexes: []
          }
        ]
      };
      EMBEDDING_STATES = {
        READY: "ready",
        PENDING: "pending",
        STALE: "stale",
        FAILED: "failed"
      };
      EMBEDDING_RETRY_LIMITS = {
        MAX_RETRIES: 3,
        BACKOFF_BASE: 1e3,
        // 1 second
        BACKOFF_MULTIPLIER: 2
      };
      QUEUE_PRIORITIES = {
        HIGH: 1,
        // New bullets, user-initiated
        NORMAL: 5,
        // Batch operations
        LOW: 10
        // Background processing
      };
    }
  });

  // src/utils/uuid.ts
  function generateUUID() {
    if (typeof crypto !== "undefined" && crypto.getRandomValues) {
      const bytes = new Uint8Array(16);
      crypto.getRandomValues(bytes);
      if (bytes.length < 16) {
        throw new Error("Failed to generate sufficient random bytes");
      }
      bytes[6] = (bytes[6] ?? 0) & 15 | 64;
      bytes[8] = (bytes[8] ?? 0) & 63 | 128;
      const hex = Array.from(bytes).map((b) => (b ?? 0).toString(16).padStart(2, "0")).join("");
      return [
        hex.slice(0, 8),
        hex.slice(8, 12),
        hex.slice(12, 16),
        hex.slice(16, 20),
        hex.slice(20, 32)
      ].join("-");
    } else {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
  }
  function generateULID() {
    const timestamp = Date.now();
    const timestampPart = timestamp.toString(36).padStart(10, "0");
    const randomPart = generateRandomString(16);
    return `${timestampPart}_${randomPart}`;
  }
  function generateRandomString(length) {
    const chars = "0123456789abcdefghijklmnopqrstuvwxyz";
    let result = "";
    if (typeof crypto !== "undefined" && crypto.getRandomValues) {
      const bytes = new Uint8Array(length);
      crypto.getRandomValues(bytes);
      for (let i = 0; i < Math.min(bytes.length, length); i++) {
        const byteValue = bytes[i] ?? 0;
        result += chars[byteValue % chars.length] ?? "0";
      }
    } else {
      for (let i = 0; i < length; i++) {
        result += chars[Math.floor(Math.random() * chars.length)] ?? "0";
      }
    }
    return result;
  }
  function createId(type = "bullet") {
    if (type === "bullet" || type === "embed_queue") {
      return generateULID();
    }
    return generateUUID();
  }
  var init_uuid = __esm({
    "src/utils/uuid.ts"() {
      "use strict";
    }
  });

  // src/storage/database.ts
  async function getDatabase() {
    if (!globalConnection) {
      globalConnection = new DatabaseConnection();
    }
    return globalConnection.open();
  }
  var DatabaseConnection, globalConnection;
  var init_database = __esm({
    "src/storage/database.ts"() {
      "use strict";
      init_feature_detection();
      init_schema();
      init_uuid();
      DatabaseConnection = class {
        db = null;
        openPromise = null;
        constructor() {
          const capabilities = detectBrowserCapabilities();
          if (!capabilities.indexedDB) {
            throw new Error("IndexedDB is not supported in this browser. Please use Chrome 91+, Firefox 90+, Safari 14+, or Edge 91+.");
          }
        }
        /**
         * Open database connection with schema migration
         */
        async open() {
          if (this.db && !this.db.version) {
            this.db = null;
            this.openPromise = null;
          }
          if (this.db) {
            return this.db;
          }
          if (this.openPromise) {
            return this.openPromise;
          }
          this.openPromise = this.performOpen();
          return this.openPromise;
        }
        async performOpen() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = () => {
              const error = request.error;
              console.error("Failed to open database:", error);
              reject(new Error(`Database connection failed: ${error?.message || "Unknown error"}`));
            };
            request.onsuccess = () => {
              this.db = request.result;
              this.db.onclose = () => {
                console.warn("Database connection closed unexpectedly");
                this.db = null;
                this.openPromise = null;
              };
              this.db.onversionchange = () => {
                console.warn("Database version changed by another tab");
                this.db?.close();
                this.db = null;
                this.openPromise = null;
              };
              resolve(this.db);
            };
            request.onupgradeneeded = (event) => {
              const db = request.result;
              const transaction = request.transaction;
              if (!transaction) {
                reject(new Error("No transaction available during upgrade"));
                return;
              }
              try {
                this.performMigration(db, event.oldVersion, event.newVersion || DB_VERSION);
              } catch (error) {
                console.error("Migration failed:", error);
                reject(error);
              }
            };
            request.onblocked = () => {
              console.warn("Database upgrade blocked by another tab");
              reject(new Error("Database upgrade blocked. Please close other tabs and try again."));
            };
          });
        }
        /**
         * Perform database schema migration
         */
        performMigration(db, oldVersion, newVersion) {
          console.log(`Migrating database from version ${oldVersion} to ${newVersion}`);
          if (oldVersion < 1) {
            this.createInitialSchema(db);
          }
        }
        /**
         * Create initial database schema
         */
        createInitialSchema(db) {
          for (const storeConfig of DATABASE_SCHEMA.stores) {
            if (!validateStoreConfig(storeConfig)) {
              throw new Error(`Invalid store configuration: ${storeConfig.name}`);
            }
            const store = db.createObjectStore(storeConfig.name, {
              keyPath: storeConfig.keyPath
            });
            if (storeConfig.indexes) {
              for (const indexConfig of storeConfig.indexes) {
                store.createIndex(
                  indexConfig.name,
                  indexConfig.keyPath,
                  indexConfig.options || {}
                );
              }
            }
          }
          console.log("Initial database schema created successfully");
        }
        /**
         * Close database connection
         */
        close() {
          if (this.db) {
            this.db.close();
            this.db = null;
            this.openPromise = null;
          }
        }
        /**
         * Get current database instance
         */
        getDatabase() {
          return this.db;
        }
        /**
         * Check if database is ready
         */
        isReady() {
          return this.db !== null;
        }
      };
      globalConnection = null;
    }
  });

  // src/storage/transactions.ts
  async function executeTransaction(storeNames, mode, operation) {
    const db = await getDatabase();
    const transaction = db.transaction(storeNames, mode);
    const stores = {};
    for (const storeName of storeNames) {
      stores[storeName] = transaction.objectStore(storeName);
    }
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error("Transaction timeout after 30 seconds"));
      }, 3e4);
    });
    const operationPromise = operation(transaction, stores);
    const completionPromise = new Promise((resolve, reject) => {
      transaction.oncomplete = () => {
        operationPromise.then(resolve).catch(reject);
      };
      transaction.onerror = () => {
        reject(new Error(`Transaction failed: ${transaction.error?.message || "Unknown error"}`));
      };
      transaction.onabort = () => {
        reject(new Error("Transaction was aborted"));
      };
    });
    return Promise.race([completionPromise, timeoutPromise]);
  }
  async function getById(storeName, id) {
    return executeTransaction([storeName], "readonly", async (_, stores) => {
      return new Promise((resolve, reject) => {
        const request = stores[storeName].get(id);
        request.onsuccess = () => {
          resolve(request.result || null);
        };
        request.onerror = () => {
          reject(new Error(`Failed to get ${storeName} by ID: ${request.error?.message}`));
        };
      });
    });
  }
  async function getAll(storeName) {
    return executeTransaction([storeName], "readonly", async (_, stores) => {
      return new Promise((resolve, reject) => {
        const request = stores[storeName].getAll();
        request.onsuccess = () => {
          resolve(request.result || []);
        };
        request.onerror = () => {
          reject(new Error(`Failed to get all ${storeName}: ${request.error?.message}`));
        };
      });
    });
  }
  async function create(storeName, data) {
    return executeTransaction([storeName], "readwrite", async (_, stores) => {
      return new Promise((resolve, reject) => {
        const request = stores[storeName].add(data);
        request.onsuccess = () => {
          resolve(data);
        };
        request.onerror = () => {
          reject(new Error(`Failed to create ${storeName}: ${request.error?.message}`));
        };
      });
    });
  }
  async function update(storeName, data) {
    return executeTransaction([storeName], "readwrite", async (_, stores) => {
      return new Promise((resolve, reject) => {
        const request = stores[storeName].put(data);
        request.onsuccess = () => {
          resolve(data);
        };
        request.onerror = () => {
          reject(new Error(`Failed to update ${storeName}: ${request.error?.message}`));
        };
      });
    });
  }
  async function deleteById(storeName, id) {
    return executeTransaction([storeName], "readwrite", async (_, stores) => {
      return new Promise((resolve, reject) => {
        const request = stores[storeName].delete(id);
        request.onsuccess = () => {
          resolve();
        };
        request.onerror = () => {
          reject(new Error(`Failed to delete ${storeName}: ${request.error?.message}`));
        };
      });
    });
  }
  async function getBulletsByState(state) {
    return executeTransaction(["bullets"], "readonly", async (_, stores) => {
      return new Promise((resolve, reject) => {
        const index = stores.bullets.index("embeddingState");
        const request = index.getAll(state);
        request.onsuccess = () => {
          resolve(request.result || []);
        };
        request.onerror = () => {
          reject(new Error(`Failed to get bullets by state: ${request.error?.message}`));
        };
      });
    });
  }
  var init_transactions = __esm({
    "src/storage/transactions.ts"() {
      "use strict";
      init_database();
    }
  });

  // src/storage/embedding-state.ts
  function getEmbeddingStateMachine() {
    if (!globalStateMachine) {
      globalStateMachine = new EmbeddingStateMachine();
    }
    return globalStateMachine;
  }
  async function markBulletChanged(bulletId) {
    const stateMachine = getEmbeddingStateMachine();
    await stateMachine.transitionToStale(bulletId);
  }
  async function queueBulletForEmbedding(bulletId) {
    const stateMachine = getEmbeddingStateMachine();
    await stateMachine.transitionToPending(bulletId, QUEUE_PRIORITIES.HIGH);
  }
  var EmbeddingStateMachine, globalStateMachine;
  var init_embedding_state = __esm({
    "src/storage/embedding-state.ts"() {
      "use strict";
      init_transactions();
      init_schema();
      init_uuid();
      EmbeddingStateMachine = class {
        /**
         * Transition bullet to pending state and add to queue
         */
        async transitionToPending(bulletId, priority = QUEUE_PRIORITIES.NORMAL) {
          await executeTransaction(["bullets", "embedQueue"], "readwrite", async (_, stores) => {
            const bulletRequest = stores.bullets.get(bulletId);
            const bullet = await new Promise((resolve, reject) => {
              bulletRequest.onsuccess = () => {
                if (bulletRequest.result) {
                  resolve(bulletRequest.result);
                } else {
                  reject(new Error(`Bullet not found: ${bulletId}`));
                }
              };
              bulletRequest.onerror = () => reject(bulletRequest.error);
            });
            const updatedBullet = {
              ...bullet,
              embeddingState: EMBEDDING_STATES.PENDING,
              lastModified: Date.now()
            };
            await new Promise((resolve, reject) => {
              const updateRequest = stores.bullets.put(updatedBullet);
              updateRequest.onsuccess = () => resolve();
              updateRequest.onerror = () => reject(updateRequest.error);
            });
            const queueIndex = stores.embedQueue.index("bulletId");
            const existingRequest = queueIndex.get(bulletId);
            await new Promise((resolve, reject) => {
              existingRequest.onsuccess = () => {
                if (!existingRequest.result) {
                  const queueItem = {
                    id: createId("embed_queue"),
                    bulletId,
                    priority,
                    createdAt: Date.now(),
                    retryCount: 0
                  };
                  const addRequest = stores.embedQueue.add(queueItem);
                  addRequest.onsuccess = () => resolve();
                  addRequest.onerror = () => reject(addRequest.error);
                } else {
                  resolve();
                }
              };
              existingRequest.onerror = () => reject(existingRequest.error);
            });
          });
        }
        /**
         * Transition bullet to ready state and remove from queue
         */
        async transitionToReady(bulletId) {
          await executeTransaction(["bullets", "embedQueue"], "readwrite", async (_, stores) => {
            const bulletRequest = stores.bullets.get(bulletId);
            const bullet = await new Promise((resolve, reject) => {
              bulletRequest.onsuccess = () => {
                if (bulletRequest.result) {
                  resolve(bulletRequest.result);
                } else {
                  reject(new Error(`Bullet not found: ${bulletId}`));
                }
              };
              bulletRequest.onerror = () => reject(bulletRequest.error);
            });
            const updatedBullet = {
              ...bullet,
              embeddingState: EMBEDDING_STATES.READY,
              lastEmbeddedAt: Date.now(),
              retryCount: 0,
              lastModified: Date.now()
            };
            await new Promise((resolve, reject) => {
              const updateRequest = stores.bullets.put(updatedBullet);
              updateRequest.onsuccess = () => resolve();
              updateRequest.onerror = () => reject(updateRequest.error);
            });
            const queueIndex = stores.embedQueue.index("bulletId");
            const queueRequest = queueIndex.get(bulletId);
            await new Promise((resolve, reject) => {
              queueRequest.onsuccess = () => {
                if (queueRequest.result) {
                  const deleteRequest = stores.embedQueue.delete(queueRequest.result.id);
                  deleteRequest.onsuccess = () => resolve();
                  deleteRequest.onerror = () => reject(deleteRequest.error);
                } else {
                  resolve();
                }
              };
              queueRequest.onerror = () => reject(queueRequest.error);
            });
          });
        }
        /**
         * Transition bullet to stale state (when text changes)
         */
        async transitionToStale(bulletId) {
          const bullet = await getById("bullets", bulletId);
          if (!bullet) {
            throw new Error(`Bullet not found: ${bulletId}`);
          }
          const updatedBullet = {
            ...bullet,
            embeddingState: EMBEDDING_STATES.STALE,
            lastModified: Date.now()
          };
          await update("bullets", updatedBullet);
        }
        /**
         * Transition bullet to failed state with retry logic
         */
        async transitionToFailed(bulletId) {
          await executeTransaction(["bullets", "embedQueue"], "readwrite", async (_, stores) => {
            const bulletRequest = stores.bullets.get(bulletId);
            const bullet = await new Promise((resolve, reject) => {
              bulletRequest.onsuccess = () => {
                if (bulletRequest.result) {
                  resolve(bulletRequest.result);
                } else {
                  reject(new Error(`Bullet not found: ${bulletId}`));
                }
              };
              bulletRequest.onerror = () => reject(bulletRequest.error);
            });
            const retryCount = bullet.retryCount + 1;
            const shouldRetry = retryCount <= EMBEDDING_RETRY_LIMITS.MAX_RETRIES;
            if (shouldRetry) {
              const updatedBullet = {
                ...bullet,
                embeddingState: EMBEDDING_STATES.PENDING,
                retryCount,
                lastModified: Date.now()
              };
              await new Promise((resolve, reject) => {
                const updateRequest = stores.bullets.put(updatedBullet);
                updateRequest.onsuccess = () => resolve();
                updateRequest.onerror = () => reject(updateRequest.error);
              });
              const queueIndex = stores.embedQueue.index("bulletId");
              const queueRequest = queueIndex.get(bulletId);
              await new Promise((resolve, reject) => {
                queueRequest.onsuccess = () => {
                  if (queueRequest.result) {
                    const delayMs = EMBEDDING_RETRY_LIMITS.BACKOFF_BASE * Math.pow(EMBEDDING_RETRY_LIMITS.BACKOFF_MULTIPLIER, retryCount - 1);
                    const updatedQueueItem = {
                      ...queueRequest.result,
                      retryCount,
                      createdAt: Date.now() + delayMs
                      // Delay retry
                    };
                    const updateRequest = stores.embedQueue.put(updatedQueueItem);
                    updateRequest.onsuccess = () => resolve();
                    updateRequest.onerror = () => reject(updateRequest.error);
                  } else {
                    resolve();
                  }
                };
                queueRequest.onerror = () => reject(queueRequest.error);
              });
            } else {
              const updatedBullet = {
                ...bullet,
                embeddingState: EMBEDDING_STATES.FAILED,
                retryCount,
                lastModified: Date.now()
              };
              await new Promise((resolve, reject) => {
                const updateRequest = stores.bullets.put(updatedBullet);
                updateRequest.onsuccess = () => resolve();
                updateRequest.onerror = () => reject(updateRequest.error);
              });
              const queueIndex = stores.embedQueue.index("bulletId");
              const queueRequest = queueIndex.get(bulletId);
              await new Promise((resolve, reject) => {
                queueRequest.onsuccess = () => {
                  if (queueRequest.result) {
                    const deleteRequest = stores.embedQueue.delete(queueRequest.result.id);
                    deleteRequest.onsuccess = () => resolve();
                    deleteRequest.onerror = () => reject(deleteRequest.error);
                  } else {
                    resolve();
                  }
                };
                queueRequest.onerror = () => reject(queueRequest.error);
              });
            }
          });
        }
        /**
         * Get bullets by state with pagination
         */
        async getBulletsByState(state, limit, offset) {
          const bullets = await getBulletsByState(state);
          if (limit !== void 0) {
            const start = offset || 0;
            return bullets.slice(start, start + limit);
          }
          return bullets;
        }
        /**
         * Get embedding queue with priority ordering
         */
        async getQueue(limit) {
          return executeTransaction(["embedQueue"], "readonly", async (_, stores) => {
            return new Promise((resolve, reject) => {
              const index = stores.embedQueue.index("priority_created");
              const request = limit ? index.getAll(null, limit) : index.getAll();
              request.onsuccess = () => {
                const items = request.result || [];
                const now = Date.now();
                const readyItems = items.filter((item) => item.createdAt <= now);
                readyItems.sort((a, b) => {
                  if (a.priority !== b.priority) {
                    return a.priority - b.priority;
                  }
                  return a.createdAt - b.createdAt;
                });
                resolve(limit ? readyItems.slice(0, limit) : readyItems);
              };
              request.onerror = () => {
                reject(new Error(`Failed to get queue: ${request.error?.message}`));
              };
            });
          });
        }
        /**
         * Peek at next queue item without removing it
         */
        async peekQueue() {
          const items = await this.getQueue(1);
          return items.length > 0 ? items[0] || null : null;
        }
        /**
         * Remove item from queue (for processing)
         */
        async dequeue(queueItemId) {
          await deleteById("embedQueue", queueItemId);
        }
        /**
         * Get queue statistics
         */
        async getQueueStats() {
          const items = await this.getQueue();
          const oldestItem = items.length > 0 ? Math.min(...items.map((i) => i.createdAt)) : void 0;
          const stats = {
            total: items.length,
            byPriority: {},
            oldestItem,
            avgRetryCount: items.length > 0 ? items.reduce((sum, i) => sum + i.retryCount, 0) / items.length : 0
          };
          for (const item of items) {
            stats.byPriority[item.priority] = (stats.byPriority[item.priority] || 0) + 1;
          }
          return stats;
        }
        /**
         * Clear failed items from queue (cleanup)
         */
        async clearFailedQueue() {
          return executeTransaction(["embedQueue", "bullets"], "readwrite", async (_, stores) => {
            let clearedCount = 0;
            const queueRequest = stores.embedQueue.getAll();
            const queueItems = await new Promise((resolve, reject) => {
              queueRequest.onsuccess = () => resolve(queueRequest.result || []);
              queueRequest.onerror = () => reject(queueRequest.error);
            });
            for (const queueItem of queueItems) {
              const bulletRequest = stores.bullets.get(queueItem.bulletId);
              const bullet = await new Promise((resolve, reject) => {
                bulletRequest.onsuccess = () => resolve(bulletRequest.result || null);
                bulletRequest.onerror = () => reject(bulletRequest.error);
              });
              if (!bullet || bullet.embeddingState === EMBEDDING_STATES.FAILED) {
                await new Promise((resolve, reject) => {
                  const deleteRequest = stores.embedQueue.delete(queueItem.id);
                  deleteRequest.onsuccess = () => {
                    clearedCount++;
                    resolve();
                  };
                  deleteRequest.onerror = () => reject(deleteRequest.error);
                });
              }
            }
            return clearedCount;
          });
        }
        /**
         * Reset all stale bullets to pending (for reprocessing)
         */
        async requeueStale(priority = QUEUE_PRIORITIES.LOW) {
          const staleBullets = await this.getBulletsByState(EMBEDDING_STATES.STALE);
          for (const bullet of staleBullets) {
            await this.transitionToPending(bullet.id, priority);
          }
          return staleBullets.length;
        }
        /**
         * Coalesce duplicate queue entries (cleanup)
         */
        async coalesceQueue() {
          return executeTransaction(["embedQueue"], "readwrite", async (_, stores) => {
            const seenBullets = /* @__PURE__ */ new Set();
            let removedCount = 0;
            const index = stores.embedQueue.index("priority_created");
            const cursor = index.openCursor();
            await new Promise((resolve, reject) => {
              cursor.onsuccess = () => {
                const cursorResult = cursor.result;
                if (cursorResult) {
                  const queueItem = cursorResult.value;
                  if (seenBullets.has(queueItem.bulletId)) {
                    cursorResult.delete();
                    removedCount++;
                  } else {
                    seenBullets.add(queueItem.bulletId);
                  }
                  cursorResult.continue();
                } else {
                  resolve();
                }
              };
              cursor.onerror = () => reject(cursor.error);
            });
            return removedCount;
          });
        }
      };
      globalStateMachine = null;
    }
  });

  // src/ui/bullet-validator.ts
  var BulletValidator;
  var init_bullet_validator = __esm({
    "src/ui/bullet-validator.ts"() {
      "use strict";
      init_xss_safe_rendering();
      BulletValidator = class {
        validate(data) {
          const errors = [];
          if (!data.text) errors.push("Please enter bullet point text");
          if (data.text.length > 500) errors.push("Bullet point is too long (maximum 500 characters)");
          if (data.roleId === "new_role" && (!data.newRoleTitle || !data.newRoleCompany)) {
            errors.push("Please enter role title and company");
          }
          if (data.projectId === "new_project" && !data.newProjectName) {
            errors.push("Please enter project name");
          }
          return { isValid: errors.length === 0, errors };
        }
        analyzeFeatures(text) {
          const wordCount = text.trim().split(/\s+/).length;
          return {
            hasNumbers: /\d/.test(text),
            actionVerb: /^(led|managed|developed|created|built|achieved|analyzed|designed|implemented)/i.test(text.trim()),
            lengthOk: wordCount >= 5 && wordCount <= 22
          };
        }
        updateCharCounter(text, counter) {
          const length = text.length;
          const maxLength = 500;
          setSafeTextContent(counter, `${length}/${maxLength} characters`);
          if (length > maxLength * 0.9) {
            counter.className = "char-counter char-counter--warning";
          } else if (length > maxLength) {
            counter.className = "char-counter char-counter--error";
          } else {
            counter.className = "char-counter";
          }
        }
      };
    }
  });

  // src/ui/bullet-form-builder.ts
  var BulletFormBuilder;
  var init_bullet_form_builder = __esm({
    "src/ui/bullet-form-builder.ts"() {
      "use strict";
      init_bullet_validator();
      init_xss_safe_rendering();
      init_transactions();
      BulletFormBuilder = class {
        validator = new BulletValidator();
        roles = [];
        projects = [];
        async createForm(config, isEdit, onSubmit, onCancel) {
          await this.loadData();
          const form = createSafeElement("form", "", "bullet-form");
          form.append(
            this.createRoleSection(config.defaultRoleId),
            this.createProjectSection(config.defaultRoleId, config.defaultProjectId),
            this.createTextSection(config.bullet?.text || ""),
            this.createQualitySection(),
            this.createButtonSection(isEdit, onCancel)
          );
          this.setupEvents(form, onSubmit);
          this.updateQualityPreview(form, config.bullet?.text || "");
          return form;
        }
        createRoleSection(defaultRoleId) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Role", "form-label");
          const select = document.createElement("select");
          select.id = "bullet-role";
          select.className = "form-select";
          this.roles.forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = `${role.title} (${role.company})`;
            option.selected = role.id === defaultRoleId;
            select.appendChild(option);
          });
          const newOption = document.createElement("option");
          newOption.value = "new_role";
          newOption.textContent = "+ New Role";
          select.appendChild(newOption);
          const newInputs = this.createNewRoleInputs();
          group.append(label, select, newInputs);
          return group;
        }
        createProjectSection(defaultRoleId, defaultProjectId) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Project", "form-label");
          const select = document.createElement("select");
          select.id = "bullet-project";
          select.className = "form-select";
          this.updateProjectOptions(select, defaultRoleId, defaultProjectId);
          const newInputs = this.createNewProjectInputs();
          group.append(label, select, newInputs);
          return group;
        }
        createTextSection(defaultText) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Bullet Point Text", "form-label");
          const textarea = document.createElement("textarea");
          const counter = createSafeElement("div", "", "char-counter");
          textarea.id = "bullet-text";
          textarea.className = "form-textarea";
          textarea.placeholder = "Enter your bullet point...";
          textarea.rows = 4;
          textarea.value = defaultText;
          textarea.disabled = false;
          this.validator.updateCharCounter(defaultText, counter);
          group.append(label, textarea, counter);
          textarea.addEventListener("input", (e) => {
            console.log("Text input working:", textarea.value.length);
          });
          return group;
        }
        createQualitySection() {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Quality Indicators", "form-label");
          const preview = createSafeElement("div", "", "quality-preview");
          group.append(label, preview);
          return group;
        }
        createButtonSection(isEdit, onCancel) {
          const group = createSafeElement("div", "", "modal-buttons");
          const cancelBtn = document.createElement("button");
          const saveBtn = document.createElement("button");
          cancelBtn.type = "button";
          cancelBtn.textContent = "Cancel";
          cancelBtn.className = "btn btn-secondary";
          cancelBtn.onclick = onCancel;
          saveBtn.type = "submit";
          saveBtn.textContent = isEdit ? "Update" : "Create";
          saveBtn.className = "btn btn-primary";
          group.append(cancelBtn, saveBtn);
          return group;
        }
        createNewRoleInputs() {
          const container = createSafeElement("div", "", "new-role-input hidden");
          const titleInput = document.createElement("input");
          const companyInput = document.createElement("input");
          titleInput.id = "new-role-title";
          titleInput.placeholder = "Role title";
          titleInput.className = "form-input";
          companyInput.id = "new-role-company";
          companyInput.placeholder = "Company name";
          companyInput.className = "form-input";
          container.append(titleInput, companyInput);
          titleInput.addEventListener("input", (e) => {
            console.log("Role title input working");
          });
          return container;
        }
        createNewProjectInputs() {
          const container = createSafeElement("div", "", "new-project-input hidden");
          const nameInput = document.createElement("input");
          const descInput = document.createElement("textarea");
          nameInput.id = "new-project-name";
          nameInput.placeholder = "Project name";
          nameInput.className = "form-input";
          descInput.id = "new-project-description";
          descInput.placeholder = "Description (optional)";
          descInput.className = "form-textarea";
          descInput.rows = 2;
          container.append(nameInput, descInput);
          return container;
        }
        setupEvents(form, onSubmit) {
          const roleSelect = form.querySelector("#bullet-role");
          const projectSelect = form.querySelector("#bullet-project");
          const textInput = form.querySelector("#bullet-text");
          const newRoleInputs = form.querySelector(".new-role-input");
          const newProjectInputs = form.querySelector(".new-project-input");
          if (roleSelect.value === "new_role") {
            newRoleInputs.classList.remove("hidden");
          }
          if (projectSelect.value === "new_project") {
            newProjectInputs.classList.remove("hidden");
          }
          roleSelect.addEventListener("change", () => {
            console.log("Role changed to:", roleSelect.value);
            if (roleSelect.value === "new_role") {
              newRoleInputs.classList.remove("hidden");
              this.updateProjectOptions(projectSelect, void 0);
            } else {
              newRoleInputs.classList.add("hidden");
              this.updateProjectOptions(projectSelect, roleSelect.value);
            }
          });
          textInput.addEventListener("input", () => {
            console.log("Text input working, length:", textInput.value.length);
            const counter = form.querySelector(".char-counter");
            this.validator.updateCharCounter(textInput.value, counter);
            this.updateQualityPreview(form, textInput.value);
          });
          roleSelect.onchange = () => {
            const newRoleInputs2 = form.querySelector(".new-role-input");
            if (roleSelect.value === "new_role") {
              newRoleInputs2.classList.remove("hidden");
            } else {
              newRoleInputs2.classList.add("hidden");
              this.updateProjectOptions(projectSelect, roleSelect.value);
            }
          };
          projectSelect.onchange = () => {
            const newProjectInputs2 = form.querySelector(".new-project-input");
            newProjectInputs2.classList.toggle("hidden", projectSelect.value !== "new_project");
          };
          textInput.oninput = () => {
            const counter = form.querySelector(".char-counter");
            this.validator.updateCharCounter(textInput.value, counter);
            this.updateQualityPreview(form, textInput.value);
          };
          form.onsubmit = async (e) => {
            e.preventDefault();
            const data = this.getFormData(form);
            const validation = this.validator.validate(data);
            if (!validation.isValid) {
              alert(validation.errors.join("\n"));
              return;
            }
            await onSubmit(data);
          };
          roleSelect.addEventListener("change", (e) => {
            console.log("Role changed to:", roleSelect.value);
            const selectedRole = roleSelect.value;
            if (selectedRole === "new_role") {
              newRoleInputs.classList.remove("hidden");
              this.updateProjectOptions(projectSelect, void 0);
            } else {
              newRoleInputs.classList.add("hidden");
              this.updateProjectOptions(projectSelect, selectedRole);
            }
          });
        }
        updateProjectOptions(select, roleId, selectedId) {
          select.innerHTML = "";
          if (!roleId || roleId === "new_role") {
            const option = document.createElement("option");
            option.textContent = "Select a role first";
            option.disabled = true;
            select.appendChild(option);
            return;
          }
          const noProjectOption = document.createElement("option");
          noProjectOption.value = `no_project_${roleId}`;
          noProjectOption.textContent = "No Project";
          noProjectOption.selected = selectedId === `no_project_${roleId}`;
          select.appendChild(noProjectOption);
          this.projects.filter((p) => p.roleId === roleId).forEach((project) => {
            const option = document.createElement("option");
            option.value = project.id;
            option.textContent = project.name;
            option.selected = project.id === selectedId;
            select.appendChild(option);
          });
          const newOption = document.createElement("option");
          newOption.value = "new_project";
          newOption.textContent = "+ New Project";
          select.appendChild(newOption);
        }
        updateQualityPreview(form, text) {
          const preview = form.querySelector(".quality-preview");
          const features = this.validator.analyzeFeatures(text);
          preview.innerHTML = "";
          [
            { key: "hasNumbers", label: "Contains Numbers", active: features.hasNumbers },
            { key: "actionVerb", label: "Strong Action Verb", active: features.actionVerb },
            { key: "lengthOk", label: "Good Length", active: features.lengthOk }
          ].forEach((indicator) => {
            const badge = createSafeElement(
              "span",
              indicator.label,
              `quality-indicator ${indicator.active ? "quality-indicator--active" : "quality-indicator--inactive"}`
            );
            preview.appendChild(badge);
          });
        }
        getFormData(form) {
          return {
            roleId: form.querySelector("#bullet-role").value,
            projectId: form.querySelector("#bullet-project").value,
            text: form.querySelector("#bullet-text").value.trim(),
            newRoleTitle: form.querySelector("#new-role-title")?.value.trim(),
            newRoleCompany: form.querySelector("#new-role-company")?.value.trim(),
            newProjectName: form.querySelector("#new-project-name")?.value.trim(),
            newProjectDescription: form.querySelector("#new-project-description")?.value.trim()
          };
        }
        async loadData() {
          [this.roles, this.projects] = await Promise.all([
            getAll("roles"),
            getAll("projects")
          ]);
          this.roles.sort((a, b) => a.orderIndex - b.orderIndex);
        }
      };
    }
  });

  // src/ui/bullet-data-service.ts
  var BulletDataService;
  var init_bullet_data_service = __esm({
    "src/ui/bullet-data-service.ts"() {
      "use strict";
      init_transactions();
      init_embedding_state();
      init_uuid();
      BulletDataService = class {
        roles = [];
        projects = [];
        async getBullet(bulletId) {
          return getById("bullets", bulletId);
        }
        async createBullet(formData) {
          const roleId = await this.ensureRole(formData);
          const projectId = await this.ensureProject(formData, roleId);
          const bullet = {
            id: createId("bullet"),
            roleId,
            projectId,
            text: formData.text,
            source: "manual",
            normalizedFingerprint: `temp_${Date.now()}`,
            features: this.analyzeFeatures(formData.text),
            embeddingState: "pending",
            retryCount: 0,
            createdAt: Date.now(),
            lastModified: Date.now()
          };
          await create("bullets", bullet);
          await queueBulletForEmbedding(bullet.id);
        }
        async updateBullet(bulletId, formData) {
          const existingBullet = await getById("bullets", bulletId);
          if (!existingBullet) throw new Error("Bullet not found");
          const roleId = await this.ensureRole(formData);
          const projectId = await this.ensureProject(formData, roleId);
          const updatedBullet = {
            ...existingBullet,
            text: formData.text,
            roleId,
            projectId,
            features: this.analyzeFeatures(formData.text),
            lastModified: Date.now()
          };
          await update("bullets", updatedBullet);
          if (existingBullet.text !== formData.text) {
            await markBulletChanged(bulletId);
          }
        }
        async ensureRole(data) {
          if (data.roleId !== "new_role") return data.roleId;
          await this.loadRoles();
          const newRole = {
            id: createId("role"),
            title: data.newRoleTitle,
            company: data.newRoleCompany,
            orderIndex: this.roles.length,
            bulletsLimit: 3,
            startDate: (/* @__PURE__ */ new Date()).toISOString().slice(0, 7),
            endDate: null
          };
          await create("roles", newRole);
          this.roles.push(newRole);
          return newRole.id;
        }
        async ensureProject(data, roleId) {
          if (data.projectId !== "new_project") {
            return data.projectId || `no_project_${roleId}`;
          }
          await this.loadProjects();
          const newProject = {
            id: createId("project"),
            roleId,
            name: data.newProjectName,
            description: data.newProjectDescription || "",
            centroidVector: new ArrayBuffer(0),
            vectorDimensions: 0,
            bulletCount: 0,
            embeddingVersion: 1,
            createdAt: Date.now(),
            updatedAt: Date.now()
          };
          await create("projects", newProject);
          this.projects.push(newProject);
          return newProject.id;
        }
        analyzeFeatures(text) {
          const wordCount = text.trim().split(/\s+/).length;
          return {
            hasNumbers: /\d/.test(text),
            actionVerb: /^(led|managed|developed|created|built|achieved|analyzed|designed|implemented)/i.test(text.trim()),
            lengthOk: wordCount >= 5 && wordCount <= 22
          };
        }
        async loadRoles() {
          if (this.roles.length === 0) {
            this.roles = await getAll("roles");
          }
        }
        async loadProjects() {
          if (this.projects.length === 0) {
            this.projects = await getAll("projects");
          }
        }
      };
    }
  });

  // src/ui/bullet-editor.ts
  function getBulletEditor() {
    if (!globalBulletEditor) globalBulletEditor = new BulletEditor();
    return globalBulletEditor;
  }
  var BulletEditor, globalBulletEditor;
  var init_bullet_editor = __esm({
    "src/ui/bullet-editor.ts"() {
      "use strict";
      init_bullet_form_builder();
      init_bullet_data_service();
      init_xss_safe_rendering();
      BulletEditor = class {
        modal = null;
        formBuilder;
        dataService;
        constructor() {
          this.formBuilder = new BulletFormBuilder();
          this.dataService = new BulletDataService();
        }
        async showAddModal(defaultRoleId, defaultProjectId, onSave) {
          await this.showModal({
            title: "Add Bullet Point",
            bullet: null,
            ...defaultRoleId && { defaultRoleId },
            ...defaultProjectId && { defaultProjectId }
          }, false, onSave);
        }
        async showEditModal(bulletId, onSave) {
          const bullet = await this.dataService.getBullet(bulletId);
          if (!bullet) throw new Error("Bullet not found");
          await this.showModal({
            title: "Edit Bullet Point",
            bullet,
            defaultRoleId: bullet.roleId,
            defaultProjectId: bullet.projectId
          }, true, onSave);
        }
        async showModal(config, isEdit, onSave) {
          this.hideModal();
          this.modal = this.createModalStructure(config.title);
          const form = await this.formBuilder.createForm(
            config,
            isEdit,
            (data) => this.handleSubmit(data, isEdit, config.bullet?.id, onSave),
            () => this.hideModal()
          );
          this.modal.querySelector(".modal-body").appendChild(form);
          this.showModalElement();
        }
        createModalStructure(title) {
          const modal = createSafeElement("div", "", "modal-overlay");
          const content = createSafeElement("div", "", "modal-content bullet-editor-modal");
          const header = createSafeElement("div", "", "modal-header");
          const titleEl = createSafeElement("h3", title);
          const closeBtn = createSafeElement("button", "\xD7", "modal-close");
          const body = createSafeElement("div", "", "modal-body");
          closeBtn.onclick = () => this.hideModal();
          header.append(titleEl, closeBtn);
          content.append(header, body);
          modal.appendChild(content);
          return modal;
        }
        showModalElement() {
          const mainContent = document.querySelector(".main-content") || document.body;
          mainContent.appendChild(this.modal);
          console.log("Modal added to:", mainContent);
          console.log("Modal in DOM:", document.contains(this.modal));
          const textInput = this.modal.querySelector("#bullet-text");
          console.log("Text input found:", textInput);
          console.log("Text input disabled:", textInput.disabled);
          setTimeout(() => {
            textInput.focus();
            console.log("Focused on text input");
          }, 100);
        }
        async handleSubmit(data, isEdit, bulletId, onSave) {
          try {
            if (isEdit && bulletId) {
              await this.dataService.updateBullet(bulletId, data);
            } else {
              await this.dataService.createBullet(data);
            }
            this.hideModal();
            onSave?.();
          } catch (error) {
            alert("Failed to save bullet point");
          }
        }
        hideModal() {
          this.modal?.remove();
          this.modal = null;
          document.onkeydown = null;
        }
      };
      globalBulletEditor = null;
    }
  });

  // src/ui/project-editor.ts
  function getProjectEditor() {
    if (!globalProjectEditor) {
      globalProjectEditor = new ProjectEditor();
    }
    return globalProjectEditor;
  }
  var ProjectEditor, globalProjectEditor;
  var init_project_editor = __esm({
    "src/ui/project-editor.ts"() {
      "use strict";
      init_transactions();
      init_xss_safe_rendering();
      init_uuid();
      ProjectEditor = class {
        modal = null;
        currentProjectId = null;
        onSave;
        roles = [];
        /**
         * Show editor for new project
         */
        async showAddModal(defaultRoleId, onSave) {
          this.currentProjectId = null;
          this.onSave = onSave;
          await this.loadRoles();
          await this.showModal({
            title: "Add Project",
            project: null,
            ...defaultRoleId && { defaultRoleId }
          });
        }
        /**
         * Show editor for existing project
         */
        async showEditModal(projectId, onSave) {
          this.currentProjectId = projectId;
          this.onSave = onSave;
          await this.loadRoles();
          const project = await getById("projects", projectId);
          if (!project) {
            throw new Error("Project not found");
          }
          await this.showModal({
            title: "Edit Project",
            project,
            defaultRoleId: project.roleId
          });
        }
        /**
         * Load roles data
         */
        async loadRoles() {
          this.roles = await getAll("roles");
          this.roles.sort((a, b) => a.orderIndex - b.orderIndex);
        }
        /**
         * Show the modal with form
         */
        async showModal(config) {
          this.hideModal();
          this.modal = this.createModalStructure(config.title);
          const form = this.createForm(config);
          this.modal.querySelector(".modal-body").appendChild(form);
          this.showModalElement();
        }
        /**
         * Create modal structure
         */
        createModalStructure(title) {
          const modal = createSafeElement("div", "", "modal-overlay");
          const content = createSafeElement("div", "", "modal-content project-editor-modal");
          const header = createSafeElement("div", "", "modal-header");
          const titleEl = createSafeElement("h3", title);
          const closeBtn = createSafeElement("button", "\xD7", "modal-close");
          const body = createSafeElement("div", "", "modal-body");
          closeBtn.onclick = () => this.hideModal();
          header.append(titleEl, closeBtn);
          content.append(header, body);
          modal.appendChild(content);
          return modal;
        }
        /**
         * Create form
         */
        createForm(config) {
          const form = createSafeElement("form", "", "project-form");
          const roleGroup = this.createRoleSelection(config.defaultRoleId);
          const nameGroup = this.createNameInput(config.project?.name || "");
          const descGroup = this.createDescriptionInput(config.project?.description || "");
          const buttonGroup = this.createButtons(config.project !== null);
          form.append(roleGroup, nameGroup, descGroup, buttonGroup);
          form.onsubmit = async (e) => {
            e.preventDefault();
            await this.handleSubmit();
          };
          return form;
        }
        /**
         * Create role selection
         */
        createRoleSelection(defaultRoleId) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Role", "form-label");
          const select = document.createElement("select");
          select.id = "project-role";
          select.className = "form-select";
          this.roles.forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = `${role.title} (${role.company})`;
            option.selected = role.id === defaultRoleId;
            select.appendChild(option);
          });
          group.append(label, select);
          return group;
        }
        /**
         * Create name input
         */
        createNameInput(defaultName) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Project Name", "form-label");
          const input = document.createElement("input");
          input.id = "project-name";
          input.type = "text";
          input.className = "form-input";
          input.placeholder = "Enter project name...";
          input.value = defaultName;
          input.required = true;
          group.append(label, input);
          return group;
        }
        /**
         * Create description input
         */
        createDescriptionInput(defaultDescription) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Description", "form-label");
          const textarea = document.createElement("textarea");
          const counter = createSafeElement("div", "", "char-counter");
          textarea.id = "project-description";
          textarea.className = "form-textarea";
          textarea.placeholder = "Enter project description (optional)...";
          textarea.rows = 3;
          textarea.value = defaultDescription;
          this.updateCharCounter(defaultDescription, counter);
          textarea.addEventListener("input", () => {
            this.updateCharCounter(textarea.value, counter);
          });
          group.append(label, textarea, counter);
          return group;
        }
        /**
         * Create form buttons
         */
        createButtons(isEdit) {
          const group = createSafeElement("div", "", "modal-buttons");
          const cancelBtn = document.createElement("button");
          cancelBtn.type = "button";
          cancelBtn.textContent = "Cancel";
          cancelBtn.className = "btn btn-secondary";
          cancelBtn.onclick = () => this.hideModal();
          const saveBtn = document.createElement("button");
          saveBtn.type = "submit";
          saveBtn.textContent = isEdit ? "Update" : "Create";
          saveBtn.className = "btn btn-primary";
          group.append(cancelBtn, saveBtn);
          return group;
        }
        /**
         * Show modal element and set up events
         */
        showModalElement() {
          const mainContent = document.querySelector(".main-content") || document.body;
          mainContent.appendChild(this.modal);
          this.modal.onclick = (e) => e.target === this.modal && this.hideModal();
          document.onkeydown = (e) => e.key === "Escape" && this.hideModal();
          setTimeout(() => {
            const nameInput = this.modal.querySelector("#project-name");
            nameInput?.focus();
          }, 100);
        }
        /**
         * Handle form submission
         */
        async handleSubmit() {
          if (!this.modal) return;
          const formData = this.getFormData();
          const validation = this.validateFormData(formData);
          if (!validation.isValid) {
            alert(validation.errors.join("\n"));
            return;
          }
          try {
            if (this.currentProjectId) {
              await this.updateProject(this.currentProjectId, formData);
            } else {
              await this.createProject(formData);
            }
            this.hideModal();
            if (this.onSave) {
              this.onSave();
            }
          } catch (error) {
            console.error("Failed to save project:", error);
            alert("Failed to save project");
          }
        }
        /**
         * Get form data
         */
        getFormData() {
          if (!this.modal) return {};
          return {
            roleId: this.modal.querySelector("#project-role").value,
            name: this.modal.querySelector("#project-name").value.trim(),
            description: this.modal.querySelector("#project-description").value.trim()
          };
        }
        /**
         * Validate form data
         */
        validateFormData(data) {
          const errors = [];
          if (!data.name) {
            errors.push("Please enter a project name");
          }
          if (data.name.length > 100) {
            errors.push("Project name is too long (maximum 100 characters)");
          }
          if (data.description.length > 500) {
            errors.push("Description is too long (maximum 500 characters)");
          }
          if (!data.roleId) {
            errors.push("Please select a role");
          }
          return {
            isValid: errors.length === 0,
            errors
          };
        }
        /**
         * Create new project
         */
        async createProject(formData) {
          const project = {
            id: createId("project"),
            roleId: formData.roleId,
            name: formData.name,
            description: formData.description,
            centroidVector: new ArrayBuffer(0),
            vectorDimensions: 0,
            bulletCount: 0,
            embeddingVersion: 1,
            createdAt: Date.now(),
            updatedAt: Date.now()
          };
          await create("projects", project);
        }
        /**
         * Update existing project
         */
        async updateProject(projectId, formData) {
          const existingProject = await getById("projects", projectId);
          if (!existingProject) {
            throw new Error("Project not found");
          }
          const updatedProject = {
            ...existingProject,
            roleId: formData.roleId,
            name: formData.name,
            description: formData.description,
            updatedAt: Date.now()
          };
          await update("projects", updatedProject);
        }
        /**
         * Update character counter
         */
        updateCharCounter(text, counter) {
          const length = text.length;
          const maxLength = 500;
          setSafeTextContent(counter, `${length}/${maxLength} characters`);
          if (length > maxLength * 0.9) {
            counter.className = "char-counter char-counter--warning";
          } else if (length > maxLength) {
            counter.className = "char-counter char-counter--error";
          } else {
            counter.className = "char-counter";
          }
        }
        /**
         * Hide modal
         */
        hideModal() {
          this.modal?.remove();
          this.modal = null;
          this.currentProjectId = null;
          this.onSave = void 0;
          document.onkeydown = null;
        }
      };
      globalProjectEditor = null;
    }
  });

  // src/ui/data-management.ts
  var BulletPointsTable, ProjectsTable;
  var init_data_management = __esm({
    "src/ui/data-management.ts"() {
      "use strict";
      init_transactions();
      init_embedding_state();
      init_xss_safe_rendering();
      init_bullet_editor();
      init_project_editor();
      BulletPointsTable = class {
        container;
        bullets = [];
        projects = [];
        roles = [];
        sortBy = "created";
        sortOrder = "desc";
        filterText = "";
        constructor(container) {
          this.container = container;
        }
        /**
         * Render the bullets table
         */
        async render() {
          await this.loadData();
          this.container.innerHTML = "";
          const header = this.createHeader();
          const table = await this.createTable();
          this.container.appendChild(header);
          this.container.appendChild(table);
        }
        /**
         * Create table header with controls
         */
        createHeader() {
          const header = createSafeElement("div", "", "bullets-header");
          const addButton = createSafeElement("button", "+ Add Bullet Point", "btn btn-primary");
          addButton.addEventListener("click", () => this.showAddBulletModal());
          const filterInput = document.createElement("input");
          filterInput.type = "text";
          filterInput.placeholder = "Filter bullets...";
          filterInput.className = "filter-input";
          filterInput.value = this.filterText;
          filterInput.addEventListener("input", (e) => {
            this.filterText = e.target.value;
            this.render();
          });
          const sortSelect = document.createElement("select");
          sortSelect.className = "sort-select";
          [
            { value: "created", label: "Created Date" },
            { value: "modified", label: "Modified Date" },
            { value: "role", label: "Role" },
            { value: "project", label: "Project" }
          ].forEach((option) => {
            const opt = document.createElement("option");
            opt.value = option.value;
            opt.textContent = option.label;
            opt.selected = this.sortBy === option.value;
            sortSelect.appendChild(opt);
          });
          sortSelect.addEventListener("change", (e) => {
            this.sortBy = e.target.value;
            this.render();
          });
          const orderButton = createSafeElement(
            "button",
            this.sortOrder === "asc" ? "\u2191" : "\u2193",
            "btn btn-sm"
          );
          orderButton.addEventListener("click", () => {
            this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
            this.render();
          });
          header.appendChild(addButton);
          header.appendChild(filterInput);
          header.appendChild(sortSelect);
          header.appendChild(orderButton);
          return header;
        }
        /**
         * Create the bullets table
         */
        async createTable() {
          const table = createSafeElement("table", "", "bullets-table data-table");
          const thead = createSafeElement("thead");
          const headerRow = createSafeElement("tr");
          ["Role", "Project", "Bullet Text", "State", "Quality", "Modified", "Actions"].forEach((text) => {
            const th = createSafeElement("th", text);
            headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);
          const tbody = createSafeElement("tbody");
          const filteredBullets = this.getFilteredAndSortedBullets();
          for (const bullet of filteredBullets) {
            const row = await this.createBulletRow(bullet);
            tbody.appendChild(row);
          }
          if (filteredBullets.length === 0) {
            const emptyRow = createSafeElement("tr");
            const emptyCell = document.createElement("td");
            emptyCell.textContent = "No bullet points found";
            emptyCell.className = "empty-state";
            emptyCell.colSpan = 7;
            emptyRow.appendChild(emptyCell);
            tbody.appendChild(emptyRow);
          }
          table.appendChild(tbody);
          return table;
        }
        /**
         * Create a single bullet row
         */
        async createBulletRow(bullet) {
          const row = createSafeElement(
            "tr",
            "",
            `bullet-row bullet-row--${bullet.embeddingState}`
          );
          const role = this.roles.find((r) => r.id === bullet.roleId);
          const roleCell = createSafeElement(
            "td",
            role ? `${role.title}
${role.company}` : "Unknown Role",
            "role-cell"
          );
          const projectCell = createSafeElement("td", "", "project-cell");
          const projectSelect = await this.createProjectSelect(bullet);
          projectCell.appendChild(projectSelect);
          const textCell = createSafeElement("td", "", "text-cell");
          const bulletElement = renderBulletPoint(bullet.text, bullet.embeddingState);
          if (bullet.text.length > 80) {
            const truncatedText = bullet.text.substring(0, 80) + "...";
            setSafeTextContent(bulletElement.querySelector(".bullet-text") || bulletElement, truncatedText);
            bulletElement.title = bullet.text;
          }
          textCell.appendChild(bulletElement);
          const stateCell = createSafeElement("td", "", "state-cell");
          const stateBadge = this.createStateBadge(bullet);
          stateCell.appendChild(stateBadge);
          const qualityCell = createSafeElement("td", "", "quality-cell");
          const qualityBadges = this.createQualityBadges(bullet);
          qualityCell.appendChild(qualityBadges);
          const modifiedCell = createSafeElement(
            "td",
            new Date(bullet.lastModified).toLocaleDateString(),
            "date-cell"
          );
          const actionsCell = createSafeElement("td", "", "actions-cell");
          const editButton = createSafeElement("button", "Edit", "btn btn-sm");
          const deleteButton = createSafeElement("button", "Delete", "btn btn-sm btn-danger");
          editButton.addEventListener("click", () => this.editBullet(bullet.id));
          deleteButton.addEventListener("click", () => this.deleteBullet(bullet.id));
          actionsCell.appendChild(editButton);
          actionsCell.appendChild(deleteButton);
          row.appendChild(roleCell);
          row.appendChild(projectCell);
          row.appendChild(textCell);
          row.appendChild(stateCell);
          row.appendChild(qualityCell);
          row.appendChild(modifiedCell);
          row.appendChild(actionsCell);
          return row;
        }
        /**
         * Create project selection dropdown for bullet
         */
        async createProjectSelect(bullet) {
          const select = document.createElement("select");
          select.className = "project-select";
          const currentProject = this.projects.find((p) => p.id === bullet.projectId);
          if (currentProject) {
            const currentOption = document.createElement("option");
            currentOption.value = currentProject.id;
            currentOption.textContent = currentProject.name;
            currentOption.selected = true;
            select.appendChild(currentOption);
          }
          const roleProjects = this.projects.filter(
            (p) => p.roleId === bullet.roleId && p.id !== bullet.projectId
          );
          for (const project of roleProjects) {
            const option = document.createElement("option");
            option.value = project.id;
            option.textContent = project.name;
            select.appendChild(option);
          }
          select.addEventListener("change", async (e) => {
            const newProjectId = e.target.value;
            await this.moveBulletToProject(bullet.id, newProjectId);
          });
          return select;
        }
        /**
         * Create embedding state badge
         */
        createStateBadge(bullet) {
          const badge = createSafeElement(
            "span",
            "",
            `state-badge state-badge--${bullet.embeddingState}`
          );
          const stateLabels = {
            ready: "\u2713 Ready",
            pending: "\u23F3 Processing",
            stale: "\u26A0 Needs Update",
            failed: "\u2717 Failed"
          };
          setSafeTextContent(badge, stateLabels[bullet.embeddingState] || "? Unknown");
          if (bullet.embeddingState === "failed" && bullet.retryCount > 0) {
            badge.title = `Failed after ${bullet.retryCount} retries`;
          }
          return badge;
        }
        /**
         * Create quality feature badges
         */
        createQualityBadges(bullet) {
          const container = createSafeElement("div", "", "quality-badges");
          const features = [
            { key: "hasNumbers", label: "#", title: "Contains numbers" },
            { key: "actionVerb", label: "V", title: "Strong action verb" },
            { key: "lengthOk", label: "L", title: "Good length" }
          ];
          for (const feature of features) {
            const badge = createSafeElement(
              "span",
              feature.label,
              `quality-badge ${bullet.features[feature.key] ? "quality-badge--active" : "quality-badge--inactive"}`
            );
            badge.title = feature.title;
            container.appendChild(badge);
          }
          return container;
        }
        /**
         * Load data from storage
         */
        async loadData() {
          [this.bullets, this.projects, this.roles] = await Promise.all([
            getAll("bullets"),
            getAll("projects"),
            getAll("roles")
          ]);
        }
        /**
         * Get filtered and sorted bullets
         */
        getFilteredAndSortedBullets() {
          let filtered = this.bullets;
          if (this.filterText) {
            const filter = this.filterText.toLowerCase();
            filtered = filtered.filter(
              (bullet) => bullet.text.toLowerCase().includes(filter)
            );
          }
          filtered.sort((a, b) => {
            let compareValue = 0;
            switch (this.sortBy) {
              case "created":
                compareValue = a.createdAt - b.createdAt;
                break;
              case "modified":
                compareValue = a.lastModified - b.lastModified;
                break;
              case "role":
                const roleA = this.roles.find((r) => r.id === a.roleId);
                const roleB = this.roles.find((r) => r.id === b.roleId);
                compareValue = (roleA?.orderIndex || 0) - (roleB?.orderIndex || 0);
                break;
              case "project":
                const projectA = this.projects.find((p) => p.id === a.projectId);
                const projectB = this.projects.find((p) => p.id === b.projectId);
                compareValue = (projectA?.name || "").localeCompare(projectB?.name || "");
                break;
            }
            return this.sortOrder === "desc" ? -compareValue : compareValue;
          });
          return filtered;
        }
        /**
         * Move bullet to different project
         */
        async moveBulletToProject(bulletId, newProjectId) {
          try {
            const bullet = this.bullets.find((b) => b.id === bulletId);
            if (!bullet) return;
            const updatedBullet = {
              ...bullet,
              projectId: newProjectId,
              lastModified: Date.now()
            };
            await update("bullets", updatedBullet);
            await markBulletChanged(bulletId);
            await this.render();
          } catch (error) {
            console.error("Failed to move bullet:", error);
            alert("Failed to move bullet point");
          }
        }
        /**
         * Show add bullet modal
         */
        showAddBulletModal() {
          const editor = getBulletEditor();
          editor.showAddModal("role_mckinsey_sc", void 0, () => {
            this.render();
          });
        }
        editBullet(bulletId) {
          const editor = getBulletEditor();
          editor.showEditModal(bulletId, () => this.render());
        }
        /**
         * Delete bullet
         */
        async deleteBullet(bulletId) {
          if (!confirm("Are you sure you want to delete this bullet point?")) {
            return;
          }
          try {
            await deleteById("bullets", bulletId);
            await this.render();
          } catch (error) {
            console.error("Failed to delete bullet:", error);
            alert("Failed to delete bullet point");
          }
        }
      };
      ProjectsTable = class {
        container;
        projects = [];
        roles = [];
        bullets = [];
        constructor(container) {
          this.container = container;
        }
        /**
         * Render the projects table
         */
        async render() {
          await this.loadData();
          this.container.innerHTML = "";
          const header = this.createHeader();
          const table = this.createTable();
          this.container.appendChild(header);
          this.container.appendChild(table);
        }
        /**
         * Create header with add button
         */
        createHeader() {
          const header = createSafeElement("div", "", "projects-header");
          const addButton = createSafeElement("button", "+ Add Project", "btn btn-primary");
          addButton.addEventListener("click", () => this.showAddProjectModal());
          header.appendChild(addButton);
          return header;
        }
        /**
         * Create projects table
         */
        createTable() {
          const table = createSafeElement("table", "", "projects-table data-table");
          const thead = createSafeElement("thead");
          const headerRow = createSafeElement("tr");
          ["Role", "Project Name", "Description", "# Bullets", "Embedding Status", "Actions"].forEach((text) => {
            const th = createSafeElement("th", text);
            headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);
          const tbody = createSafeElement("tbody");
          for (const project of this.projects) {
            const row = this.createProjectRow(project);
            tbody.appendChild(row);
          }
          if (this.projects.length === 0) {
            const emptyRow = createSafeElement("tr");
            const emptyCell = document.createElement("td");
            emptyCell.textContent = "No projects found";
            emptyCell.className = "empty-state";
            emptyCell.colSpan = 6;
            emptyRow.appendChild(emptyCell);
            tbody.appendChild(emptyRow);
          }
          table.appendChild(tbody);
          return table;
        }
        /**
         * Create project row
         */
        createProjectRow(project) {
          const row = createSafeElement("tr", "", "project-row");
          const role = this.roles.find((r) => r.id === project.roleId);
          const roleCell = createSafeElement(
            "td",
            role ? `${role.title}
${role.company}` : "Unknown Role"
          );
          const nameCell = createSafeElement("td", project.name, "project-name");
          const descCell = createSafeElement(
            "td",
            project.description.length > 60 ? project.description.substring(0, 60) + "..." : project.description
          );
          if (project.description.length > 60) {
            descCell.title = project.description;
          }
          const projectBullets = this.bullets.filter((b) => b.projectId === project.id);
          const actualCount = projectBullets.length;
          const storedCount = project.bulletCount;
          const countCell = createSafeElement("td", "", "count-cell");
          const countText = createSafeElement("span", actualCount.toString());
          if (actualCount !== storedCount) {
            countText.className = "count-mismatch";
            countText.title = `Stored count: ${storedCount}, Actual: ${actualCount}`;
          }
          countCell.appendChild(countText);
          const statusCell = createSafeElement("td", "", "status-cell");
          const statusBadge = this.createEmbeddingStatusBadge(project, projectBullets);
          statusCell.appendChild(statusBadge);
          const actionsCell = createSafeElement("td", "", "actions-cell");
          const editButton = createSafeElement("button", "Edit", "btn btn-sm");
          const deleteButton = createSafeElement("button", "Delete", "btn btn-sm btn-danger");
          editButton.addEventListener("click", () => this.editProject(project.id));
          deleteButton.addEventListener("click", () => this.deleteProject(project.id));
          actionsCell.appendChild(editButton);
          actionsCell.appendChild(deleteButton);
          row.appendChild(roleCell);
          row.appendChild(nameCell);
          row.appendChild(descCell);
          row.appendChild(countCell);
          row.appendChild(statusCell);
          row.appendChild(actionsCell);
          return row;
        }
        /**
         * Create embedding status badge for project
         */
        createEmbeddingStatusBadge(project, bullets) {
          const badge = createSafeElement("div", "", "embedding-status");
          if (bullets.length === 0) {
            badge.className += " embedding-status--empty";
            setSafeTextContent(badge, "No bullets");
            return badge;
          }
          const stateCounts = {
            ready: 0,
            pending: 0,
            stale: 0,
            failed: 0
          };
          bullets.forEach((bullet) => {
            stateCounts[bullet.embeddingState]++;
          });
          if (stateCounts.failed > 0) {
            badge.className += " embedding-status--failed";
            setSafeTextContent(badge, `${stateCounts.failed} failed`);
          } else if (stateCounts.pending > 0) {
            badge.className += " embedding-status--pending";
            setSafeTextContent(badge, `${stateCounts.pending} processing`);
          } else if (stateCounts.stale > 0) {
            badge.className += " embedding-status--stale";
            setSafeTextContent(badge, `${stateCounts.stale} stale`);
          } else {
            badge.className += " embedding-status--ready";
            setSafeTextContent(badge, "All ready");
          }
          const hasValidCentroid = project.centroidVector.byteLength > 0;
          if (!hasValidCentroid) {
            badge.className += " embedding-status--no-centroid";
            badge.title = "Project centroid needs calculation";
          }
          return badge;
        }
        /**
         * Load data from storage
         */
        async loadData() {
          [this.projects, this.roles, this.bullets] = await Promise.all([
            getAll("projects"),
            getAll("roles"),
            getAll("bullets")
          ]);
        }
        /**
         * Show add project modal
         */
        showAddProjectModal() {
          const editor = getProjectEditor();
          const firstRole = this.roles[0];
          const defaultRoleId = firstRole ? firstRole.id : void 0;
          editor.showAddModal(defaultRoleId, () => this.render());
        }
        /**
         * Edit project
         */
        editProject(projectId) {
          const editor = getProjectEditor();
          editor.showEditModal(projectId, () => this.render());
        }
        /**
         * Delete project
         */
        async deleteProject(projectId) {
          const project = this.projects.find((p) => p.id === projectId);
          if (!project) return;
          const projectBullets = this.bullets.filter((b) => b.projectId === projectId);
          if (projectBullets.length > 0) {
            const confirmMessage = `This project has ${projectBullets.length} bullet points. Deleting it will move them to "No Project". Continue?`;
            if (!confirm(confirmMessage)) {
              return;
            }
          }
          if (!confirm(`Are you sure you want to delete "${project.name}"?`)) {
            return;
          }
          try {
            await deleteById("projects", projectId);
            await this.render();
          } catch (error) {
            console.error("Failed to delete project:", error);
            alert("Failed to delete project");
          }
        }
      };
    }
  });

  // src/ui/experience-tab.ts
  var experience_tab_exports = {};
  __export(experience_tab_exports, {
    ExperienceTab: () => ExperienceTab
  });
  var ExperienceTab;
  var init_experience_tab = __esm({
    "src/ui/experience-tab.ts"() {
      "use strict";
      init_data_management();
      init_xss_safe_rendering();
      ExperienceTab = class {
        container;
        currentView = "bullets";
        bulletsTable;
        projectsTable;
        constructor(container) {
          this.container = container;
          const tableContainer = createSafeElement("div", "", "table-container");
          this.bulletsTable = new BulletPointsTable(tableContainer);
          this.projectsTable = new ProjectsTable(tableContainer);
        }
        /**
         * Render the experience tab content
         */
        async render() {
          this.container.innerHTML = "";
          const subNav = this.createSubNavigation();
          const content = createSafeElement("div", "", "experience-content");
          this.container.appendChild(subNav);
          this.container.appendChild(content);
          if (this.currentView === "bullets") {
            await this.bulletsTable.render();
            content.appendChild(this.bulletsTable["container"]);
          } else {
            await this.projectsTable.render();
            content.appendChild(this.projectsTable["container"]);
          }
        }
        /**
         * Create sub-navigation between bullets and projects views
         */
        createSubNavigation() {
          const nav = createSafeElement("nav", "", "experience-subnav");
          const bulletsButton = createSafeElement(
            "button",
            "Bullet Points",
            `subnav-button ${this.currentView === "bullets" ? "subnav-button--active" : ""}`
          );
          const projectsButton = createSafeElement(
            "button",
            "Projects",
            `subnav-button ${this.currentView === "projects" ? "subnav-button--active" : ""}`
          );
          bulletsButton.addEventListener("click", async () => {
            this.currentView = "bullets";
            await this.render();
          });
          projectsButton.addEventListener("click", async () => {
            this.currentView = "projects";
            await this.render();
          });
          nav.appendChild(bulletsButton);
          nav.appendChild(projectsButton);
          return nav;
        }
      };
    }
  });

  // src/ui/app.ts
  init_xss_safe_rendering();
  var TAB_CONFIGS = [
    {
      id: "application",
      label: "New Application",
      icon: "\u{1F4DD}",
      description: "Generate recommendations for a job application"
    },
    {
      id: "experience",
      label: "Experience",
      icon: "\u{1F4BC}",
      description: "Manage your bullet points and projects"
    },
    {
      id: "settings",
      label: "Settings",
      icon: "\u2699\uFE0F",
      description: "Configure API key and data management"
    }
  ];
  var ResuumApp = class {
    state = {
      currentTab: "application",
      loading: false
    };
    container;
    tabNavigation = null;
    tabContent = null;
    statusBar = null;
    constructor(containerId) {
      const container = document.getElementById(containerId);
      if (!container) {
        throw new Error(`Container element with id "${containerId}" not found`);
      }
      this.container = container;
    }
    // ============================================================================
    // Initialization
    // ============================================================================
    /**
     * Initialize the application UI
     */
    async initialize() {
      try {
        this.showLoading("Initializing Resuum...");
        this.container.innerHTML = "";
        this.buildUIStructure();
        await this.switchTab("application");
        this.hideLoading();
        this.showSuccess("Resuum initialized successfully");
      } catch (error) {
        this.showError(`Failed to initialize: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Build the main UI structure
     */
    buildUIStructure() {
      this.container.innerHTML = "";
      const sidebarNav = document.getElementById("sidebar-nav");
      if (sidebarNav) {
        const navigation = this.createTabNavigation();
        sidebarNav.appendChild(navigation);
        this.tabNavigation = navigation;
      }
      const content = this.createTabContent();
      const status = this.createStatusBar();
      this.container.appendChild(content);
      this.container.appendChild(status);
      this.tabContent = content;
      this.statusBar = status;
    }
    /**
     * Create tab navigation
     */
    createTabNavigation() {
      const nav = createSafeElement("nav", "", "tab-navigation");
      const tabList = createSafeElement("ul", "", "tab-list");
      TAB_CONFIGS.forEach((tabConfig) => {
        const tabItem = this.createTabItem(tabConfig);
        tabList.appendChild(tabItem);
      });
      nav.appendChild(tabList);
      return nav;
    }
    /**
     * Create individual tab item
     */
    createTabItem(config) {
      const listItem = createSafeElement("li", "", "tab-item");
      const button = document.createElement("button");
      button.className = `tab-button ${this.state.currentTab === config.id ? "tab-button--active" : ""}`;
      button.setAttribute("data-tab", config.id);
      button.setAttribute("aria-label", config.description);
      const icon = createSafeElement("span", config.icon, "tab-icon");
      const label = createSafeElement("span", config.label, "tab-label");
      button.appendChild(icon);
      button.appendChild(label);
      button.addEventListener("click", () => {
        this.switchTab(config.id);
      });
      button.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          this.switchTab(config.id);
        }
      });
      listItem.appendChild(button);
      return listItem;
    }
    /**
     * Create tab content container
     */
    createTabContent() {
      return createSafeElement("div", "", "tab-content");
    }
    /**
     * Create status bar
     */
    createStatusBar() {
      return createSafeElement("div", "", "status-bar");
    }
    // ============================================================================
    // Tab Management
    // ============================================================================
    /**
     * Switch to a different tab
     */
    async switchTab(tabName) {
      try {
        this.state.currentTab = tabName;
        this.updateTabNavigation();
        await this.loadTabContent(tabName);
      } catch (error) {
        this.showError(`Failed to switch to ${tabName} tab: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Update tab navigation visual state
     */
    updateTabNavigation() {
      if (!this.tabNavigation) return;
      const buttons = this.tabNavigation.querySelectorAll(".tab-button");
      buttons.forEach((button) => {
        const isActive = button.getAttribute("data-tab") === this.state.currentTab;
        button.classList.toggle("tab-button--active", isActive);
        button.setAttribute("aria-selected", isActive.toString());
      });
    }
    /**
     * Load content for the current tab
     */
    async loadTabContent(tabName) {
      if (!this.tabContent) return;
      this.tabContent.innerHTML = "";
      switch (tabName) {
        case "application":
          this.loadApplicationTab();
          break;
        case "experience":
          this.loadExperienceTab();
          break;
        case "settings":
          this.loadSettingsTab();
          break;
        default:
          throw new Error(`Unknown tab: ${tabName}`);
      }
    }
    /**
     * Load New Application tab content
     */
    loadApplicationTab() {
      if (!this.tabContent) return;
      const container = createSafeElement("div", "", "application-tab");
      const jobSection = createSafeElement("section", "", "job-input-section");
      const jobTitle = createSafeElement("h2", "Job Application", "section-title");
      const jobForm = this.createJobInputForm();
      jobSection.appendChild(jobTitle);
      jobSection.appendChild(jobForm);
      const resultsSection = createSafeElement("section", "", "results-section hidden");
      const resultsTitle = createSafeElement("h2", "Recommendations", "section-title");
      const resultsContainer = createSafeElement("div", "", "results-container");
      resultsSection.appendChild(resultsTitle);
      resultsSection.appendChild(resultsContainer);
      container.appendChild(jobSection);
      container.appendChild(resultsSection);
      this.tabContent.appendChild(container);
    }
    /**
     * Create job input form
     */
    createJobInputForm() {
      const form = createSafeElement("form", "", "job-input-form");
      const titleGroup = createSafeElement("div", "", "form-group");
      const titleLabel = createSafeElement("label", "Job Title", "form-label");
      titleLabel.setAttribute("for", "job-title");
      const titleInput = document.createElement("input");
      titleInput.type = "text";
      titleInput.id = "job-title";
      titleInput.className = "form-input";
      titleInput.placeholder = "e.g., Senior Product Manager";
      titleGroup.appendChild(titleLabel);
      titleGroup.appendChild(titleInput);
      const descGroup = createSafeElement("div", "", "form-group");
      const descLabel = createSafeElement("label", "Job Description", "form-label");
      descLabel.setAttribute("for", "job-description");
      const descTextarea = document.createElement("textarea");
      descTextarea.id = "job-description";
      descTextarea.className = "form-textarea";
      descTextarea.placeholder = "Paste the job description here...";
      descTextarea.rows = 8;
      descGroup.appendChild(descLabel);
      descGroup.appendChild(descTextarea);
      const biasGroup = createSafeElement("div", "", "form-group");
      const biasLabel = createSafeElement("label", "Function Bias", "form-label");
      biasLabel.setAttribute("for", "function-bias");
      const biasSelect = document.createElement("select");
      biasSelect.id = "function-bias";
      biasSelect.className = "form-select";
      const biasOptions = [
        { value: "general", label: "General" },
        { value: "technical", label: "Technical" },
        { value: "business_strategy", label: "Business Strategy" },
        { value: "marketing", label: "Marketing" },
        { value: "operations", label: "Operations" }
      ];
      biasOptions.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option.value;
        setSafeTextContent(optionElement, option.label);
        biasSelect.appendChild(optionElement);
      });
      biasGroup.appendChild(biasLabel);
      biasGroup.appendChild(biasSelect);
      const submitButton = document.createElement("button");
      submitButton.type = "submit";
      submitButton.className = "form-submit";
      setSafeTextContent(submitButton, "Generate Recommendations");
      form.addEventListener("submit", (event) => {
        event.preventDefault();
        this.handleJobSubmission(titleInput.value, descTextarea.value, biasSelect.value);
      });
      form.appendChild(titleGroup);
      form.appendChild(descGroup);
      form.appendChild(biasGroup);
      form.appendChild(submitButton);
      return form;
    }
    /**
     * Load Experience tab content
     */
    loadExperienceTab() {
      if (!this.tabContent) return;
      console.log("Loading Experience tab...");
      try {
        Promise.resolve().then(() => (init_experience_tab(), experience_tab_exports)).then(({ ExperienceTab: ExperienceTab2 }) => {
          if (this.tabContent) {
            console.log("Creating ExperienceTab instance...");
            const experienceTab = new ExperienceTab2(this.tabContent);
            experienceTab.render();
            console.log("ExperienceTab rendered successfully");
          }
        }).catch((error) => {
          console.error("Dynamic import failed:", error);
          if (this.tabContent) {
            this.tabContent.innerHTML = `<div style="color: red; padding: 1rem;">
                Failed to load Experience tab: ${error.message}
            </div>`;
          }
        });
      } catch (error) {
        console.error("Experience tab error:", error);
        if (this.tabContent) {
          this.tabContent.innerHTML = `<div style="color: red; padding: 1rem;">
            Experience tab error: ${error instanceof Error ? error.message : "Unknown error"}
            </div>`;
        }
      }
    }
    /**
     * Load Settings tab content  
     */
    loadSettingsTab() {
      if (!this.tabContent) return;
      const container = createSafeElement("div", "", "settings-tab");
      const placeholder = createSafeElement("div", "Settings configuration coming soon...", "tab-placeholder");
      container.appendChild(placeholder);
      this.tabContent.appendChild(container);
    }
    // ============================================================================
    // Event Handlers
    // ============================================================================
    /**
     * Handle job submission
     */
    async handleJobSubmission(title, description, bias) {
      try {
        this.showLoading("Generating recommendations...");
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        this.showSuccess("Recommendations generated successfully!");
      } catch (error) {
        this.showError(`Failed to generate recommendations: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    // ============================================================================
    // State Management
    // ============================================================================
    /**
     * Show loading state
     */
    showLoading(message) {
      this.state.loading = true;
      this.state.error = void 0;
      this.state.success = void 0;
      this.updateStatusBar(message, "loading");
    }
    /**
     * Hide loading state
     */
    hideLoading() {
      this.state.loading = false;
      this.updateStatusBar("", "hidden");
    }
    /**
     * Show error message
     */
    showError(message) {
      this.state.loading = false;
      this.state.error = message;
      this.state.success = void 0;
      this.updateStatusBar(message, "error");
    }
    /**
     * Show success message
     */
    showSuccess(message) {
      this.state.loading = false;
      this.state.error = void 0;
      this.state.success = message;
      this.updateStatusBar(message, "success");
      setTimeout(() => {
        if (this.state.success === message) {
          this.hideLoading();
        }
      }, 3e3);
    }
    /**
     * Update status bar
     */
    updateStatusBar(message, type) {
      if (!this.statusBar) return;
      this.statusBar.innerHTML = "";
      this.statusBar.className = `status-bar status-bar--${type}`;
      if (type !== "hidden" && message) {
        let element;
        switch (type) {
          case "loading":
            element = createSafeElement("div", `\u23F3 ${message}`, "status-message");
            break;
          case "error":
            element = createErrorElement(message);
            break;
          case "success":
            element = createSuccessElement(`\u2713 ${message}`);
            break;
          default:
            element = createSafeElement("div", message, "status-message");
        }
        this.statusBar.appendChild(element);
      }
    }
    // ============================================================================
    // Public API
    // ============================================================================
    /**
     * Get current application state
     */
    getState() {
      return { ...this.state };
    }
    /**
     * Navigate to specific tab programmatically
     */
    async navigateToTab(tabName) {
      await this.switchTab(tabName);
    }
  };

  // src/main.ts
  console.log("Main.ts loaded - initializing app...");
  var loadingDiv = document.getElementById("loading");
  if (loadingDiv) {
    loadingDiv.remove();
  }
  try {
    const app = new ResuumApp("app");
    app.initialize();
    console.log("ResuumApp initialized successfully");
  } catch (error) {
    console.error("App initialization failed:", error);
    const container = document.getElementById("app");
    if (container) {
      container.innerHTML = `<div style="color: red; padding: 1rem;">
      App failed to load: ${error instanceof Error ? error.message : "Unknown error"}
      <br><br>
      Check browser console for details.
    </div>`;
    }
  }
})();

    </script>
</body>
</html>