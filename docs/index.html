<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resuum - AI-Powered Resume Optimization</title>
    <style>
        /* Main Layout - Two Column */
        body { 
            font-family: system-ui, sans-serif; 
            margin: 0; 
            padding: 0; 
            background: #f5f5f5; 
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            padding: 1rem 0;
            background: white;
            border-bottom: 1px solid #e5e7eb;
        }
        .header h1 {
            color: #1e293b;
            font-size: 2.5rem;
            margin: 0 0 0.5rem 0;
        }
        .header p {
            color: #64748b;
            font-size: 1.1rem;
            margin: 0;
        }

        .main-container {
            flex: 1;
            display: flex;
            min-height: 0;
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 240px;
            background: white;
            border-right: 1px solid #e5e7eb;
            flex-shrink: 0;
            padding: 1rem;
        }

        .tab-navigation {
            width: 100%;
        }
        .tab-list {
            display: flex;
            flex-direction: column;
            list-style: none;
            margin: 0;
            padding: 0;
            gap: 4px;
        }
        .tab-item {
            width: 100%;
        }
        .tab-button {
            width: 100%;
            padding: 12px 16px;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 15px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
            text-align: left;
            color: #374151;
        }
        .tab-button:hover {
            background-color: #f3f4f6;
        }
        .tab-button--active {
            background-color: #e0f2fe;
            color: #0369a1;
            font-weight: 600;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 2rem;
        }

        .tab-content {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            flex: 1;
            overflow: auto;
        }
        
        /* Experience Tab Styles */
        .experience-header {
            margin-bottom: 2rem;
        }
        .section-title {
            color: #1e293b;
            margin-bottom: 1rem;
        }
        .embedding-summary {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1.5rem;
        }
        .summary-text {
            margin: 0;
            font-weight: 500;
        }
        .state-badges {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }
        .summary-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
        }
        .summary-badge--ready { background: #dcfce7; color: #166534; }
        .summary-badge--pending { background: #fef3c7; color: #92400e; }
        .summary-badge--stale { background: #fed7aa; color: #9a3412; }
        .summary-badge--failed { background: #fecaca; color: #991b1b; }
        
        /* Sub Navigation */
        .experience-sub-nav {
            margin-bottom: 1.5rem;
        }
        .sub-nav-list {
            display: flex;
            list-style: none;
            margin: 0;
            padding: 0;
            gap: 0.5rem;
        }
        .sub-nav-button {
            padding: 0.5rem 1rem;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sub-nav-button--active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        /* Table Styles */
        .table-controls {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .sort-select {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
        }
        .bullets-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        .bullets-table th,
        .bullets-table td {
            padding: 0.75rem;
            text-align: left;
            border: 1px solid #e5e7eb;
            vertical-align: top;
        }
        .bullets-table th {
            background: #f9fafb;
            font-weight: 600;
        }
        .bullets-table tr:nth-child(even) {
            background: #f9fafb;
        }
        
        /* State Badges */
        .state-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
            white-space: nowrap;
        }
        .state-badge--ready { background: #dcfce7; color: #166534; }
        .state-badge--pending { background: #fef3c7; color: #92400e; }
        .state-badge--stale { background: #fed7aa; color: #9a3412; }
        .state-badge--failed { background: #fecaca; color: #991b1b; }
        
        /* Quality Indicators */
        .quality-indicators {
            display: flex;
            gap: 0.25rem;
        }
        .quality-indicator {
            font-size: 1.2em;
        }
        .quality-indicator.active {
            opacity: 1;
        }
        .quality-indicator.inactive {
            opacity: 0.3;
        }
        
        /* Status Bar */
        .status-bar {
            margin-top: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
        }
        .status-bar--loading {
            background: #fef3c7;
            color: #92400e;
        }
        .status-bar--error {
            background: #fecaca;
            color: #991b1b;
        }
        .status-bar--success {
            background: #dcfce7;
            color: #166534;
        }
        .status-bar--hidden {
            display: none;
        }
        
        /* Form Styles */
        .form-group {
            margin-bottom: 1rem;
        }
        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        .form-input,
        .form-textarea,
        .form-select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-family: inherit;
        }
        .form-textarea {
            resize: vertical;
        }
        .form-submit {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
        }
        .form-submit:hover {
            background: #2563eb;
        }
        .form-submit:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        
        /* Utility Classes */
        .hidden { display: none; }
        .error { 
            background: #fecaca; 
            border: 1px solid #f87171; 
            padding: 1rem; 
            border-radius: 4px; 
            color: #991b1b; 
            margin: 1rem 0;
        }
        .success {
            background: #dcfce7;
            border: 1px solid #4ade80;
            padding: 1rem;
            border-radius: 4px;
            color: #166534;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>Resuum</h1>
        <p>AI-Powered Resume Optimization</p>
    </header>
    
    <div class="main-container">
        <div class="sidebar">
            <div id="sidebar-nav"></div>
        </div>
        
        <div class="main-content">
            <main id="app">
                <div id="loading">Loading application...</div>
            </main>
        </div>
    </div>

    <script>
        "use strict";
var Resuum = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // src/ui/xss-safe-rendering.ts
  function createSafeTextNode(text) {
    return document.createTextNode(text || "");
  }
  function setSafeTextContent(element, text) {
    element.textContent = "";
    element.appendChild(createSafeTextNode(text));
  }
  function createSafeElement(tagName, textContent, className) {
    const element = document.createElement(tagName);
    if (className) {
      element.className = className;
    }
    if (textContent) {
      setSafeTextContent(element, textContent);
    }
    return element;
  }
  function createErrorElement(message, title) {
    const container = createSafeElement("div", "", "error-message");
    if (title) {
      const titleElement = createSafeElement("h3", title, "error-title");
      container.appendChild(titleElement);
    }
    const messageElement = createSafeElement("p", message, "error-text");
    container.appendChild(messageElement);
    return container;
  }
  function createSuccessElement(message) {
    return createSafeElement("div", message, "success-message");
  }
  var init_xss_safe_rendering = __esm({
    "src/ui/xss-safe-rendering.ts"() {
      "use strict";
    }
  });

  // src/storage/schema.ts
  function handleSchemaUpgrade(event, db) {
    const oldVersion = event.oldVersion;
    console.log(`Upgrading database from version ${oldVersion} to ${DB_SCHEMA.version}`);
    if (oldVersion === 1) {
      if (db.objectStoreNames.contains("embeddings")) {
        db.deleteObjectStore("embeddings");
      }
      if (db.objectStoreNames.contains("embedQueue")) {
        db.deleteObjectStore("embedQueue");
      }
      console.log("Removed obsolete embedding stores");
    }
  }
  var DB_SCHEMA;
  var init_schema = __esm({
    "src/storage/schema.ts"() {
      "use strict";
      DB_SCHEMA = {
        name: "ResuumDB",
        version: 2,
        // Incremented for schema changes
        stores: [
          {
            name: "roles",
            keyPath: "id",
            indexes: [
              { name: "orderIndex", keyPath: "orderIndex" },
              { name: "company", keyPath: "company" },
              { name: "startDate", keyPath: "startDate" },
              { name: "endDate", keyPath: "endDate" }
            ]
          },
          {
            name: "projects",
            keyPath: "id",
            indexes: [
              { name: "roleId", keyPath: "roleId" },
              { name: "name", keyPath: "name" },
              { name: "createdAt", keyPath: "createdAt" },
              { name: "role_created", keyPath: ["roleId", "createdAt"] }
            ]
          },
          {
            name: "bullets",
            keyPath: "id",
            indexes: [
              { name: "roleId", keyPath: "roleId" },
              { name: "projectId", keyPath: "projectId" },
              { name: "source", keyPath: "source" },
              { name: "createdAt", keyPath: "createdAt" },
              { name: "role_project", keyPath: ["roleId", "projectId"] }
            ]
          },
          {
            name: "settings",
            keyPath: "key",
            indexes: []
          }
        ]
      };
    }
  });

  // src/storage/database.ts
  async function initializeDatabase() {
    if (dbInstance) {
      return dbInstance;
    }
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_SCHEMA.name, DB_SCHEMA.version);
      request.onerror = () => {
        reject(new Error(`Failed to open database: ${request.error?.message}`));
      };
      request.onsuccess = () => {
        dbInstance = request.result;
        console.log(`Database ${DB_SCHEMA.name} opened successfully`);
        resolve(dbInstance);
      };
      request.onupgradeneeded = (event) => {
        const db = request.result;
        console.log(`Upgrading database from version ${event.oldVersion} to ${DB_SCHEMA.version}`);
        handleSchemaUpgrade(event, db);
        DB_SCHEMA.stores.forEach((storeConfig) => {
          if (!db.objectStoreNames.contains(storeConfig.name)) {
            const store = db.createObjectStore(storeConfig.name, {
              keyPath: storeConfig.keyPath
            });
            storeConfig.indexes?.forEach((indexConfig) => {
              store.createIndex(
                indexConfig.name,
                indexConfig.keyPath,
                indexConfig.options
              );
            });
            console.log(`Created store: ${storeConfig.name}`);
          }
        });
      };
    });
  }
  async function getDatabase() {
    if (!dbInstance) {
      return initializeDatabase();
    }
    return dbInstance;
  }
  var dbInstance;
  var init_database = __esm({
    "src/storage/database.ts"() {
      "use strict";
      init_schema();
      dbInstance = null;
    }
  });

  // src/storage/transactions.ts
  async function executeTransaction(storeNames, mode, operation) {
    const db = await getDatabase();
    const transaction = db.transaction(storeNames, mode);
    const stores = {};
    for (const storeName of storeNames) {
      stores[storeName] = transaction.objectStore(storeName);
    }
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error("Transaction timeout after 30 seconds"));
      }, 3e4);
    });
    const operationPromise = operation(transaction, stores);
    const completionPromise = new Promise((resolve, reject) => {
      transaction.oncomplete = () => {
        operationPromise.then(resolve).catch(reject);
      };
      transaction.onerror = () => {
        reject(new Error(`Transaction failed: ${transaction.error?.message || "Unknown error"}`));
      };
      transaction.onabort = () => {
        reject(new Error("Transaction was aborted"));
      };
    });
    return Promise.race([completionPromise, timeoutPromise]);
  }
  async function getById(storeName, id) {
    return executeTransaction([storeName], "readonly", async (_, stores) => {
      return new Promise((resolve, reject) => {
        const request = stores[storeName].get(id);
        request.onsuccess = () => {
          resolve(request.result || null);
        };
        request.onerror = () => {
          reject(new Error(`Failed to get ${storeName} by ID: ${request.error?.message}`));
        };
      });
    });
  }
  async function getAll(storeName) {
    return executeTransaction([storeName], "readonly", async (_, stores) => {
      return new Promise((resolve, reject) => {
        const request = stores[storeName].getAll();
        request.onsuccess = () => {
          resolve(request.result || []);
        };
        request.onerror = () => {
          reject(new Error(`Failed to get all ${storeName}: ${request.error?.message}`));
        };
      });
    });
  }
  async function create(storeName, data) {
    return executeTransaction([storeName], "readwrite", async (_, stores) => {
      return new Promise((resolve, reject) => {
        const request = stores[storeName].add(data);
        request.onsuccess = () => {
          resolve(data);
        };
        request.onerror = () => {
          reject(new Error(`Failed to create ${storeName}: ${request.error?.message}`));
        };
      });
    });
  }
  async function update(storeName, data) {
    return executeTransaction([storeName], "readwrite", async (_, stores) => {
      return new Promise((resolve, reject) => {
        const request = stores[storeName].put(data);
        request.onsuccess = () => {
          resolve(data);
        };
        request.onerror = () => {
          reject(new Error(`Failed to update ${storeName}: ${request.error?.message}`));
        };
      });
    });
  }
  async function deleteById(storeName, id) {
    return executeTransaction([storeName], "readwrite", async (_, stores) => {
      return new Promise((resolve, reject) => {
        const request = stores[storeName].delete(id);
        request.onsuccess = () => {
          resolve();
        };
        request.onerror = () => {
          reject(new Error(`Failed to delete ${storeName}: ${request.error?.message}`));
        };
      });
    });
  }
  var init_transactions = __esm({
    "src/storage/transactions.ts"() {
      "use strict";
      init_database();
    }
  });

  // src/ui/bullet-validator.ts
  function getBulletValidator() {
    if (!globalBulletValidator) {
      globalBulletValidator = new BulletValidator();
    }
    return globalBulletValidator;
  }
  var VALIDATION_RULES, BulletValidator, globalBulletValidator;
  var init_bullet_validator = __esm({
    "src/ui/bullet-validator.ts"() {
      "use strict";
      VALIDATION_RULES = {
        minLength: 10,
        maxLength: 500,
        maxWords: 75
      };
      BulletValidator = class {
        /**
         * Validate bullet point text
         */
        validateText(text) {
          const errors = [];
          const warnings = [];
          if (!text || typeof text !== "string") {
            errors.push("Bullet point text is required");
            return { isValid: false, errors, warnings };
          }
          const trimmedText = text.trim();
          if (trimmedText.length === 0) {
            errors.push("Bullet point cannot be empty");
          } else if (trimmedText.length < VALIDATION_RULES.minLength) {
            errors.push(`Bullet point should be at least ${VALIDATION_RULES.minLength} characters long`);
          } else if (trimmedText.length > VALIDATION_RULES.maxLength) {
            errors.push(`Bullet point should be less than ${VALIDATION_RULES.maxLength} characters long`);
          }
          const wordCount = trimmedText.split(/\s+/).length;
          if (wordCount > VALIDATION_RULES.maxWords) {
            warnings.push(`Bullet point has ${wordCount} words. Consider keeping it under ${VALIDATION_RULES.maxWords} words for readability`);
          }
          if (trimmedText.length > 0) {
            if (!trimmedText.match(/^[A-Z]/) && !trimmedText.match(/^[0-9]/)) {
              warnings.push("Consider starting with a capital letter or number");
            }
            if (wordCount < 5) {
              warnings.push("Bullet point seems very short. Consider adding more detail about your impact");
            }
            if (trimmedText.includes("  ")) {
              warnings.push("Remove extra spaces between words");
            }
            if (trimmedText.startsWith("\u2022") || trimmedText.startsWith("-")) {
              warnings.push("Remove bullet symbols - they will be added automatically");
            }
          }
          return {
            isValid: errors.length === 0,
            errors,
            warnings
          };
        }
        /**
         * Validate complete bullet data
         */
        validateBullet(bulletData) {
          const textValidation = this.validateText(bulletData.text);
          const errors = [...textValidation.errors];
          const warnings = [...textValidation.warnings];
          if (!bulletData.roleId || bulletData.roleId.trim().length === 0) {
            errors.push("Role selection is required");
          }
          if (!bulletData.projectId || bulletData.projectId.trim().length === 0) {
            errors.push("Project selection is required");
          }
          return {
            isValid: errors.length === 0,
            errors,
            warnings
          };
        }
        /**
         * Check for potential duplicates
         */
        checkForDuplicates(newText, existingBullets) {
          const normalizedNew = this.normalizeText(newText);
          const similarBullets = [];
          for (const bullet of existingBullets) {
            const normalizedExisting = this.normalizeText(bullet.text);
            const similarity = this.calculateTextSimilarity(normalizedNew, normalizedExisting);
            if (similarity > 0.8) {
              similarBullets.push({ bullet, similarity });
            }
          }
          return {
            hasDuplicates: similarBullets.length > 0,
            similarBullets: similarBullets.sort((a, b) => b.similarity - a.similarity)
          };
        }
        /**
         * Normalize text for comparison
         */
        normalizeText(text) {
          return text.toLowerCase().replace(/[^\w\s]/g, " ").replace(/\s+/g, " ").trim();
        }
        /**
         * Calculate simple text similarity (Jaccard similarity)
         */
        calculateTextSimilarity(text1, text2) {
          const words1 = new Set(text1.split(/\s+/));
          const words2 = new Set(text2.split(/\s+/));
          const intersection = new Set([...words1].filter((word) => words2.has(word)));
          const union = /* @__PURE__ */ new Set([...words1, ...words2]);
          return union.size === 0 ? 0 : intersection.size / union.size;
        }
        /**
         * Get validation suggestions
         */
        getImprovementSuggestions(text) {
          const suggestions = [];
          const trimmedText = text.trim();
          if (trimmedText.length === 0) {
            return ["Add meaningful content describing your accomplishment or responsibility"];
          }
          const startsWithActionVerb = /^(Led|Managed|Developed|Created|Implemented|Analyzed|Designed|Built|Optimized|Increased|Decreased|Improved|Reduced|Achieved|Delivered|Coordinated|Established|Generated|Streamlined)/i.test(trimmedText);
          if (!startsWithActionVerb) {
            suggestions.push("Consider starting with a strong action verb (Led, Developed, Implemented, etc.)");
          }
          const hasNumbers = /\d/.test(trimmedText);
          if (!hasNumbers) {
            suggestions.push("Consider adding specific numbers or metrics to quantify your impact");
          }
          const hasImpactWords = /(result|impact|effect|outcome|improvement|increase|decrease|saving|revenue|efficiency)/i.test(trimmedText);
          if (!hasImpactWords) {
            suggestions.push("Consider adding the impact or results of your work");
          }
          return suggestions;
        }
      };
      globalBulletValidator = null;
    }
  });

  // src/ui/bullet-form-builder.ts
  var BulletFormBuilder;
  var init_bullet_form_builder = __esm({
    "src/ui/bullet-form-builder.ts"() {
      "use strict";
      init_bullet_validator();
      init_xss_safe_rendering();
      init_transactions();
      BulletFormBuilder = class {
        roles = [];
        projects = [];
        async createForm(config, isEdit, onSubmit, onCancel) {
          await this.loadData();
          const form = createSafeElement("form", "", "bullet-form");
          form.append(
            this.createRoleSection(config.defaultRoleId),
            this.createProjectSection(config.defaultRoleId, config.defaultProjectId),
            this.createTextSection(config.bullet?.text || ""),
            this.createButtonSection(isEdit, onCancel)
          );
          this.setupEvents(form, onSubmit);
          return form;
        }
        createRoleSection(defaultRoleId) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Role", "form-label");
          const select = document.createElement("select");
          select.id = "bullet-role";
          select.className = "form-select";
          this.roles.forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = `${role.title} (${role.company})`;
            option.selected = role.id === defaultRoleId;
            select.appendChild(option);
          });
          group.append(label, select);
          return group;
        }
        createProjectSection(defaultRoleId, defaultProjectId) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Project", "form-label");
          const select = document.createElement("select");
          select.id = "bullet-project";
          select.className = "form-select";
          this.updateProjectOptions(select, defaultRoleId, defaultProjectId);
          group.append(label, select);
          return group;
        }
        createTextSection(defaultText) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Bullet Point Text", "form-label");
          const textarea = document.createElement("textarea");
          const counter = createSafeElement("div", "", "char-counter");
          textarea.id = "bullet-text";
          textarea.className = "form-textarea";
          textarea.placeholder = "Enter your bullet point...";
          textarea.rows = 4;
          textarea.value = defaultText;
          this.updateCharCounter(defaultText, counter);
          group.append(label, textarea, counter);
          return group;
        }
        createButtonSection(isEdit, onCancel) {
          const group = createSafeElement("div", "", "modal-buttons");
          const cancelBtn = document.createElement("button");
          cancelBtn.type = "button";
          cancelBtn.textContent = "Cancel";
          cancelBtn.className = "btn btn-secondary";
          cancelBtn.onclick = onCancel;
          const saveBtn = document.createElement("button");
          saveBtn.type = "submit";
          saveBtn.textContent = isEdit ? "Update" : "Create";
          saveBtn.className = "btn btn-primary";
          group.append(cancelBtn, saveBtn);
          return group;
        }
        setupEvents(form, onSubmit) {
          const roleSelect = form.querySelector("#bullet-role");
          const projectSelect = form.querySelector("#bullet-project");
          const textarea = form.querySelector("#bullet-text");
          const counter = form.querySelector(".char-counter");
          roleSelect.addEventListener("change", () => {
            this.updateProjectOptions(projectSelect, roleSelect.value);
          });
          textarea.addEventListener("input", () => {
            this.updateCharCounter(textarea.value, counter);
          });
          form.addEventListener("submit", async (e) => {
            e.preventDefault();
            const data = this.getFormData(form);
            const validation = this.validateFormData(data);
            if (!validation.isValid) {
              alert(validation.errors.join("\n"));
              return;
            }
            await onSubmit(data);
          });
        }
        updateProjectOptions(select, roleId, selectedId) {
          select.innerHTML = "";
          if (!roleId) {
            const option = document.createElement("option");
            option.textContent = "Select a role first";
            option.disabled = true;
            select.appendChild(option);
            return;
          }
          this.projects.filter((p) => p.roleId === roleId).forEach((project) => {
            const option = document.createElement("option");
            option.value = project.id;
            option.textContent = project.name;
            option.selected = project.id === selectedId;
            select.appendChild(option);
          });
          if (this.projects.filter((p) => p.roleId === roleId).length === 0) {
            const option = document.createElement("option");
            option.textContent = "No projects available";
            option.disabled = true;
            select.appendChild(option);
          }
        }
        /**
         * Update character counter (implemented locally)
         */
        updateCharCounter(text, counter) {
          const length = text.length;
          const maxLength = 500;
          setSafeTextContent(counter, `${length}/${maxLength} characters`);
          if (length > maxLength * 0.9) {
            counter.className = "char-counter char-counter--warning";
          } else if (length > maxLength) {
            counter.className = "char-counter char-counter--error";
          } else {
            counter.className = "char-counter";
          }
        }
        getFormData(form) {
          return {
            roleId: form.querySelector("#bullet-role").value,
            projectId: form.querySelector("#bullet-project").value,
            text: form.querySelector("#bullet-text").value.trim()
          };
        }
        validateFormData(data) {
          const validator = getBulletValidator();
          return validator.validateBullet(data);
        }
        async loadData() {
          [this.roles, this.projects] = await Promise.all([
            getAll("roles"),
            getAll("projects")
          ]);
          this.roles.sort((a, b) => a.orderIndex - b.orderIndex);
        }
      };
    }
  });

  // src/ui/bullet-data-service.ts
  function getBulletDataService() {
    if (!globalBulletDataService) {
      globalBulletDataService = new BulletDataService();
    }
    return globalBulletDataService;
  }
  var BulletDataService, globalBulletDataService;
  var init_bullet_data_service = __esm({
    "src/ui/bullet-data-service.ts"() {
      "use strict";
      init_transactions();
      BulletDataService = class {
        /**
         * Get all bullet points
         */
        async getAllBullets() {
          return getAll("bullets");
        }
        /**
         * Get bullet points by role
         */
        async getBulletsByRole(roleId) {
          const allBullets = await this.getAllBullets();
          return allBullets.filter((bullet) => bullet.roleId === roleId);
        }
        /**
         * Get bullet points by project
         */
        async getBulletsByProject(projectId) {
          const allBullets = await this.getAllBullets();
          return allBullets.filter((bullet) => bullet.projectId === projectId);
        }
        /**
         * Create new bullet point
         */
        async createBullet(bulletData) {
          const bullet = {
            id: `bullet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            roleId: bulletData.roleId,
            projectId: bulletData.projectId,
            text: bulletData.text.trim(),
            source: bulletData.source || "manual",
            createdAt: Date.now(),
            lastModified: Date.now()
          };
          return create("bullets", bullet);
        }
        /**
         * Update bullet point
         */
        async updateBullet(bulletId, updates) {
          const existingBullet = await getById("bullets", bulletId);
          if (!existingBullet) {
            throw new Error(`Bullet with id ${bulletId} not found`);
          }
          const updatedBullet = {
            ...existingBullet,
            ...updates,
            lastModified: Date.now()
          };
          if (updates.text) {
            updatedBullet.text = updates.text.trim();
          }
          return update("bullets", updatedBullet);
        }
        /**
         * Delete bullet point
         */
        async deleteBullet(bulletId) {
          await deleteById("bullets", bulletId);
        }
        /**
         * Get bullets with role and project context
         */
        async getBulletsWithContext() {
          const [bullets, roles, projects] = await Promise.all([
            this.getAllBullets(),
            getAll("roles"),
            getAll("projects")
          ]);
          return bullets.map((bullet) => ({
            bullet,
            role: roles.find((r) => r.id === bullet.roleId) || null,
            project: projects.find((p) => p.id === bullet.projectId) || null
          }));
        }
        /**
         * Validate bullet point data
         */
        validateBulletData(text, roleId, projectId) {
          const errors = [];
          if (!text || text.trim().length === 0) {
            errors.push("Bullet point text is required");
          }
          if (text && text.trim().length < 10) {
            errors.push("Bullet point should be at least 10 characters long");
          }
          if (text && text.trim().length > 500) {
            errors.push("Bullet point should be less than 500 characters");
          }
          if (!roleId) {
            errors.push("Role is required");
          }
          if (!projectId) {
            errors.push("Project is required");
          }
          return {
            isValid: errors.length === 0,
            errors
          };
        }
        /**
         * Search bullets by text
         */
        async searchBullets(searchTerm) {
          const allBullets = await this.getAllBullets();
          const lowerSearchTerm = searchTerm.toLowerCase();
          return allBullets.filter(
            (bullet) => bullet.text.toLowerCase().includes(lowerSearchTerm)
          );
        }
        /**
         * Get bullet statistics
         */
        async getBulletStats() {
          const bullets = await this.getAllBullets();
          const bulletsByRole = bullets.reduce((acc, bullet) => {
            const existing = acc.find((item) => item.roleId === bullet.roleId);
            if (existing) {
              existing.count++;
            } else {
              acc.push({ roleId: bullet.roleId, count: 1 });
            }
            return acc;
          }, []);
          const bulletsByProject = bullets.reduce((acc, bullet) => {
            const existing = acc.find((item) => item.projectId === bullet.projectId);
            if (existing) {
              existing.count++;
            } else {
              acc.push({ projectId: bullet.projectId, count: 1 });
            }
            return acc;
          }, []);
          return {
            totalBullets: bullets.length,
            bulletsByRole,
            bulletsByProject
          };
        }
      };
      globalBulletDataService = null;
    }
  });

  // src/ui/bullet-editor.ts
  function getBulletEditor() {
    if (!globalBulletEditor) {
      globalBulletEditor = new BulletEditor();
    }
    return globalBulletEditor;
  }
  var BulletEditor, globalBulletEditor;
  var init_bullet_editor = __esm({
    "src/ui/bullet-editor.ts"() {
      "use strict";
      init_bullet_form_builder();
      init_bullet_data_service();
      init_xss_safe_rendering();
      BulletEditor = class {
        modal = null;
        formBuilder;
        constructor() {
          this.formBuilder = new BulletFormBuilder();
        }
        async showAddModal(defaultRoleId, defaultProjectId, onSave) {
          await this.showModal({
            title: "Add Bullet Point",
            bullet: null,
            ...defaultRoleId && { defaultRoleId },
            ...defaultProjectId && { defaultProjectId }
          }, false, onSave);
        }
        async showEditModal(bulletId, onSave) {
          const dataService = getBulletDataService();
          const bullets = await dataService.getAllBullets();
          const bullet = bullets.find((b) => b.id === bulletId);
          if (!bullet) throw new Error("Bullet not found");
          await this.showModal({
            title: "Edit Bullet Point",
            bullet,
            defaultRoleId: bullet.roleId,
            defaultProjectId: bullet.projectId
          }, true, onSave);
        }
        async showModal(config, isEdit, onSave) {
          this.hideModal();
          this.modal = this.createModalStructure(config.title);
          const form = await this.formBuilder.createForm(
            config,
            isEdit,
            (data) => this.handleSubmit(data, isEdit, config.bullet?.id, onSave),
            () => this.hideModal()
          );
          this.modal.querySelector(".modal-body").appendChild(form);
          this.showModalElement();
        }
        createModalStructure(title) {
          const modal = createSafeElement("div", "", "modal-overlay");
          const content = createSafeElement("div", "", "modal-content bullet-editor-modal");
          const header = createSafeElement("div", "", "modal-header");
          const titleEl = createSafeElement("h3", title);
          const closeBtn = createSafeElement("button", "\xD7", "modal-close");
          const body = createSafeElement("div", "", "modal-body");
          closeBtn.onclick = () => this.hideModal();
          header.append(titleEl, closeBtn);
          content.append(header, body);
          modal.appendChild(content);
          return modal;
        }
        showModalElement() {
          const mainContent = document.querySelector(".main-content") || document.body;
          mainContent.appendChild(this.modal);
          setTimeout(() => {
            const firstInput = this.modal.querySelector("input, textarea");
            firstInput?.focus();
          }, 100);
        }
        async handleSubmit(data, isEdit, bulletId, onSave) {
          try {
            const dataService = getBulletDataService();
            if (isEdit && bulletId) {
              await dataService.updateBullet(bulletId, {
                text: data.text,
                projectId: data.projectId
              });
            } else {
              await dataService.createBullet({
                roleId: data.roleId,
                projectId: data.projectId,
                text: data.text,
                source: "manual"
              });
            }
            this.hideModal();
            if (onSave) {
              onSave();
            }
          } catch (error) {
            console.error("Failed to save bullet:", error);
            alert("Failed to save bullet point");
          }
        }
        hideModal() {
          this.modal?.remove();
          this.modal = null;
        }
      };
      globalBulletEditor = null;
    }
  });

  // src/utils/uuid.ts
  function generateUUID() {
    if (typeof crypto !== "undefined" && crypto.getRandomValues) {
      const bytes = new Uint8Array(16);
      crypto.getRandomValues(bytes);
      if (bytes.length < 16) {
        throw new Error("Failed to generate sufficient random bytes");
      }
      bytes[6] = (bytes[6] ?? 0) & 15 | 64;
      bytes[8] = (bytes[8] ?? 0) & 63 | 128;
      const hex = Array.from(bytes).map((b) => (b ?? 0).toString(16).padStart(2, "0")).join("");
      return [
        hex.slice(0, 8),
        hex.slice(8, 12),
        hex.slice(12, 16),
        hex.slice(16, 20),
        hex.slice(20, 32)
      ].join("-");
    } else {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
  }
  function generateULID() {
    const timestamp = Date.now();
    const timestampPart = timestamp.toString(36).padStart(10, "0");
    const randomPart = generateRandomString(16);
    return `${timestampPart}_${randomPart}`;
  }
  function generateRandomString(length) {
    const chars = "0123456789abcdefghijklmnopqrstuvwxyz";
    let result = "";
    if (typeof crypto !== "undefined" && crypto.getRandomValues) {
      const bytes = new Uint8Array(length);
      crypto.getRandomValues(bytes);
      for (let i = 0; i < Math.min(bytes.length, length); i++) {
        const byteValue = bytes[i] ?? 0;
        result += chars[byteValue % chars.length] ?? "0";
      }
    } else {
      for (let i = 0; i < length; i++) {
        result += chars[Math.floor(Math.random() * chars.length)] ?? "0";
      }
    }
    return result;
  }
  function createId(type = "bullet") {
    if (type === "bullet" || type === "embed_queue") {
      return generateULID();
    }
    return generateUUID();
  }
  var init_uuid = __esm({
    "src/utils/uuid.ts"() {
      "use strict";
    }
  });

  // src/ui/project-editor.ts
  function getProjectEditor() {
    if (!globalProjectEditor) {
      globalProjectEditor = new ProjectEditor();
    }
    return globalProjectEditor;
  }
  var ProjectEditor, globalProjectEditor;
  var init_project_editor = __esm({
    "src/ui/project-editor.ts"() {
      "use strict";
      init_transactions();
      init_xss_safe_rendering();
      init_uuid();
      ProjectEditor = class {
        modal = null;
        currentProjectId = null;
        onSave;
        roles = [];
        /**
         * Show editor for new project
         */
        async showAddModal(defaultRoleId, onSave) {
          this.currentProjectId = null;
          this.onSave = onSave;
          await this.loadRoles();
          await this.showModal({
            title: "Add Project",
            project: null,
            ...defaultRoleId && { defaultRoleId }
          });
        }
        /**
         * Show editor for existing project
         */
        async showEditModal(projectId, onSave) {
          this.currentProjectId = projectId;
          this.onSave = onSave;
          await this.loadRoles();
          const project = await getById("projects", projectId);
          if (!project) {
            throw new Error("Project not found");
          }
          await this.showModal({
            title: "Edit Project",
            project,
            defaultRoleId: project.roleId
          });
        }
        /**
         * Load roles data
         */
        async loadRoles() {
          this.roles = await getAll("roles");
          this.roles.sort((a, b) => a.orderIndex - b.orderIndex);
        }
        /**
         * Show the modal with form
         */
        async showModal(config) {
          this.hideModal();
          this.modal = this.createModalStructure(config.title);
          const form = this.createForm(config);
          this.modal.querySelector(".modal-body").appendChild(form);
          this.showModalElement();
        }
        /**
         * Create modal structure
         */
        createModalStructure(title) {
          const modal = createSafeElement("div", "", "modal-overlay");
          const content = createSafeElement("div", "", "modal-content project-editor-modal");
          const header = createSafeElement("div", "", "modal-header");
          const titleEl = createSafeElement("h3", title);
          const closeBtn = createSafeElement("button", "\xD7", "modal-close");
          const body = createSafeElement("div", "", "modal-body");
          closeBtn.onclick = () => this.hideModal();
          header.append(titleEl, closeBtn);
          content.append(header, body);
          modal.appendChild(content);
          return modal;
        }
        /**
         * Create form
         */
        createForm(config) {
          const form = document.createElement("form");
          form.className = "project-form";
          const roleGroup = this.createRoleSelection(config.defaultRoleId);
          const nameGroup = document.createElement("div");
          nameGroup.className = "form-group";
          const nameLabel = document.createElement("label");
          nameLabel.textContent = "Project Name";
          nameLabel.className = "form-label";
          const nameInput = document.createElement("input");
          nameInput.id = "project-name";
          nameInput.type = "text";
          nameInput.className = "form-input";
          nameInput.placeholder = "Enter project name...";
          nameInput.value = config.project?.name || "";
          nameGroup.append(nameLabel, nameInput);
          const descGroup = document.createElement("div");
          descGroup.className = "form-group";
          const descLabel = document.createElement("label");
          descLabel.textContent = "Description";
          descLabel.className = "form-label";
          const descInput = document.createElement("textarea");
          descInput.id = "project-description";
          descInput.className = "form-textarea";
          descInput.placeholder = "Enter description...";
          descInput.rows = 3;
          descInput.value = config.project?.description || "";
          descGroup.append(descLabel, descInput);
          const buttonGroup = this.createButtons(config.project !== null);
          form.append(roleGroup, nameGroup, descGroup, buttonGroup);
          form.addEventListener("submit", async (e) => {
            e.preventDefault();
            await this.handleSubmit();
          });
          return form;
        }
        /**
         * Create role selection
         */
        createRoleSelection(defaultRoleId) {
          const group = createSafeElement("div", "", "form-group");
          const label = createSafeElement("label", "Role", "form-label");
          const select = document.createElement("select");
          select.id = "project-role";
          select.className = "form-select";
          this.roles.forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = `${role.title} (${role.company})`;
            option.selected = role.id === defaultRoleId;
            select.appendChild(option);
          });
          group.append(label, select);
          return group;
        }
        /**
         * Create form buttons
         */
        createButtons(isEdit) {
          const group = createSafeElement("div", "", "modal-buttons");
          const cancelBtn = document.createElement("button");
          cancelBtn.type = "button";
          cancelBtn.textContent = "Cancel";
          cancelBtn.className = "btn btn-secondary";
          cancelBtn.onclick = () => this.hideModal();
          const saveBtn = document.createElement("button");
          saveBtn.type = "submit";
          saveBtn.textContent = isEdit ? "Update" : "Create";
          saveBtn.className = "btn btn-primary";
          group.append(cancelBtn, saveBtn);
          return group;
        }
        /**
         * Show modal element and set up events
         */
        showModalElement() {
          const mainContent = document.querySelector(".main-content") || document.body;
          mainContent.appendChild(this.modal);
          setTimeout(() => {
            const allInputs = this.modal.querySelectorAll("input, textarea");
            allInputs.forEach((input) => {
              input.disabled = false;
              input.readOnly = false;
            });
            const nameInput = this.modal.querySelector("#project-name");
            nameInput?.focus();
          }, 100);
        }
        /**
         * Handle form submission
         */
        async handleSubmit() {
          if (!this.modal) return;
          const formData = this.getFormData();
          const validation = this.validateFormData(formData);
          if (!validation.isValid) {
            alert(validation.errors.join("\n"));
            return;
          }
          try {
            if (this.currentProjectId) {
              await this.updateProject(this.currentProjectId, formData);
            } else {
              await this.createProject(formData);
            }
            this.hideModal();
            if (this.onSave) {
              this.onSave();
            }
          } catch (error) {
            console.error("Failed to save project:", error);
            alert("Failed to save project");
          }
        }
        /**
         * Get form data
         */
        getFormData() {
          if (!this.modal) return {};
          return {
            roleId: this.modal.querySelector("#project-role").value,
            name: this.modal.querySelector("#project-name").value.trim(),
            description: this.modal.querySelector("#project-description").value.trim()
          };
        }
        /**
         * Validate form data
         */
        validateFormData(data) {
          const errors = [];
          if (!data.name) {
            errors.push("Please enter a project name");
          }
          if (data.name.length > 100) {
            errors.push("Project name is too long (maximum 100 characters)");
          }
          if (data.description.length > 500) {
            errors.push("Description is too long (maximum 500 characters)");
          }
          if (!data.roleId) {
            errors.push("Please select a role");
          }
          return {
            isValid: errors.length === 0,
            errors
          };
        }
        /**
         * Create new project (FIXED - removed embedding fields)
         */
        async createProject(formData) {
          const project = {
            id: createId("project"),
            roleId: formData.roleId,
            name: formData.name,
            description: formData.description,
            bulletCount: 0,
            createdAt: Date.now(),
            updatedAt: Date.now()
          };
          await create("projects", project);
        }
        /**
         * Update existing project
         */
        async updateProject(projectId, formData) {
          const existingProject = await getById("projects", projectId);
          if (!existingProject) {
            throw new Error("Project not found");
          }
          const updatedProject = {
            ...existingProject,
            roleId: formData.roleId,
            name: formData.name,
            description: formData.description,
            updatedAt: Date.now()
          };
          await update("projects", updatedProject);
        }
        /**
         * Hide modal
         */
        hideModal() {
          this.modal?.remove();
          this.modal = null;
          this.currentProjectId = null;
          this.onSave = void 0;
          document.onkeydown = null;
        }
      };
      globalProjectEditor = null;
    }
  });

  // src/ui/data-management.ts
  var BulletPointsTable, ProjectsTable;
  var init_data_management = __esm({
    "src/ui/data-management.ts"() {
      "use strict";
      init_transactions();
      init_xss_safe_rendering();
      init_bullet_editor();
      init_project_editor();
      BulletPointsTable = class {
        container;
        bullets = [];
        projects = [];
        roles = [];
        sortBy = "created";
        sortOrder = "desc";
        filterText = "";
        constructor(container) {
          this.container = container;
        }
        /**
         * Render the bullets table
         */
        async render() {
          await this.loadData();
          this.container.innerHTML = "";
          const header = this.createHeader();
          const table = await this.createTable();
          this.container.appendChild(header);
          this.container.appendChild(table);
        }
        /**
         * Create table header with controls
         */
        createHeader() {
          const header = createSafeElement("div", "", "bullets-header");
          const addButton = createSafeElement("button", "+ Add Bullet Point", "btn btn-primary");
          addButton.addEventListener("click", () => this.showAddBulletModal());
          const filterInput = document.createElement("input");
          filterInput.type = "text";
          filterInput.placeholder = "Filter bullets...";
          filterInput.className = "filter-input";
          filterInput.value = this.filterText;
          filterInput.addEventListener("input", (e) => {
            this.filterText = e.target.value;
            this.render();
          });
          const sortSelect = document.createElement("select");
          sortSelect.className = "sort-select";
          [
            { value: "created", label: "Created Date" },
            { value: "modified", label: "Modified Date" },
            { value: "role", label: "Role" },
            { value: "project", label: "Project" }
          ].forEach((option) => {
            const opt = document.createElement("option");
            opt.value = option.value;
            opt.textContent = option.label;
            opt.selected = this.sortBy === option.value;
            sortSelect.appendChild(opt);
          });
          sortSelect.addEventListener("change", (e) => {
            this.sortBy = e.target.value;
            this.render();
          });
          const orderButton = createSafeElement(
            "button",
            this.sortOrder === "asc" ? "\u2191" : "\u2193",
            "btn btn-sm"
          );
          orderButton.addEventListener("click", () => {
            this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
            this.render();
          });
          header.appendChild(addButton);
          header.appendChild(filterInput);
          header.appendChild(sortSelect);
          header.appendChild(orderButton);
          return header;
        }
        /**
         * Create the bullets table
         */
        async createTable() {
          const table = createSafeElement("table", "", "bullets-table data-table");
          const thead = createSafeElement("thead");
          const headerRow = createSafeElement("tr");
          ["Role", "Project", "Bullet Text", "Modified", "Actions"].forEach((text) => {
            const th = createSafeElement("th", text);
            headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);
          const tbody = createSafeElement("tbody");
          const filteredBullets = this.getFilteredAndSortedBullets();
          for (const bullet of filteredBullets) {
            const row = await this.createBulletRow(bullet);
            tbody.appendChild(row);
          }
          if (filteredBullets.length === 0) {
            const emptyRow = createSafeElement("tr");
            const emptyCell = document.createElement("td");
            emptyCell.textContent = "No bullet points found";
            emptyCell.className = "empty-state";
            emptyCell.colSpan = 5;
            emptyRow.appendChild(emptyCell);
            tbody.appendChild(emptyRow);
          }
          table.appendChild(tbody);
          return table;
        }
        /**
         * Create a single bullet row
         */
        async createBulletRow(bullet) {
          const row = createSafeElement("tr", "", "bullet-row");
          const role = this.roles.find((r) => r.id === bullet.roleId);
          const roleCell = createSafeElement(
            "td",
            role ? `${role.title}
${role.company}` : "Unknown Role",
            "role-cell"
          );
          const projectCell = createSafeElement("td", "", "project-cell");
          const projectSelect = await this.createProjectSelect(bullet);
          projectCell.appendChild(projectSelect);
          const textCell = createSafeElement("td", "", "text-cell");
          const truncatedText = bullet.text.length > 80 ? bullet.text.substring(0, 80) + "..." : bullet.text;
          setSafeTextContent(textCell, truncatedText);
          textCell.title = bullet.text;
          const modifiedCell = createSafeElement(
            "td",
            new Date(bullet.lastModified).toLocaleDateString(),
            "date-cell"
          );
          const actionsCell = createSafeElement("td", "", "actions-cell");
          const editButton = createSafeElement("button", "Edit", "btn btn-sm");
          const deleteButton = createSafeElement("button", "Delete", "btn btn-sm btn-danger");
          editButton.addEventListener("click", () => this.editBullet(bullet.id));
          deleteButton.addEventListener("click", () => this.deleteBullet(bullet.id));
          actionsCell.appendChild(editButton);
          actionsCell.appendChild(deleteButton);
          row.appendChild(roleCell);
          row.appendChild(projectCell);
          row.appendChild(textCell);
          row.appendChild(modifiedCell);
          row.appendChild(actionsCell);
          return row;
        }
        /**
         * Create project selection dropdown for bullet
         */
        async createProjectSelect(bullet) {
          const select = document.createElement("select");
          select.className = "project-select";
          const currentProject = this.projects.find((p) => p.id === bullet.projectId);
          if (currentProject) {
            const currentOption = document.createElement("option");
            currentOption.value = currentProject.id;
            currentOption.textContent = currentProject.name;
            currentOption.selected = true;
            select.appendChild(currentOption);
          }
          const roleProjects = this.projects.filter(
            (p) => p.roleId === bullet.roleId && p.id !== bullet.projectId
          );
          roleProjects.forEach((project) => {
            const option = document.createElement("option");
            option.value = project.id;
            option.textContent = project.name;
            select.appendChild(option);
          });
          select.addEventListener("change", () => {
            this.moveBulletToProject(bullet.id, select.value);
          });
          return select;
        }
        /**
         * Get filtered and sorted bullets
         */
        getFilteredAndSortedBullets() {
          let filtered = this.bullets;
          if (this.filterText) {
            const filterLower = this.filterText.toLowerCase();
            filtered = filtered.filter((bullet) => {
              const role = this.roles.find((r) => r.id === bullet.roleId);
              const project = this.projects.find((p) => p.id === bullet.projectId);
              return bullet.text.toLowerCase().includes(filterLower) || role?.title.toLowerCase().includes(filterLower) || role?.company.toLowerCase().includes(filterLower) || project?.name.toLowerCase().includes(filterLower);
            });
          }
          filtered.sort((a, b) => {
            let compareValue = 0;
            switch (this.sortBy) {
              case "role":
                const roleA = this.roles.find((r) => r.id === a.roleId)?.title || "";
                const roleB = this.roles.find((r) => r.id === b.roleId)?.title || "";
                compareValue = roleA.localeCompare(roleB);
                break;
              case "project":
                const projectA = this.projects.find((p) => p.id === a.projectId)?.name || "";
                const projectB = this.projects.find((p) => p.id === b.projectId)?.name || "";
                compareValue = projectA.localeCompare(projectB);
                break;
              case "created":
                compareValue = a.createdAt - b.createdAt;
                break;
              case "modified":
                compareValue = a.lastModified - b.lastModified;
                break;
            }
            return this.sortOrder === "asc" ? compareValue : -compareValue;
          });
          return filtered;
        }
        /**
         * Move bullet to different project
         */
        async moveBulletToProject(bulletId, newProjectId) {
          try {
            const bullet = this.bullets.find((b) => b.id === bulletId);
            if (!bullet) return;
            const updatedBullet = {
              ...bullet,
              projectId: newProjectId,
              lastModified: Date.now()
            };
            await update("bullets", updatedBullet);
            await this.render();
          } catch (error) {
            console.error("Failed to move bullet:", error);
            alert("Failed to move bullet point");
          }
        }
        /**
         * Show add bullet modal
         */
        showAddBulletModal() {
          try {
            const editor = getBulletEditor();
            editor.showAddModal(void 0, void 0, () => {
              this.render();
            });
          } catch (error) {
            console.error("Error showing add modal:", error);
            alert("Error opening bullet editor: " + (error instanceof Error ? error.message : "Unknown error"));
          }
        }
        editBullet(bulletId) {
          try {
            const editor = getBulletEditor();
            editor.showEditModal(bulletId, () => this.render());
          } catch (error) {
            console.error("Error editing bullet:", error);
            alert("Error opening bullet editor: " + (error instanceof Error ? error.message : "Unknown error"));
          }
        }
        /**
         * Delete bullet
         */
        async deleteBullet(bulletId) {
          if (!confirm("Are you sure you want to delete this bullet point?")) {
            return;
          }
          try {
            await deleteById("bullets", bulletId);
            await this.render();
          } catch (error) {
            console.error("Failed to delete bullet:", error);
            alert("Failed to delete bullet point");
          }
        }
        /**
         * Load data from storage
         */
        async loadData() {
          [this.bullets, this.projects, this.roles] = await Promise.all([
            getAll("bullets"),
            getAll("projects"),
            getAll("roles")
          ]);
        }
      };
      ProjectsTable = class {
        container;
        projects = [];
        roles = [];
        bullets = [];
        constructor(container) {
          this.container = container;
        }
        /**
         * Render the projects table
         */
        async render() {
          await this.loadData();
          this.container.innerHTML = "";
          const header = this.createHeader();
          const table = this.createTable();
          this.container.appendChild(header);
          this.container.appendChild(table);
        }
        /**
         * Create header with add button
         */
        createHeader() {
          const header = createSafeElement("div", "", "projects-header");
          const addButton = createSafeElement("button", "+ Add Project", "btn btn-primary");
          addButton.addEventListener("click", () => this.showAddProjectModal());
          header.appendChild(addButton);
          return header;
        }
        /**
         * Create projects table
         */
        createTable() {
          const table = createSafeElement("table", "", "projects-table data-table");
          const thead = createSafeElement("thead");
          const headerRow = createSafeElement("tr");
          ["Role", "Project Name", "Description", "# Bullets", "Actions"].forEach((text) => {
            const th = createSafeElement("th", text);
            headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);
          const tbody = createSafeElement("tbody");
          for (const project of this.projects) {
            const row = this.createProjectRow(project);
            tbody.appendChild(row);
          }
          if (this.projects.length === 0) {
            const emptyRow = createSafeElement("tr");
            const emptyCell = document.createElement("td");
            emptyCell.textContent = "No projects found";
            emptyCell.className = "empty-state";
            emptyCell.colSpan = 5;
            emptyRow.appendChild(emptyCell);
            tbody.appendChild(emptyRow);
          }
          table.appendChild(tbody);
          return table;
        }
        /**
         * Create project row
         */
        createProjectRow(project) {
          const row = createSafeElement("tr", "", "project-row");
          const role = this.roles.find((r) => r.id === project.roleId);
          const roleCell = createSafeElement(
            "td",
            role ? `${role.title}
${role.company}` : "Unknown Role"
          );
          const nameCell = createSafeElement("td", project.name, "project-name");
          const descCell = createSafeElement(
            "td",
            project.description && project.description.length > 60 ? project.description.substring(0, 60) + "..." : project.description || "No description"
          );
          const bulletCount = this.bullets.filter((b) => b.projectId === project.id).length;
          const countCell = createSafeElement("td", bulletCount.toString());
          const actionsCell = createSafeElement("td", "", "actions-cell");
          const editButton = createSafeElement("button", "Edit", "btn btn-sm");
          const deleteButton = createSafeElement("button", "Delete", "btn btn-sm btn-danger");
          editButton.addEventListener("click", () => this.editProject(project.id));
          deleteButton.addEventListener("click", () => this.deleteProject(project.id));
          actionsCell.appendChild(editButton);
          actionsCell.appendChild(deleteButton);
          row.appendChild(roleCell);
          row.appendChild(nameCell);
          row.appendChild(descCell);
          row.appendChild(countCell);
          row.appendChild(actionsCell);
          return row;
        }
        /**
         * Show add project modal
         */
        showAddProjectModal() {
          try {
            const editor = getProjectEditor();
            editor.showAddModal(void 0, () => this.render());
          } catch (error) {
            console.error("Error showing add project modal:", error);
            alert("Error opening project editor: " + (error instanceof Error ? error.message : "Unknown error"));
          }
        }
        /**
         * Edit project
         */
        editProject(projectId) {
          try {
            const editor = getProjectEditor();
            editor.showEditModal(projectId, () => this.render());
          } catch (error) {
            console.error("Error editing project:", error);
            alert("Error opening project editor: " + (error instanceof Error ? error.message : "Unknown error"));
          }
        }
        /**
         * Delete project
         */
        async deleteProject(projectId) {
          const project = this.projects.find((p) => p.id === projectId);
          if (!project) return;
          const projectBullets = this.bullets.filter((b) => b.projectId === projectId);
          if (projectBullets.length > 0) {
            const confirmMessage = `This project has ${projectBullets.length} bullet points. Deleting it will remove them. Continue?`;
            if (!confirm(confirmMessage)) {
              return;
            }
          }
          if (!confirm(`Are you sure you want to delete "${project.name}"?`)) {
            return;
          }
          try {
            await deleteById("projects", projectId);
            await this.render();
          } catch (error) {
            console.error("Failed to delete project:", error);
            alert("Failed to delete project");
          }
        }
        /**
         * Load data from storage
         */
        async loadData() {
          [this.projects, this.roles, this.bullets] = await Promise.all([
            getAll("projects"),
            getAll("roles"),
            getAll("bullets")
          ]);
        }
      };
    }
  });

  // src/ui/experience-tab.ts
  var experience_tab_exports = {};
  __export(experience_tab_exports, {
    ExperienceTab: () => ExperienceTab
  });
  var ExperienceTab;
  var init_experience_tab = __esm({
    "src/ui/experience-tab.ts"() {
      "use strict";
      init_data_management();
      init_xss_safe_rendering();
      ExperienceTab = class {
        container;
        currentView = "bullets";
        bulletsTable = null;
        projectsTable = null;
        constructor(container) {
          this.container = container;
          console.log("ExperienceTab constructor called with container:", container);
        }
        /**
         * Render the experience tab content
         */
        async render() {
          console.log("ExperienceTab render() called");
          try {
            this.container.innerHTML = "";
            const tabContent = createSafeElement("div", "", "experience-tab-content");
            const subNav = this.createSubNavigation();
            const contentArea = createSafeElement("div", "", "experience-content");
            tabContent.appendChild(subNav);
            tabContent.appendChild(contentArea);
            this.container.appendChild(tabContent);
            console.log("ExperienceTab basic structure created, rendering current view...");
            await this.renderCurrentView(contentArea);
            console.log("ExperienceTab render completed successfully");
          } catch (error) {
            console.error("Error in ExperienceTab.render():", error);
            this.container.innerHTML = `
        <div style="color: red; padding: 1rem; border: 1px solid #ff0000; border-radius: 4px;">
          <h3>Experience Tab Render Error</h3>
          <p>Error rendering experience tab: ${error instanceof Error ? error.message : "Unknown error"}</p>
        </div>
      `;
          }
        }
        /**
         * Create sub-navigation between bullets and projects
         */
        createSubNavigation() {
          const nav = createSafeElement("div", "", "experience-subnav");
          const bulletsButton = createSafeElement(
            "button",
            "Bullet Points",
            `subnav-button ${this.currentView === "bullets" ? "subnav-button--active" : ""}`
          );
          const projectsButton = createSafeElement(
            "button",
            "Projects",
            `subnav-button ${this.currentView === "projects" ? "subnav-button--active" : ""}`
          );
          bulletsButton.addEventListener("click", async () => {
            if (this.currentView !== "bullets") {
              this.currentView = "bullets";
              await this.render();
            }
          });
          projectsButton.addEventListener("click", async () => {
            if (this.currentView !== "projects") {
              this.currentView = "projects";
              await this.render();
            }
          });
          nav.appendChild(bulletsButton);
          nav.appendChild(projectsButton);
          return nav;
        }
        /**
         * Render the current view content
         */
        async renderCurrentView(contentArea) {
          contentArea.innerHTML = "";
          if (this.currentView === "bullets") {
            await this.renderBulletsView(contentArea);
          } else {
            await this.renderProjectsView(contentArea);
          }
        }
        /**
         * Render bullets view - FIXED to actually use BulletPointsTable
         */
        async renderBulletsView(contentArea) {
          try {
            console.log("Rendering bullets view...");
            const tableContainer = createSafeElement("div", "", "bullets-table-container");
            contentArea.appendChild(tableContainer);
            this.bulletsTable = new BulletPointsTable(tableContainer);
            await this.bulletsTable.render();
            console.log("Bullets view rendered successfully");
          } catch (error) {
            console.error("Error rendering bullets view:", error);
            contentArea.innerHTML = `
        <div style="padding: 1rem;">
          <h3>Bullets</h3>
          <p style="color: orange;">Error loading bullets table: ${error instanceof Error ? error.message : "Unknown error"}</p>
          <p>The bullets functionality is being updated. Please check back soon.</p>
        </div>
      `;
          }
        }
        /**
         * Render projects view - FIXED to actually use ProjectsTable
         */
        async renderProjectsView(contentArea) {
          try {
            console.log("Rendering projects view...");
            const tableContainer = createSafeElement("div", "", "projects-table-container");
            contentArea.appendChild(tableContainer);
            this.projectsTable = new ProjectsTable(tableContainer);
            await this.projectsTable.render();
            console.log("Projects view rendered successfully");
          } catch (error) {
            console.error("Error rendering projects view:", error);
            contentArea.innerHTML = `
        <div style="padding: 1rem;">
          <h3>Projects</h3>
          <p style="color: orange;">Error loading projects interface: ${error instanceof Error ? error.message : "Unknown error"}</p>
          <p>The projects functionality is being updated. Please check back soon.</p>
        </div>
      `;
          }
        }
        /**
         * Refresh the current view
         */
        async refresh() {
          await this.render();
        }
      };
    }
  });

  // src/ui/app.ts
  init_xss_safe_rendering();

  // src/ui/application-tab.ts
  init_xss_safe_rendering();
  var ApplicationTab = class {
    container;
    processingState = "idle";
    lastResults = null;
    lastError = null;
    lastJobData = null;
    constructor(container) {
      this.container = container;
    }
    // ============================================================================
    // Public Interface
    // ============================================================================
    /**
     * Render the Application tab content
     */
    render() {
      this.container.innerHTML = "";
      const tabContainer = createSafeElement("div", "", "application-tab");
      const inputSection = this.createJobInputSection();
      tabContainer.appendChild(inputSection);
      if (this.lastResults || this.processingState !== "idle") {
        const resultsSection = this.createResultsSection();
        tabContainer.appendChild(resultsSection);
      }
      this.container.appendChild(tabContainer);
      this.addKeyboardShortcuts();
    }
    // ============================================================================
    // Job Input Section
    // ============================================================================
    /**
     * Create job input form section
     */
    createJobInputSection() {
      const section = createSafeElement("section", "", "job-input-section");
      const title = createSafeElement("h2", "New Job Application", "section-title");
      const description = createSafeElement(
        "p",
        "Paste your job description below and get AI-powered resume recommendations.",
        "section-description"
      );
      const form = this.createJobInputForm();
      section.appendChild(title);
      section.appendChild(description);
      section.appendChild(form);
      return section;
    }
    /**
     * Create job input form
     */
    createJobInputForm() {
      const form = createSafeElement("form", "", "job-input-form");
      form.setAttribute("data-form", "job-input");
      const titleGroup = this.createInputGroup(
        "job-title",
        "Job Title",
        "text",
        "e.g., Senior Product Manager"
      );
      const descriptionGroup = this.createTextareaGroup(
        "job-description",
        "Job Description",
        "Paste the complete job description here..."
      );
      const submitButton = document.createElement("button");
      submitButton.type = "submit";
      submitButton.className = "form-submit";
      submitButton.disabled = this.processingState === "processing";
      setSafeTextContent(
        submitButton,
        this.processingState === "processing" ? "Generating..." : "Generate Recommendations"
      );
      form.appendChild(titleGroup);
      form.appendChild(descriptionGroup);
      form.appendChild(submitButton);
      form.addEventListener("submit", (event) => {
        event.preventDefault();
        this.handleFormSubmission(form);
      });
      return form;
    }
    /**
     * Create input group
     */
    createInputGroup(id, label, type, placeholder) {
      const group = createSafeElement("div", "", "input-group");
      const labelElement = createSafeElement("label", label, "input-label");
      labelElement.setAttribute("for", id);
      const input = document.createElement("input");
      input.type = type;
      input.id = id;
      input.className = "form-input";
      input.placeholder = placeholder;
      group.appendChild(labelElement);
      group.appendChild(input);
      return group;
    }
    /**
     * Create textarea group
     */
    createTextareaGroup(id, label, placeholder) {
      const group = createSafeElement("div", "", "input-group");
      const labelElement = createSafeElement("label", label, "input-label");
      labelElement.setAttribute("for", id);
      const textarea = document.createElement("textarea");
      textarea.id = id;
      textarea.className = "form-textarea";
      textarea.placeholder = placeholder;
      textarea.rows = 8;
      group.appendChild(labelElement);
      group.appendChild(textarea);
      return group;
    }
    // ============================================================================
    // Results Section
    // ============================================================================
    /**
     * Create results display section
     */
    createResultsSection() {
      const section = createSafeElement("section", "", "results-section");
      const title = createSafeElement("h3", "Recommendations", "results-title");
      section.appendChild(title);
      if (this.processingState === "processing") {
        const status = this.createProcessingStatus();
        section.appendChild(status);
      } else if (this.processingState === "complete" && this.lastResults) {
        const summary = this.createResultsSummary();
        const details = this.createResultsDetails();
        const actions = this.createResultsActions();
        section.appendChild(summary);
        section.appendChild(details);
        section.appendChild(actions);
      } else if (this.processingState === "error") {
        const error = this.createErrorDisplay();
        section.appendChild(error);
      }
      return section;
    }
    /**
     * Create processing status display
     */
    createProcessingStatus() {
      const container = createSafeElement("div", "", "processing-status");
      const spinner = createSafeElement("div", "", "spinner");
      const status = createSafeElement("p", "Analyzing job description and finding best matches...", "status-text");
      container.appendChild(spinner);
      container.appendChild(status);
      return container;
    }
    /**
     * Create results summary box
     */
    createResultsSummary() {
      if (!this.lastResults) return createSafeElement("div", "", "results-summary");
      const summary = createSafeElement("div", "", "results-summary");
      const { totalBullets, processingTime, projectsConsidered } = this.lastResults;
      const summaryText = createSafeElement("p", "", "summary-text");
      setSafeTextContent(
        summaryText,
        `Selected ${totalBullets} bullet points across ${projectsConsidered} projects. Processing time: ${processingTime}s`
      );
      summary.appendChild(summaryText);
      return summary;
    }
    /**
     * Create detailed results display
     */
    createResultsDetails() {
      if (!this.lastResults) return createSafeElement("div", "", "results-details");
      const details = createSafeElement("div", "", "results-details");
      this.lastResults.roleResults.forEach((roleResult) => {
        const roleSection = this.createRoleResultSection(roleResult);
        details.appendChild(roleSection);
      });
      return details;
    }
    /**
     * Create individual role result section
     */
    createRoleResultSection(roleResult) {
      const section = createSafeElement("div", "", "role-result-section");
      const header = createSafeElement("div", "", "role-header");
      const title = createSafeElement("h4", "", "role-title");
      setSafeTextContent(title, `${roleResult.roleTitle} - ${roleResult.selectedBullets.length} bullet points selected`);
      const projectsInfo = createSafeElement("p", "", "projects-info");
      setSafeTextContent(projectsInfo, `Projects considered: ${roleResult.projectsShortlisted.join(", ")}`);
      header.appendChild(title);
      header.appendChild(projectsInfo);
      const bulletsList = createSafeElement("ul", "", "bullets-list");
      const sortedBullets = [...roleResult.selectedBullets].sort((a, b) => b.relevance - a.relevance);
      sortedBullets.forEach((bullet) => {
        const listItem = createSafeElement("li", "", "bullet-item");
        const bulletText = createSafeElement("span", bullet.text, "bullet-text");
        const metadata = createSafeElement("span", "", "bullet-metadata");
        setSafeTextContent(metadata, `(Relevance: ${Math.round(bullet.relevance * 100)}%, Project: ${bullet.projectName})`);
        listItem.appendChild(bulletText);
        listItem.appendChild(metadata);
        bulletsList.appendChild(listItem);
      });
      section.appendChild(header);
      section.appendChild(bulletsList);
      return section;
    }
    /**
     * Create results actions section
     */
    createResultsActions() {
      const actions = createSafeElement("div", "", "results-actions");
      const copyButton = document.createElement("button");
      copyButton.className = "action-button action-button--primary";
      setSafeTextContent(copyButton, "Copy All Bullets");
      copyButton.addEventListener("click", () => this.copyResultsToClipboard());
      const exportButton = document.createElement("button");
      exportButton.className = "action-button action-button--secondary";
      setSafeTextContent(exportButton, "Export to Plain Text");
      exportButton.addEventListener("click", () => this.exportResultsToText());
      const refreshButton = document.createElement("button");
      refreshButton.className = "action-button action-button--tertiary";
      setSafeTextContent(refreshButton, "Refresh Results");
      refreshButton.addEventListener("click", () => this.refreshResults());
      actions.appendChild(copyButton);
      actions.appendChild(exportButton);
      actions.appendChild(refreshButton);
      return actions;
    }
    /**
     * Create error display
     */
    createErrorDisplay() {
      const container = createSafeElement("div", "", "error-display");
      const title = createSafeElement("h4", "Generation Failed", "error-title");
      const message = createSafeElement("p", this.lastError || "Unknown error occurred", "error-message");
      const retryButton = document.createElement("button");
      retryButton.className = "action-button action-button--primary";
      setSafeTextContent(retryButton, "Try Again");
      retryButton.addEventListener("click", () => this.retryGeneration());
      container.appendChild(title);
      container.appendChild(message);
      container.appendChild(retryButton);
      return container;
    }
    // ============================================================================
    // Event Handlers
    // ============================================================================
    /**
     * Handle form submission
     */
    async handleFormSubmission(form) {
      try {
        const formData = new FormData(form);
        const jobTitle = formData.get("job-title");
        const jobDescription = formData.get("job-description");
        if (!jobDescription?.trim()) {
          throw new Error("Job description is required");
        }
        await this.generateRecommendations(jobTitle, jobDescription);
      } catch (error) {
        this.processingState = "error";
        this.lastError = error instanceof Error ? error.message : "Unknown error";
        this.render();
      }
    }
    /**
     * Generate recommendations (placeholder for now)
     */
    async generateRecommendations(jobTitle, jobDescription) {
      this.processingState = "processing";
      this.lastError = null;
      this.lastJobData = { title: jobTitle, description: jobDescription };
      this.render();
      try {
        const startTime = Date.now();
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        const result = await this.simulateRecommendationGeneration(jobTitle, jobDescription);
        const processingTime = (Date.now() - startTime) / 1e3;
        result.processingTime = processingTime;
        this.lastResults = result;
        this.processingState = "complete";
        this.render();
      } catch (error) {
        this.processingState = "error";
        this.lastError = error instanceof Error ? error.message : "Unknown error";
        this.render();
      }
    }
    /**
     * Simulate recommendation generation (temporary)
     */
    async simulateRecommendationGeneration(jobTitle, jobDescription) {
      return {
        jobTitle,
        totalBullets: 5,
        processingTime: 2.1,
        projectsConsidered: 8,
        roleResults: [
          {
            roleTitle: "Senior Consultant",
            projectsShortlisted: ["Global Telecom", "Healthcare M&A", "Retail Strategy"],
            selectedBullets: [
              {
                text: "Led cross-functional team of 12 engineers to deliver enterprise software platform, resulting in 40% improvement in deployment efficiency",
                relevance: 0.94,
                projectName: "Global Telecom"
              },
              {
                text: "Developed comprehensive market analysis framework, identifying $50M growth opportunity in emerging markets",
                relevance: 0.89,
                projectName: "Healthcare M&A"
              }
            ],
            avgRelevance: 0.9
          }
        ]
      };
    }
    /**
     * Copy results to clipboard
     */
    async copyResultsToClipboard() {
      console.log("Copy to clipboard not implemented yet");
    }
    /**
     * Export results to text
     */
    exportResultsToText() {
      console.log("Export to text not implemented yet");
    }
    /**
     * Refresh results
     */
    refreshResults() {
      if (this.lastJobData) {
        this.generateRecommendations(this.lastJobData.title, this.lastJobData.description);
      }
    }
    /**
     * Retry generation
     */
    retryGeneration() {
      if (this.lastJobData) {
        this.generateRecommendations(this.lastJobData.title, this.lastJobData.description);
      }
    }
    /**
     * Add keyboard shortcuts
     */
    addKeyboardShortcuts() {
      const handleKeydown = (event) => {
        if ((event.ctrlKey || event.metaKey) && event.key === "Enter") {
          event.preventDefault();
          const form = this.container.querySelector(".job-input-form");
          if (form && this.processingState !== "processing") {
            this.handleFormSubmission(form);
          }
        }
      };
      document.addEventListener("keydown", handleKeydown);
    }
  };

  // src/ui/settings-tab.ts
  init_xss_safe_rendering();

  // src/ui/api-config.ts
  init_xss_safe_rendering();

  // src/services/openai-service.ts
  var OPENAI_BASE_URL = "https://api.openai.com/v1";
  var DEFAULT_MODEL = "text-embedding-3-small";
  var DEFAULT_DIMENSIONS = 1536;
  var RATE_LIMIT_CONFIG = {
    MAX_RETRIES: 3,
    BASE_DELAY: 1e3,
    // 1 second
    MAX_DELAY: 3e4,
    // 30 seconds
    JITTER_MAX: 0.1,
    // 10% jitter
    CONCURRENT_LIMIT: 3
    // Max concurrent requests
  };
  var OpenAIService = class {
    apiKey = null;
    currentRequests = 0;
    requestQueue = [];
    /**
     * Set OpenAI API key (stored in memory only)
     */
    setApiKey(key) {
      this.apiKey = key?.trim() || null;
    }
    /**
     * Get current API key status
     */
    hasApiKey() {
      return this.apiKey !== null && this.apiKey.length > 0;
    }
    /**
     * Clear stored API key
     */
    clearApiKey() {
      this.apiKey = null;
    }
    /**
     * Test API connection
     */
    async testConnection() {
      if (!this.hasApiKey()) {
        return { success: false, error: "No API key configured" };
      }
      try {
        await this.generateEmbedding("test", { skipCache: true });
        return { success: true };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        };
      }
    }
    /**
     * Generate embedding for text with caching and rate limiting
     */
    async generateEmbedding(text, options = {}) {
      if (!this.hasApiKey()) {
        throw new Error("OpenAI API key not configured");
      }
      const { model = DEFAULT_MODEL, dimensions = DEFAULT_DIMENSIONS } = options;
      if (!text || text.trim().length === 0) {
        throw new Error("Text cannot be empty");
      }
      const cleanText = text.trim().replace(/\s+/g, " ");
      await this.acquireRateLimit();
      try {
        const embedding = await this.makeEmbeddingRequest(cleanText, model, dimensions);
        return embedding;
      } finally {
        this.releaseRateLimit();
      }
    }
    /**
     * Generate embeddings for multiple texts (batch processing)
     */
    async generateEmbeddings(texts, options = {}) {
      const results = [];
      const { onProgress } = options;
      for (let i = 0; i < texts.length; i++) {
        const embedding = await this.generateEmbedding(texts[i] || "", options);
        results.push(embedding);
        if (onProgress) {
          onProgress(i + 1, texts.length);
        }
      }
      return results;
    }
    // ============================================================================
    // Private Methods
    // ============================================================================
    /**
     * Make the actual API request with retry logic
     */
    async makeEmbeddingRequest(text, model, dimensions, retryCount = 0) {
      try {
        const response = await fetch(`${OPENAI_BASE_URL}/embeddings`, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${this.apiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            input: text,
            model,
            dimensions
          })
        });
        if (response.status === 429) {
          const retryAfter = response.headers.get("Retry-After");
          const delay = retryAfter ? parseInt(retryAfter) * 1e3 : this.calculateBackoffDelay(retryCount);
          if (retryCount < RATE_LIMIT_CONFIG.MAX_RETRIES) {
            await this.sleep(delay);
            return this.makeEmbeddingRequest(text, model, dimensions, retryCount + 1);
          } else {
            throw new Error("Rate limit exceeded after maximum retries");
          }
        }
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          const errorMessage = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;
          throw new Error(`OpenAI API error: ${errorMessage}`);
        }
        const data = await response.json();
        if (!data.data || !Array.isArray(data.data) || data.data.length === 0) {
          throw new Error("Invalid embedding response format");
        }
        const embeddingData = data.data[0];
        if (!embeddingData?.embedding || !Array.isArray(embeddingData.embedding)) {
          throw new Error("Missing embedding data in response");
        }
        return new Float32Array(embeddingData.embedding);
      } catch (error) {
        if (retryCount < RATE_LIMIT_CONFIG.MAX_RETRIES && this.isRetryableError(error)) {
          const delay = this.calculateBackoffDelay(retryCount);
          await this.sleep(delay);
          return this.makeEmbeddingRequest(text, model, dimensions, retryCount + 1);
        }
        throw error;
      }
    }
    /**
     * Calculate exponential backoff delay with jitter
     */
    calculateBackoffDelay(retryCount) {
      const baseDelay = RATE_LIMIT_CONFIG.BASE_DELAY * Math.pow(2, retryCount);
      const cappedDelay = Math.min(baseDelay, RATE_LIMIT_CONFIG.MAX_DELAY);
      const jitter = cappedDelay * RATE_LIMIT_CONFIG.JITTER_MAX * Math.random();
      return cappedDelay + jitter;
    }
    /**
     * Determine if error is retryable
     */
    isRetryableError(error) {
      if (error instanceof Error) {
        const message = error.message.toLowerCase();
        return message.includes("network") || message.includes("timeout") || message.includes("fetch") || message.includes("connection");
      }
      return false;
    }
    /**
     * Acquire rate limit slot
     */
    async acquireRateLimit() {
      return new Promise((resolve) => {
        if (this.currentRequests < RATE_LIMIT_CONFIG.CONCURRENT_LIMIT) {
          this.currentRequests++;
          resolve();
        } else {
          this.requestQueue.push(() => {
            this.currentRequests++;
            resolve();
          });
        }
      });
    }
    /**
     * Release rate limit slot
     */
    releaseRateLimit() {
      this.currentRequests--;
      if (this.requestQueue.length > 0) {
        const nextRequest = this.requestQueue.shift();
        if (nextRequest) {
          nextRequest();
        }
      }
    }
    /**
     * Sleep utility
     */
    sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  };
  var globalOpenAIService = null;
  function getOpenAIService() {
    if (!globalOpenAIService) {
      globalOpenAIService = new OpenAIService();
    }
    return globalOpenAIService;
  }

  // src/ui/api-config.ts
  var APIConfig = class {
    container = null;
    /**
     * Render API configuration interface
     */
    async render(container) {
      this.container = container;
      container.innerHTML = "";
      const description = createSafeElement(
        "p",
        "Your OpenAI API key is stored locally in your browser and never exported.",
        "section-description"
      );
      const form = this.createForm();
      container.appendChild(description);
      container.appendChild(form);
    }
    /**
     * Create API key form
     */
    createForm() {
      const form = createSafeElement("div", "", "api-form");
      const inputGroup = createSafeElement("div", "", "input-group");
      const label = createSafeElement("label", "OpenAI API Key", "input-label");
      label.setAttribute("for", "api-key");
      const keyInput = document.createElement("input");
      keyInput.type = "password";
      keyInput.id = "api-key";
      keyInput.className = "form-input";
      keyInput.placeholder = "sk-...";
      const openaiService = getOpenAIService();
      if (openaiService.hasApiKey()) {
        keyInput.value = "***key-stored***";
        keyInput.disabled = true;
      }
      inputGroup.appendChild(label);
      inputGroup.appendChild(keyInput);
      const buttonGroup = createSafeElement("div", "", "button-group");
      const saveBtn = this.createSaveButton(keyInput);
      const testBtn = this.createTestButton();
      const forgetBtn = this.createForgetButton();
      buttonGroup.appendChild(saveBtn);
      buttonGroup.appendChild(testBtn);
      buttonGroup.appendChild(forgetBtn);
      form.appendChild(inputGroup);
      form.appendChild(buttonGroup);
      return form;
    }
    /**
     * Create save button
     */
    createSaveButton(keyInput) {
      const button = document.createElement("button");
      button.type = "button";
      button.className = "form-button form-button--primary";
      const openaiService = getOpenAIService();
      setSafeTextContent(button, openaiService.hasApiKey() ? "Update Key" : "Save Key");
      button.addEventListener("click", async () => {
        await this.saveKey(keyInput.value);
      });
      return button;
    }
    /**
     * Create test button
     */
    createTestButton() {
      const button = document.createElement("button");
      button.type = "button";
      button.className = "form-button form-button--secondary";
      setSafeTextContent(button, "Test Connection");
      button.addEventListener("click", async () => {
        await this.testConnection();
      });
      return button;
    }
    /**
     * Create forget button
     */
    createForgetButton() {
      const button = document.createElement("button");
      button.type = "button";
      button.className = "form-button form-button--danger";
      setSafeTextContent(button, "Forget Key");
      const openaiService = getOpenAIService();
      button.style.display = openaiService.hasApiKey() ? "inline-block" : "none";
      button.addEventListener("click", () => {
        this.forgetKey();
      });
      return button;
    }
    // ============================================================================
    // Actions
    // ============================================================================
    /**
     * Save API key
     */
    async saveKey(key) {
      if (!key || key === "***key-stored***") {
        alert("Please enter a valid API key");
        return;
      }
      try {
        const openaiService = getOpenAIService();
        openaiService.setApiKey(key);
        const result = await openaiService.testConnection();
        if (!result.success) {
          openaiService.clearApiKey();
          throw new Error(result.error || "Connection test failed");
        }
        alert("API key saved and tested successfully");
        if (this.container) {
          await this.render(this.container);
        }
      } catch (error) {
        alert(`Failed to save API key: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Test connection
     */
    async testConnection() {
      const openaiService = getOpenAIService();
      if (!openaiService.hasApiKey()) {
        alert("No API key configured");
        return;
      }
      try {
        const result = await openaiService.testConnection();
        if (result.success) {
          alert("Connection test successful");
        } else {
          alert(`Connection test failed: ${result.error}`);
        }
      } catch (error) {
        alert(`Connection test failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Forget API key
     */
    forgetKey() {
      if (confirm("Are you sure you want to forget your API key? This will disable AI functionality.")) {
        const openaiService = getOpenAIService();
        openaiService.clearApiKey();
        if (this.container) {
          this.render(this.container);
        }
        alert("API key forgotten");
      }
    }
  };

  // src/ui/role-manager.ts
  init_xss_safe_rendering();
  init_transactions();

  // src/utils/simple-modal.ts
  init_xss_safe_rendering();
  function createSimpleModal(title, formContent, onSubmit, onCancel) {
    const mainContent = document.querySelector(".main-content") || document.body;
    const backdrop = createSafeElement("div", "", "modal-backdrop");
    backdrop.style.cssText = `
    position: fixed;
    top: 0;
    left: 250px;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  `;
    const modal = createSafeElement("div", "", "modal-content");
    modal.style.cssText = `
    background: white;
    border-radius: 8px;
    padding: 0;
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
  `;
    const header = createSafeElement("div", "", "modal-header");
    header.style.cssText = `
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
  `;
    const titleElement = createSafeElement("h2", title, "modal-title");
    titleElement.style.cssText = `
    margin: 0;
    font-size: 1.25rem;
    font-weight: 600;
  `;
    const closeButton = document.createElement("button");
    closeButton.type = "button";
    closeButton.className = "close-button";
    closeButton.style.cssText = `
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
  `;
    setSafeTextContent(closeButton, "\xD7");
    header.appendChild(titleElement);
    header.appendChild(closeButton);
    const body = createSafeElement("div", "", "modal-body");
    body.style.cssText = `
    padding: 1.5rem;
  `;
    body.appendChild(formContent);
    const footer = createSafeElement("div", "", "modal-footer");
    footer.style.cssText = `
    padding: 1rem 1.5rem;
    border-top: 1px solid #e5e7eb;
    display: flex;
    gap: 0.5rem;
    justify-content: flex-end;
  `;
    const cancelBtn = document.createElement("button");
    cancelBtn.type = "button";
    cancelBtn.className = "form-button form-button--secondary";
    cancelBtn.style.cssText = `
    padding: 0.5rem 1rem;
    border: 1px solid #d1d5db;
    background: white;
    border-radius: 4px;
    cursor: pointer;
  `;
    setSafeTextContent(cancelBtn, "Cancel");
    const submitBtn = document.createElement("button");
    submitBtn.type = "button";
    submitBtn.className = "form-button form-button--primary";
    submitBtn.style.cssText = `
    padding: 0.5rem 1rem;
    border: none;
    background: #3b82f6;
    color: white;
    border-radius: 4px;
    cursor: pointer;
  `;
    setSafeTextContent(submitBtn, "Save");
    footer.appendChild(cancelBtn);
    footer.appendChild(submitBtn);
    modal.appendChild(header);
    modal.appendChild(body);
    modal.appendChild(footer);
    backdrop.appendChild(modal);
    const closeModal = () => {
      mainContent.removeChild(backdrop);
      document.removeEventListener("keydown", handleKeydown);
      if (onCancel) onCancel();
    };
    const handleSubmit = async () => {
      try {
        const formData = new FormData();
        const inputs = modal.querySelectorAll("input, select, textarea");
        inputs.forEach((input) => {
          const element = input;
          if (element.name) {
            if (element.type === "checkbox") {
              formData.append(element.name, element.checked ? "true" : "false");
            } else {
              formData.append(element.name, element.value);
            }
          }
        });
        await onSubmit(formData);
        closeModal();
      } catch (error) {
        console.error("Modal submit error:", error);
        alert(error instanceof Error ? error.message : "An error occurred");
      }
    };
    const handleKeydown = (event) => {
      if (event.key === "Escape") {
        closeModal();
      } else if (event.key === "Enter" && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();
        handleSubmit();
      }
    };
    closeButton.addEventListener("click", closeModal);
    cancelBtn.addEventListener("click", closeModal);
    submitBtn.addEventListener("click", handleSubmit);
    backdrop.addEventListener("click", (event) => {
      if (event.target === backdrop) {
        closeModal();
      }
    });
    document.addEventListener("keydown", handleKeydown);
    mainContent.appendChild(backdrop);
    const firstInput = modal.querySelector("input, select, textarea");
    if (firstInput) {
      firstInput.focus();
    }
  }

  // src/ui/role-manager.ts
  var RoleManager = class {
    container = null;
    roles = [];
    sortBy = "endDate";
    /**
     * Render role management interface
     */
    async render(container) {
      this.container = container;
      await this.loadRoles();
      container.innerHTML = "";
      const header = this.createHeader();
      const rolesList = this.createRolesList();
      container.appendChild(header);
      container.appendChild(rolesList);
    }
    /**
     * Create header with add button and sort control
     */
    createHeader() {
      const header = createSafeElement("div", "", "role-manager-header");
      header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1rem;
    `;
      const leftSection = createSafeElement("div", "", "header-left");
      const description = createSafeElement(
        "p",
        "Roles are automatically sorted by date (most recent first). Set bullet limits for recommendations.",
        "section-description"
      );
      const addBtn = document.createElement("button");
      addBtn.className = "form-button form-button--primary";
      addBtn.style.marginTop = "0.5rem";
      setSafeTextContent(addBtn, "Add Role");
      addBtn.addEventListener("click", () => this.showAddModal());
      leftSection.appendChild(description);
      leftSection.appendChild(addBtn);
      const sortSection = createSafeElement("div", "", "header-sort");
      const sortLabel = createSafeElement("label", "Sort by:", "sort-label");
      sortLabel.style.cssText = `
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      color: #374151;
      margin-bottom: 0.25rem;
    `;
      const sortSelect = document.createElement("select");
      sortSelect.style.cssText = `
      padding: 0.375rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 0.875rem;
      background: white;
    `;
      const endDateOption = document.createElement("option");
      endDateOption.value = "endDate";
      setSafeTextContent(endDateOption, "End Date");
      endDateOption.selected = this.sortBy === "endDate";
      const startDateOption = document.createElement("option");
      startDateOption.value = "startDate";
      setSafeTextContent(startDateOption, "Start Date");
      startDateOption.selected = this.sortBy === "startDate";
      sortSelect.appendChild(endDateOption);
      sortSelect.appendChild(startDateOption);
      sortSelect.addEventListener("change", () => {
        this.sortBy = sortSelect.value;
        this.render(this.container);
      });
      sortSection.appendChild(sortLabel);
      sortSection.appendChild(sortSelect);
      header.appendChild(leftSection);
      header.appendChild(sortSection);
      return header;
    }
    /**
     * Create roles list
     */
    createRolesList() {
      const container = createSafeElement("div", "", "roles-list");
      container.style.cssText = `
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 0.75rem;
    `;
      if (this.roles.length === 0) {
        const empty = createSafeElement("div", "No roles configured. Add your first role to get started.", "empty-state");
        empty.style.cssText = `
        padding: 2rem;
        text-align: center;
        color: #6b7280;
        border: 2px dashed #d1d5db;
        border-radius: 8px;
      `;
        container.appendChild(empty);
        return container;
      }
      const sortedRoles = this.getSortedRoles();
      sortedRoles.forEach((role) => {
        const item = this.createRoleCard(role);
        container.appendChild(item);
      });
      return container;
    }
    /**
     * Get roles sorted by current criteria
     */
    getSortedRoles() {
      return [...this.roles].sort((a, b) => {
        if (this.sortBy === "endDate") {
          const aDate = a.endDate || "9999-99";
          const bDate = b.endDate || "9999-99";
          return bDate.localeCompare(aDate);
        } else {
          return b.startDate.localeCompare(a.startDate);
        }
      });
    }
    /**
     * Create compact role card
     */
    createRoleCard(role) {
      const card = createSafeElement("div", "", "role-card");
      card.style.cssText = `
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 0.75rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      transition: box-shadow 0.15s ease;
    `;
      const topLine = createSafeElement("div", "", "role-top-line");
      topLine.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    `;
      const nameSection = createSafeElement("div", "", "role-name");
      const title = createSafeElement("div", `${role.title} at ${role.company}`, "role-title");
      title.style.cssText = `
      font-weight: 600;
      font-size: 0.95rem;
      color: #111827;
    `;
      nameSection.appendChild(title);
      const dateSection = createSafeElement("div", "", "role-date");
      const dates = createSafeElement("div", this.formatDateRange(role), "role-dates");
      dates.style.cssText = `
      color: #6b7280;
      font-size: 0.8rem;
      text-align: right;
    `;
      dateSection.appendChild(dates);
      topLine.appendChild(nameSection);
      topLine.appendChild(dateSection);
      const bottomLine = createSafeElement("div", "", "role-bottom-line");
      bottomLine.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
    `;
      const bulletsSection = createSafeElement("div", "", "role-bullets");
      bulletsSection.style.cssText = `
      display: flex;
      align-items: center;
      gap: 0.5rem;
    `;
      const bulletsLabel = createSafeElement("span", "Bullets:", "bullets-label");
      bulletsLabel.style.cssText = `
      font-size: 0.8rem;
      color: #374151;
      font-weight: 500;
    `;
      const limitInput = document.createElement("input");
      limitInput.type = "number";
      limitInput.min = "1";
      limitInput.max = "10";
      limitInput.value = role.bulletsLimit.toString();
      limitInput.style.cssText = `
      width: 50px;
      padding: 0.2rem 0.4rem;
      border: 1px solid #d1d5db;
      border-radius: 3px;
      text-align: center;
      font-size: 0.8rem;
    `;
      limitInput.addEventListener("change", () => this.updateLimit(role.id, parseInt(limitInput.value)));
      bulletsSection.appendChild(bulletsLabel);
      bulletsSection.appendChild(limitInput);
      const actionsSection = createSafeElement("div", "", "role-actions");
      actionsSection.style.cssText = `
      display: flex;
      gap: 0.4rem;
    `;
      const editBtn = this.createActionButton("Edit", "secondary", () => this.showEditModal(role.id));
      const deleteBtn = this.createActionButton("Delete", "danger", () => this.deleteRole(role.id));
      actionsSection.appendChild(editBtn);
      actionsSection.appendChild(deleteBtn);
      bottomLine.appendChild(bulletsSection);
      bottomLine.appendChild(actionsSection);
      card.appendChild(topLine);
      card.appendChild(bottomLine);
      card.addEventListener("mouseenter", () => {
        card.style.boxShadow = "0 3px 6px rgba(0, 0, 0, 0.15)";
      });
      card.addEventListener("mouseleave", () => {
        card.style.boxShadow = "0 1px 3px rgba(0, 0, 0, 0.1)";
      });
      return card;
    }
    /**
     * Create compact action button
     */
    createActionButton(text, variant, onClick) {
      const button = document.createElement("button");
      button.type = "button";
      setSafeTextContent(button, text);
      button.addEventListener("click", onClick);
      const baseStyles = `
      padding: 0.3rem 0.6rem;
      border-radius: 3px;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    `;
      if (variant === "danger") {
        button.style.cssText = baseStyles + `
        background: #fef2f2;
        color: #dc2626;
        border: 1px solid #fecaca;
      `;
      } else {
        button.style.cssText = baseStyles + `
        background: #f9fafb;
        color: #374151;
        border: 1px solid #d1d5db;
      `;
      }
      return button;
    }
    // ============================================================================
    // Actions
    // ============================================================================
    /**
     * Update bullet limit
     */
    async updateLimit(roleId, limit) {
      if (limit < 1 || limit > 10 || isNaN(limit)) {
        alert("Bullet limit must be between 1 and 10");
        if (this.container) await this.render(this.container);
        return;
      }
      try {
        const role = this.roles.find((r) => r.id === roleId);
        if (!role) return;
        role.bulletsLimit = limit;
        await update("roles", role);
      } catch (error) {
        alert(`Failed to update limit: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Delete role
     */
    async deleteRole(roleId) {
      const role = this.roles.find((r) => r.id === roleId);
      if (!role) return;
      if (!confirm(`Delete "${role.title} at ${role.company}"? This will also delete associated data.`)) {
        return;
      }
      try {
        await deleteById("roles", roleId);
        if (this.container) await this.render(this.container);
      } catch (error) {
        alert(`Failed to delete role: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Show add modal
     */
    showAddModal() {
      createSimpleModal("Add Role", this.createRoleForm(), (formData) => {
        this.saveRole(formData);
      });
    }
    /**
     * Show edit modal
     */
    showEditModal(roleId) {
      const role = this.roles.find((r) => r.id === roleId);
      if (!role) return;
      createSimpleModal("Edit Role", this.createRoleForm(role), (formData) => {
        this.saveRole(formData, role.id);
      });
    }
    /**
     * Create role form with simple date inputs
     */
    createRoleForm(role) {
      const form = createSafeElement("div", "", "role-form");
      const titleGroup = this.createInputGroup("title", "Job Title", "text", "e.g., Senior Product Manager");
      if (role) titleGroup.querySelector("input").value = role.title;
      const companyGroup = this.createInputGroup("company", "Company", "text", "e.g., Google");
      if (role) companyGroup.querySelector("input").value = role.company;
      const startGroup = this.createDateInputGroup("startDate", "Start Date", "e.g., 2023-01");
      if (role) startGroup.querySelector("input").value = role.startDate;
      const endGroup = this.createDateInputGroup("endDate", "End Date", "e.g., 2024-12");
      if (role && role.endDate) endGroup.querySelector("input").value = role.endDate;
      const currentGroup = createSafeElement("div", "", "input-group");
      const currentLabel = createSafeElement("label", "", "checkbox-label");
      const currentCheckbox = document.createElement("input");
      currentCheckbox.type = "checkbox";
      currentCheckbox.name = "isCurrent";
      currentCheckbox.checked = role ? !role.endDate : false;
      const checkboxText = createSafeElement("span", "This is my current role", "");
      currentLabel.appendChild(currentCheckbox);
      currentLabel.appendChild(checkboxText);
      currentGroup.appendChild(currentLabel);
      const endInput = endGroup.querySelector("input");
      const updateEndDateState = () => {
        endInput.disabled = currentCheckbox.checked;
        if (currentCheckbox.checked) {
          endInput.value = "";
        }
      };
      currentCheckbox.addEventListener("change", updateEndDateState);
      updateEndDateState();
      form.appendChild(titleGroup);
      form.appendChild(companyGroup);
      form.appendChild(startGroup);
      form.appendChild(endGroup);
      form.appendChild(currentGroup);
      return form;
    }
    /**
     * Create input group helper
     */
    createInputGroup(name, label, type, placeholder) {
      const group = createSafeElement("div", "", "input-group");
      const labelElement = createSafeElement("label", label, "input-label");
      const input = document.createElement("input");
      input.type = type;
      input.name = name;
      input.className = "form-input";
      input.placeholder = placeholder;
      if (name === "title" || name === "company") {
        input.required = true;
      }
      group.appendChild(labelElement);
      group.appendChild(input);
      return group;
    }
    /**
     * Create date input group with validation
     */
    createDateInputGroup(name, label, placeholder) {
      const group = createSafeElement("div", "", "input-group");
      const labelElement = createSafeElement("label", label, "input-label");
      const input = document.createElement("input");
      input.type = "text";
      input.name = name;
      input.className = "form-input";
      input.placeholder = placeholder;
      input.pattern = "^\\d{4}-\\d{2}$";
      input.title = "Format: YYYY-MM (e.g., 2023-01)";
      const helper = createSafeElement("small", "Format: YYYY-MM", "input-helper");
      if (name === "startDate") {
        input.required = true;
      }
      group.appendChild(labelElement);
      group.appendChild(input);
      group.appendChild(helper);
      return group;
    }
    /**
     * Save role
     */
    async saveRole(formData, roleId) {
      const title = formData.get("title");
      const company = formData.get("company");
      const startDate = formData.get("startDate");
      const endDate = formData.get("endDate");
      const isCurrent = formData.get("isCurrent") === "true";
      if (!title || !company || !startDate) {
        alert("Title, company, and start date are required");
        return;
      }
      const datePattern = /^\d{4}-\d{2}$/;
      if (!datePattern.test(startDate)) {
        alert("Start date must be in YYYY-MM format (e.g., 2023-01)");
        return;
      }
      if (endDate && !isCurrent && !datePattern.test(endDate)) {
        alert("End date must be in YYYY-MM format (e.g., 2024-12)");
        return;
      }
      try {
        if (roleId) {
          const role = this.roles.find((r) => r.id === roleId);
          if (role) {
            role.title = title;
            role.company = company;
            role.startDate = startDate;
            role.endDate = isCurrent ? null : endDate || null;
            await update("roles", role);
          }
        } else {
          const newRole = {
            id: `role_${Date.now()}`,
            title,
            company,
            orderIndex: 0,
            // Not used anymore but keeping for compatibility
            bulletsLimit: 3,
            startDate,
            endDate: isCurrent ? null : endDate || null
          };
          await update("roles", newRole);
        }
        if (this.container) await this.render(this.container);
      } catch (error) {
        alert(`Failed to save role: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    // ============================================================================
    // Utilities
    // ============================================================================
    /**
     * Load roles from storage
     */
    async loadRoles() {
      this.roles = await getAll("roles");
    }
    /**
     * Format date range
     */
    formatDateRange(role) {
      return role.endDate ? `${role.startDate} - ${role.endDate}` : `${role.startDate} - Present`;
    }
  };

  // src/ui/settings-tab.ts
  init_transactions();
  var SettingsTab = class {
    container;
    apiConfig;
    roleManager;
    constructor(container) {
      this.container = container;
      this.apiConfig = new APIConfig();
      this.roleManager = new RoleManager();
    }
    // ============================================================================
    // Public Interface
    // ============================================================================
    /**
     * Render the Settings tab content
     */
    async render() {
      this.container.innerHTML = "";
      const tabContainer = createSafeElement("div", "", "settings-tab");
      const apiSection = await this.createAPISection();
      const roleSection = await this.createRoleSection();
      const dataSection = await this.createDataSection();
      tabContainer.appendChild(apiSection);
      tabContainer.appendChild(roleSection);
      tabContainer.appendChild(dataSection);
      this.container.appendChild(tabContainer);
    }
    // ============================================================================
    // Section Creation
    // ============================================================================
    /**
     * Create API configuration section
     */
    async createAPISection() {
      const section = createSafeElement("section", "", "settings-section");
      const title = createSafeElement("h2", "AI Configuration", "section-title");
      const configContainer = createSafeElement("div", "", "api-config-container");
      await this.apiConfig.render(configContainer);
      section.appendChild(title);
      section.appendChild(configContainer);
      return section;
    }
    /**
     * Create role management section
     */
    async createRoleSection() {
      const section = createSafeElement("section", "", "settings-section");
      const title = createSafeElement("h2", "Role Management", "section-title");
      const managerContainer = createSafeElement("div", "", "role-manager-container");
      await this.roleManager.render(managerContainer);
      section.appendChild(title);
      section.appendChild(managerContainer);
      return section;
    }
    /**
     * Create data management section
     */
    async createDataSection() {
      const section = createSafeElement("section", "", "settings-section");
      const title = createSafeElement("h2", "Data Management", "section-title");
      const usage = await this.createStorageUsage();
      const actions = this.createDataActions();
      section.appendChild(title);
      section.appendChild(usage);
      section.appendChild(actions);
      return section;
    }
    /**
     * Create storage usage display
     */
    async createStorageUsage() {
      const container = createSafeElement("div", "", "storage-usage");
      try {
        const [roles, bullets, projects] = await Promise.all([
          getAll("roles"),
          getAll("bullets"),
          getAll("projects")
        ]);
        const stats = createSafeElement("div", "", "usage-stats");
        const roleCount = createSafeElement("span", `${roles.length} roles`, "stat-item");
        const bulletCount = createSafeElement("span", `${bullets.length} bullets`, "stat-item");
        const projectCount = createSafeElement("span", `${projects.length} projects`, "stat-item");
        stats.appendChild(roleCount);
        stats.appendChild(bulletCount);
        stats.appendChild(projectCount);
        container.appendChild(stats);
      } catch (error) {
        const errorMsg = createSafeElement("div", "Unable to load storage usage", "error-text");
        container.appendChild(errorMsg);
      }
      return container;
    }
    /**
     * Create data action buttons
     */
    createDataActions() {
      const actions = createSafeElement("div", "", "data-actions");
      const exportBtn = document.createElement("button");
      exportBtn.className = "form-button form-button--secondary";
      setSafeTextContent(exportBtn, "Export Data");
      exportBtn.addEventListener("click", () => this.exportData());
      const importBtn = document.createElement("button");
      importBtn.className = "form-button form-button--secondary";
      setSafeTextContent(importBtn, "Import Data");
      importBtn.addEventListener("click", () => this.importData());
      actions.appendChild(exportBtn);
      actions.appendChild(importBtn);
      return actions;
    }
    // ============================================================================
    // Data Operations
    // ============================================================================
    /**
     * Export all data
     */
    async exportData() {
      try {
        const [roles, projects, bullets] = await Promise.all([
          getAll("roles"),
          getAll("projects"),
          getAll("bullets")
        ]);
        const exportData = {
          version: 1,
          timestamp: Date.now(),
          data: { roles, projects, bullets }
        };
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `resuum-export-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
        link.click();
        URL.revokeObjectURL(url);
      } catch (error) {
        alert(`Export failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Import data
     */
    importData() {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.addEventListener("change", async (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        try {
          const text = await file.text();
          const importData = JSON.parse(text);
          if (!importData.version || !importData.data) {
            throw new Error("Invalid file format");
          }
          alert("Import functionality coming soon");
        } catch (error) {
          alert(`Import failed: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      });
      input.click();
    }
  };

  // src/ui/app.ts
  var TAB_CONFIGS = [
    {
      id: "application",
      label: "New Application",
      icon: "\u{1F4DD}",
      description: "Generate recommendations for a job application"
    },
    {
      id: "experience",
      label: "Experience",
      icon: "\u{1F4BC}",
      description: "Manage your bullet points and projects"
    },
    {
      id: "settings",
      label: "Settings",
      icon: "\u2699\uFE0F",
      description: "Configure API key and data management"
    }
  ];
  var ResuumApp = class {
    state = {
      currentTab: "application",
      loading: false
    };
    container;
    tabNavigation = null;
    tabContent = null;
    statusBar = null;
    // Tab instances
    applicationTab = null;
    settingsTab = null;
    constructor(containerId) {
      const container = document.getElementById(containerId);
      if (!container) {
        throw new Error(`Container element with id "${containerId}" not found`);
      }
      this.container = container;
    }
    // ============================================================================
    // Initialization
    // ============================================================================
    /**
     * Initialize the application UI
     */
    async initialize() {
      try {
        this.showLoading("Initializing Resuum...");
        this.container.innerHTML = "";
        this.buildUIStructure();
        await this.switchTab("application");
        this.hideLoading();
        this.showSuccess("Resuum initialized successfully");
      } catch (error) {
        this.showError(`Failed to initialize: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Build the main UI structure
     */
    buildUIStructure() {
      this.container.innerHTML = "";
      const sidebarNav = document.getElementById("sidebar-nav");
      if (sidebarNav) {
        const navigation = this.createTabNavigation();
        sidebarNav.appendChild(navigation);
        this.tabNavigation = navigation;
      }
      const content = this.createTabContent();
      const status = this.createStatusBar();
      this.container.appendChild(content);
      this.container.appendChild(status);
      this.tabContent = content;
      this.statusBar = status;
    }
    /**
     * Create tab navigation
     */
    createTabNavigation() {
      const nav = createSafeElement("nav", "", "tab-navigation");
      const tabList = createSafeElement("ul", "", "tab-list");
      TAB_CONFIGS.forEach((tabConfig) => {
        const tabItem = this.createTabItem(tabConfig);
        tabList.appendChild(tabItem);
      });
      nav.appendChild(tabList);
      return nav;
    }
    /**
     * Create individual tab item
     */
    createTabItem(config) {
      const listItem = createSafeElement("li", "", "tab-item");
      const button = document.createElement("button");
      button.className = `tab-button ${this.state.currentTab === config.id ? "tab-button--active" : ""}`;
      button.setAttribute("data-tab", config.id);
      button.setAttribute("aria-label", config.description);
      const icon = createSafeElement("span", config.icon, "tab-icon");
      const label = createSafeElement("span", config.label, "tab-label");
      button.appendChild(icon);
      button.appendChild(label);
      button.addEventListener("click", () => {
        this.switchTab(config.id);
      });
      button.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          this.switchTab(config.id);
        }
      });
      listItem.appendChild(button);
      return listItem;
    }
    /**
     * Create tab content container
     */
    createTabContent() {
      return createSafeElement("div", "", "tab-content");
    }
    /**
     * Create status bar
     */
    createStatusBar() {
      return createSafeElement("div", "", "status-bar");
    }
    // ============================================================================
    // Tab Management
    // ============================================================================
    /**
     * Switch to a different tab
     */
    async switchTab(tabName) {
      try {
        this.state.currentTab = tabName;
        this.updateTabNavigation();
        await this.loadTabContent(tabName);
      } catch (error) {
        this.showError(`Failed to switch to ${tabName} tab: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Update tab navigation visual state
     */
    updateTabNavigation() {
      if (!this.tabNavigation) return;
      const buttons = this.tabNavigation.querySelectorAll(".tab-button");
      buttons.forEach((button) => {
        const isActive = button.getAttribute("data-tab") === this.state.currentTab;
        button.classList.toggle("tab-button--active", isActive);
        button.setAttribute("aria-selected", isActive.toString());
      });
    }
    /**
     * Load content for the current tab
     */
    async loadTabContent(tabName) {
      if (!this.tabContent) return;
      this.tabContent.innerHTML = "";
      switch (tabName) {
        case "application":
          await this.loadApplicationTab();
          break;
        case "experience":
          this.loadExperienceTab();
          break;
        case "settings":
          await this.loadSettingsTab();
          break;
        default:
          throw new Error(`Unknown tab: ${tabName}`);
      }
    }
    /**
     * Load New Application tab content
     */
    async loadApplicationTab() {
      if (!this.tabContent) return;
      try {
        if (!this.applicationTab) {
          this.applicationTab = new ApplicationTab(this.tabContent);
        }
        this.applicationTab.render();
      } catch (error) {
        this.showError(`Failed to load application tab: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Load Experience tab content (placeholder)
     */
    /**
     * Load Experience tab content (FIXED VERSION)
     * Replace the existing loadExperienceTab() method in app.ts with this
     */
    async loadExperienceTab() {
      if (!this.tabContent) return;
      console.log("Loading Experience tab...");
      try {
        this.tabContent.innerHTML = "";
        const { ExperienceTab: ExperienceTab2 } = await Promise.resolve().then(() => (init_experience_tab(), experience_tab_exports));
        console.log("ExperienceTab imported successfully");
        console.log("Creating ExperienceTab instance...");
        const experienceTab = new ExperienceTab2(this.tabContent);
        console.log("Rendering ExperienceTab...");
        await experienceTab.render();
        console.log("ExperienceTab rendered successfully");
      } catch (error) {
        console.error("Experience tab error:", error);
        if (this.tabContent) {
          this.tabContent.innerHTML = `
          <div style="color: red; padding: 1rem; border: 1px solid #ff0000; border-radius: 4px; margin: 1rem;">
            <h3>Experience Tab Error</h3>
            <p>Failed to load Experience tab: ${error instanceof Error ? error.message : "Unknown error"}</p>
            <details>
              <summary>Click for Error Details</summary>
              <pre style="background: #f5f5f5; padding: 1rem; margin-top: 0.5rem; overflow: auto;">${error instanceof Error ? error.stack : JSON.stringify(error, null, 2)}</pre>
            </details>
            <br>
            <button onclick="location.reload()" style="padding: 0.5rem 1rem; background: #007cba; color: white; border: none; border-radius: 4px; cursor: pointer;">
              Reload Page
            </button>
          </div>
        `;
        }
      }
    }
    /**
     * Load Settings tab content
     */
    async loadSettingsTab() {
      if (!this.tabContent) return;
      try {
        if (!this.settingsTab) {
          this.settingsTab = new SettingsTab(this.tabContent);
        }
        await this.settingsTab.render();
      } catch (error) {
        this.showError(`Failed to load settings tab: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    /**
     * Generate recommendations (placeholder)
     */
    async generateRecommendations() {
      try {
        this.showLoading("Generating recommendations...");
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        this.showSuccess("Recommendations generated successfully");
      } catch (error) {
        this.showError(`Failed to generate recommendations: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    // ============================================================================
    // State Management
    // ============================================================================
    /**
     * Show loading state
     */
    showLoading(message) {
      this.state.loading = true;
      this.state.error = void 0;
      this.state.success = void 0;
      this.updateStatusBar(message, "loading");
    }
    /**
     * Hide loading state
     */
    hideLoading() {
      this.state.loading = false;
      this.updateStatusBar("", "hidden");
    }
    /**
     * Show error message
     */
    showError(message) {
      this.state.loading = false;
      this.state.error = message;
      this.state.success = void 0;
      this.updateStatusBar(message, "error");
    }
    /**
     * Show success message
     */
    showSuccess(message) {
      this.state.loading = false;
      this.state.error = void 0;
      this.state.success = message;
      this.updateStatusBar(message, "success");
      setTimeout(() => {
        if (this.state.success === message) {
          this.hideLoading();
        }
      }, 3e3);
    }
    /**
     * Update status bar
     */
    updateStatusBar(message, type) {
      if (!this.statusBar) return;
      this.statusBar.innerHTML = "";
      this.statusBar.className = `status-bar status-bar--${type}`;
      if (type !== "hidden" && message) {
        let element;
        switch (type) {
          case "loading":
            element = createSafeElement("div", `\u23F3 ${message}`, "status-message");
            break;
          case "error":
            element = createErrorElement(message);
            break;
          case "success":
            element = createSuccessElement(`\u2713 ${message}`);
            break;
          default:
            element = createSafeElement("div", message, "status-message");
        }
        this.statusBar.appendChild(element);
      }
    }
    // ============================================================================
    // Public API
    // ============================================================================
    /**
     * Get current application state
     */
    getState() {
      return { ...this.state };
    }
    /**
     * Navigate to specific tab programmatically
     */
    async navigateToTab(tabName) {
      await this.switchTab(tabName);
    }
  };

  // src/main.ts
  console.log("Main.ts loaded - initializing app...");
  var loadingDiv = document.getElementById("loading");
  if (loadingDiv) {
    loadingDiv.remove();
  }
  try {
    const app = new ResuumApp("app");
    app.initialize();
    console.log("ResuumApp initialized successfully");
  } catch (error) {
    console.error("App initialization failed:", error);
    const container = document.getElementById("app");
    if (container) {
      container.innerHTML = `<div style="color: red; padding: 1rem;">
      App failed to load: ${error instanceof Error ? error.message : "Unknown error"}
      <br><br>
      Check browser console for details.
    </div>`;
    }
  }
})();

    </script>
</body>
</html>